// Copyright Tharsis Labs Ltd.(Evmos)
// SPDX-License-Identifier:ENCL-1.0(https://github.com/evmos/apps/blob/main/LICENSE)

/* eslint-disable */
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/evmos/claims/v1/claims_records": {
    /** ClaimsRecords returns all claims records */
    get: operations["ClaimsRecords"];
  };
  "/evmos/claims/v1/claims_records/{address}": {
    /** ClaimsRecord returns the claims record for a given address */
    get: operations["ClaimsRecord"];
  };
  "/evmos/claims/v1/params": {
    /** Params returns the claims module parameters */
    get: operations["ClaimsParams"];
  };
  "/evmos/claims/v1/total_unclaimed": {
    /** TotalUnclaimed queries the total unclaimed tokens from the airdrop */
    get: operations["TotalUnclaimed"];
  };
  "/evmos/epochs/v1/current_epoch": {
    /** CurrentEpoch provide current epoch of specified identifier */
    get: operations["CurrentEpoch"];
  };
  "/evmos/epochs/v1/epochs": {
    /** EpochInfos provide running epochInfos */
    get: operations["EpochInfos"];
  };
  "/evmos/erc20/v1/params": {
    /** Params retrieves the erc20 module params */
    get: operations["ERC20Params"];
  };
  "/evmos/erc20/v1/token_pairs": {
    /** TokenPairs retrieves registered token pairs */
    get: operations["TokenPairs"];
  };
  "/evmos/erc20/v1/token_pairs/{token}": {
    /** TokenPair retrieves a registered token pair */
    get: operations["TokenPair"];
  };
  "/evmos/incentives/v1/allocation_meters": {
    /**
     * AllocationMeters retrieves active allocation meters for a given
     * denomination
     */
    get: operations["AllocationMeters"];
  };
  "/evmos/incentives/v1/allocation_meters/{denom}": {
    /** AllocationMeter retrieves a active gas meter */
    get: operations["AllocationMeter"];
  };
  "/evmos/incentives/v1/gas_meters/{contract}": {
    /** GasMeters retrieves active gas meters for a given contract */
    get: operations["GasMeters"];
  };
  "/evmos/incentives/v1/gas_meters/{contract}/{participant}": {
    /** GasMeter retrieves a active gas meter */
    get: operations["GasMeter"];
  };
  "/evmos/incentives/v1/incentives": {
    /** Incentives retrieves registered incentives */
    get: operations["Incentives"];
  };
  "/evmos/incentives/v1/incentives/{contract}": {
    /** Incentive retrieves a registered incentive */
    get: operations["Incentive"];
  };
  "/evmos/incentives/v1/params": {
    /** Params retrieves the incentives module params */
    get: operations["IncentivesParams"];
  };
  "/evmos/inflation/v1/circulating_supply": {
    /**
     * CirculatingSupply retrieves the total number of tokens that are in
     * circulation (i.e. excluding unvested tokens).
     */
    get: operations["CirculatingSupply"];
  };
  "/evmos/inflation/v1/epoch_mint_provision": {
    /** EpochMintProvision retrieves current minting epoch provision value. */
    get: operations["EpochMintProvision"];
  };
  "/evmos/inflation/v1/inflation_rate": {
    /** InflationRate retrieves the inflation rate of the current period. */
    get: operations["InflationRate"];
  };
  "/evmos/inflation/v1/params": {
    /** Params retrieves the total set of minting parameters. */
    get: operations["InflationParams"];
  };
  "/evmos/inflation/v1/period": {
    /** Period retrieves current period. */
    get: operations["Period"];
  };
  "/evmos/inflation/v1/skipped_epochs": {
    /** SkippedEpochs retrieves the total number of skipped epochs. */
    get: operations["SkippedEpochs"];
  };
  "/evmos/vesting/v1/balances/{address}": {
    /** Balances retrieves the unvested, vested and locked tokens for a vesting account */
    get: operations["Balances"];
  };
  "/evmos/recovery/v1/params": {
    /** Params retrieves the total set of recovery parameters. */
    get: operations["RecoveryParams"];
  };
  "/evmos/revenue/v1/params": {
    /** Params retrieves the revenue module params */
    get: operations["RevenueParams"];
  };
  "/evmos/revenue/v1/revenues": {
    /** Revenues retrieves all registered revenues */
    get: operations["Revenues"];
  };
  "/evmos/revenue/v1/revenues/{contract_address}": {
    /** Revenue retrieves a registered revenue for a given contract address */
    get: operations["Revenue"];
  };
  "/evmos/revenue/v1/revenues/{deployer_address}": {
    /**
     * DeployerRevenues retrieves all revenues that a given deployer has
     * registered
     */
    get: operations["DeployerRevenues"];
  };
  "/evmos/revenue/v1/revenues/{withdrawer_address}": {
    /**
     * WithdrawerRevenues retrieves all revenues with a given withdrawer
     * address
     */
    get: operations["WithdrawerRevenues"];
  };
  "/evmos/evm/v1/account/{address}": {
    /** Account queries an Ethereum account. */
    get: operations["Account"];
  };
  "/evmos/evm/v1/balances/{address}": {
    /**
     * Balance queries the balance of a the EVM denomination for a single
     * EthAccount.
     */
    get: operations["Balance"];
  };
  "/evmos/evm/v1/base_fee": {
    /**
     * BaseFee queries the base fee of the parent block of the current block,
     * it's similar to feemarket module's method, but also checks london hardfork status.
     */
    get: operations["BaseFee"];
  };
  "/evmos/evm/v1/codes/{address}": {
    /** Code queries the balance of all coins for a single account. */
    get: operations["Code"];
  };
  "/evmos/evm/v1/cosmos_account/{address}": {
    /** CosmosAccount queries an Ethereum account's Cosmos Address. */
    get: operations["CosmosAccount"];
  };
  "/evmos/evm/v1/estimate_gas": {
    /** EstimateGas implements the `eth_estimateGas` rpc api */
    get: operations["EstimateGas"];
  };
  "/evmos/evm/v1/eth_call": {
    /** EthCall implements the `eth_call` rpc api */
    get: operations["EthCall"];
  };
  "/evmos/evm/v1/params": {
    /** Params queries the parameters of x/evm module. */
    get: operations["EvmParams"];
  };
  "/evmos/evm/v1/storage/{address}/{key}": {
    /** Storage queries the balance of all coins for a single account. */
    get: operations["Storage"];
  };
  "/evmos/evm/v1/trace_block": {
    /** TraceBlock implements the `debug_traceBlockByNumber` and `debug_traceBlockByHash` rpc api */
    get: operations["TraceBlock"];
  };
  "/evmos/evm/v1/trace_tx": {
    /** TraceTx implements the `debug_traceTransaction` rpc api */
    get: operations["TraceTx"];
  };
  "/evmos/evm/v1/validator_account/{cons_address}": {
    /**
     * ValidatorAccount queries an Ethereum account's from a validator consensus
     * Address.
     */
    get: operations["ValidatorAccount"];
  };
  "/evmos/feemarket/v1/base_fee": {
    /** BaseFee queries the base fee of the parent block of the current block. */
    get: operations["FeeMarketBaseFee"];
  };
  "/evmos/feemarket/v1/block_gas": {
    /** BlockGas queries the gas used at a given block height */
    get: operations["BlockGas"];
  };
  "/evmos/feemarket/v1/params": {
    /** Params queries the parameters of x/feemarket module. */
    get: operations["FeeMarketParams"];
  };
  "/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address": {
    /** EscrowAddress returns the escrow address for a particular port and channel id. */
    get: operations["EscrowAddress"];
  };
  "/ibc/apps/transfer/v1/denom_hashes/{trace}": {
    /** DenomHash queries a denomination hash information. */
    get: operations["DenomHash"];
  };
  "/ibc/apps/transfer/v1/denom_traces": {
    /** DenomTraces queries all denomination traces. */
    get: operations["DenomTraces"];
  };
  "/ibc/apps/transfer/v1/denom_traces/{hash}": {
    /** DenomTrace queries a denomination trace information. */
    get: operations["DenomTrace"];
  };
  "/ibc/apps/transfer/v1/denoms/{denom}/total_escrow": {
    /** TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom. */
    get: operations["TotalEscrowForDenom"];
  };
  "/ibc/apps/transfer/v1/params": {
    /** Params queries all parameters of the ibc-transfer module. */
    get: operations["TransferParams"];
  };
  "/ibc/core/client/v1/client_states": {
    /** ClientStates queries all the IBC light clients of a chain. */
    get: operations["ClientStates"];
  };
  "/ibc/core/client/v1/client_states/{client_id}": {
    /** ClientState queries an IBC light client. */
    get: operations["ClientState"];
  };
  "/ibc/core/client/v1/client_status/{client_id}": {
    /** Status queries the status of an IBC client. */
    get: operations["ClientStatus"];
  };
  "/ibc/core/client/v1/consensus_states/{client_id}": {
    /**
     * ConsensusStates queries all the consensus state associated with a given
     * client.
     */
    get: operations["ConsensusStates"];
  };
  "/ibc/core/client/v1/consensus_states/{client_id}/heights": {
    /** ConsensusStateHeights queries the height of every consensus states associated with a given client. */
    get: operations["ConsensusStateHeights"];
  };
  "/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}": {
    /**
     * ConsensusState queries a consensus state associated with a client state at
     * a given height.
     */
    get: operations["ConsensusState"];
  };
  "/ibc/core/client/v1/params": {
    /** ClientParams queries all parameters of the ibc client submodule. */
    get: operations["ClientParams"];
  };
  "/ibc/core/client/v1/upgraded_client_states": {
    /** UpgradedClientState queries an Upgraded IBC light client. */
    get: operations["UpgradedClientState"];
  };
  "/ibc/core/client/v1/upgraded_consensus_states": {
    /** UpgradedConsensusState queries an Upgraded IBC consensus state. */
    get: operations["UpgradedConsensusState"];
  };
  "/ibc/core/connection/v1/client_connections/{client_id}": {
    /**
     * ClientConnections queries the connection paths associated with a client
     * state.
     */
    get: operations["ClientConnections"];
  };
  "/ibc/core/connection/v1/connections": {
    /** Connections queries all the IBC connections of a chain. */
    get: operations["Connections"];
  };
  "/ibc/core/connection/v1/connections/{connection_id}": {
    /** Connection queries an IBC connection end. */
    get: operations["Connection"];
  };
  "/ibc/core/connection/v1/connections/{connection_id}/client_state": {
    /**
     * ConnectionClientState queries the client state associated with the
     * connection.
     */
    get: operations["ConnectionClientState"];
  };
  "/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
    /**
     * ConnectionConsensusState queries the consensus state associated with the
     * connection.
     */
    get: operations["ConnectionConsensusState"];
  };
  "/ibc/core/connection/v1/params": {
    /** ConnectionParams queries all parameters of the ibc connection submodule. */
    get: operations["ConnectionParams"];
  };
  "/ibc/core/channel/v1/channels": {
    /** Channels queries all the IBC channels of a chain. */
    get: operations["Channels"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}": {
    /** Channel queries an IBC Channel. */
    get: operations["Channel"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state": {
    /**
     * ChannelClientState queries for the client state for the channel associated
     * with the provided channel identifiers.
     */
    get: operations["ChannelClientState"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
    /**
     * ChannelConsensusState queries for the consensus state for the channel
     * associated with the provided channel identifiers.
     */
    get: operations["ChannelConsensusState"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence": {
    /** NextSequenceReceive returns the next receive sequence for a given channel. */
    get: operations["NextSequenceReceive"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence_send": {
    /** NextSequenceSend returns the next send sequence for a given channel. */
    get: operations["NextSequenceSend"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements": {
    /**
     * PacketAcknowledgements returns all the packet acknowledgements associated
     * with a channel.
     */
    get: operations["PacketAcknowledgements"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}": {
    /** PacketAcknowledgement queries a stored packet acknowledgement hash. */
    get: operations["PacketAcknowledgement"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments": {
    /**
     * PacketCommitments returns all the packet commitments hashes associated
     * with a channel.
     */
    get: operations["PacketCommitments"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks": {
    /**
     * UnreceivedAcks returns all the unreceived IBC acknowledgements associated
     * with a channel and sequences.
     */
    get: operations["UnreceivedAcks"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets": {
    /**
     * UnreceivedPackets returns all the unreceived IBC packets associated with a
     * channel and sequences.
     */
    get: operations["UnreceivedPackets"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}": {
    /** PacketCommitment queries a stored packet commitment hash. */
    get: operations["PacketCommitment"];
  };
  "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}": {
    /**
     * PacketReceipt queries if a given packet sequence has been received on the
     * queried chain
     */
    get: operations["PacketReceipt"];
  };
  "/ibc/core/channel/v1/connections/{connection}/channels": {
    /**
     * ConnectionChannels queries all the channels associated with a connection
     * end.
     */
    get: operations["ConnectionChannels"];
  };
  "/cosmos/auth/v1beta1/account_info/{address}": {
    /**
     * AccountInfo queries account info which is common to all account types.
     * @description Since: cosmos-sdk 0.47
     */
    get: operations["AccountInfo"];
  };
  "/cosmos/auth/v1beta1/accounts": {
    /**
     * Accounts returns all the existing accounts.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     *
     * Since: cosmos-sdk 0.43
     */
    get: operations["Accounts"];
  };
  "/cosmos/auth/v1beta1/accounts/{address}": {
    /** Account returns account details based on address. */
    get: operations["AuthAccount"];
  };
  "/cosmos/auth/v1beta1/address_by_id/{id}": {
    /**
     * AccountAddressByID returns account address based on account number.
     * @description Since: cosmos-sdk 0.46.2
     */
    get: operations["AccountAddressByID"];
  };
  "/cosmos/auth/v1beta1/bech32": {
    /**
     * Bech32Prefix queries bech32Prefix
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["Bech32Prefix"];
  };
  "/cosmos/auth/v1beta1/bech32/{address_bytes}": {
    /**
     * AddressBytesToString converts Account Address bytes to string
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["AddressBytesToString"];
  };
  "/cosmos/auth/v1beta1/bech32/{address_string}": {
    /**
     * AddressStringToBytes converts Address string to bytes
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["AddressStringToBytes"];
  };
  "/cosmos/auth/v1beta1/module_accounts": {
    /**
     * ModuleAccounts returns all the existing module accounts.
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["ModuleAccounts"];
  };
  "/cosmos/auth/v1beta1/module_accounts/{name}": {
    /** ModuleAccountByName returns the module account info by module name */
    get: operations["ModuleAccountByName"];
  };
  "/cosmos/auth/v1beta1/params": {
    /** Params queries all parameters. */
    get: operations["AuthParams"];
  };
  "/cosmos/authz/v1beta1/grants": {
    /** Returns list of `Authorization`, granted to the grantee by the granter. */
    get: operations["Grants"];
  };
  "/cosmos/authz/v1beta1/grants/grantee/{grantee}": {
    /**
     * GranteeGrants returns a list of `GrantAuthorization` by grantee.
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["GranteeGrants"];
  };
  "/cosmos/authz/v1beta1/grants/granter/{granter}": {
    /**
     * GranterGrants returns list of `GrantAuthorization`, granted by granter.
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["GranterGrants"];
  };
  "/cosmos/bank/v1beta1/balances/{address}": {
    /**
     * AllBalances queries the balance of all coins for a single account.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["AllBalances"];
  };
  "/cosmos/bank/v1beta1/balances/{address}/by_denom": {
    /** Balance queries the balance of a single coin for a single account. */
    get: operations["BankBalance"];
  };
  "/cosmos/bank/v1beta1/denom_owners/{denom}": {
    /**
     * DenomOwners queries for all account addresses that own a particular token
     * denomination.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     *
     * Since: cosmos-sdk 0.46
     */
    get: operations["DenomOwners"];
  };
  "/cosmos/bank/v1beta1/denoms_metadata": {
    /**
     * DenomsMetadata queries the client metadata for all registered coin
     * denominations.
     */
    get: operations["DenomsMetadata"];
  };
  "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
    /** DenomsMetadata queries the client metadata of a given coin denomination. */
    get: operations["DenomMetadata"];
  };
  "/cosmos/bank/v1beta1/denoms_metadata_by_query_string": {
    /** DenomsMetadata queries the client metadata of a given coin denomination. */
    get: operations["DenomMetadataByQueryString"];
  };
  "/cosmos/bank/v1beta1/params": {
    /** Params queries the parameters of x/bank module. */
    get: operations["BankParams"];
  };
  "/cosmos/bank/v1beta1/send_enabled": {
    /**
     * SendEnabled queries for SendEnabled entries.
     * @description This query only returns denominations that have specific SendEnabled settings.
     * Any denomination that does not have a specific setting will use the default
     * params.default_send_enabled, and will not be returned by this query.
     *
     * Since: cosmos-sdk 0.47
     */
    get: operations["SendEnabled"];
  };
  "/cosmos/bank/v1beta1/spendable_balances/{address}": {
    /**
     * SpendableBalances queries the spendable balance of all coins for a single
     * account.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     *
     * Since: cosmos-sdk 0.46
     */
    get: operations["SpendableBalances"];
  };
  "/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom": {
    /**
     * SpendableBalanceByDenom queries the spendable balance of a single denom for
     * a single account.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     *
     * Since: cosmos-sdk 0.47
     */
    get: operations["SpendableBalanceByDenom"];
  };
  "/cosmos/bank/v1beta1/supply": {
    /**
     * TotalSupply queries the total supply of all coins.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["TotalSupply"];
  };
  "/cosmos/bank/v1beta1/supply/by_denom": {
    /**
     * SupplyOf queries the supply of a single coin.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["SupplyOf"];
  };
  "/cosmos/distribution/v1beta1/community_pool": {
    /** CommunityPool queries the community pool coins. */
    get: operations["CommunityPool"];
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards": {
    /**
     * DelegationTotalRewards queries the total rewards accrued by each
     * validator.
     */
    get: operations["DelegationTotalRewards"];
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}": {
    /** DelegationRewards queries the total rewards accrued by a delegation. */
    get: operations["DelegationRewards"];
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators": {
    /** DelegatorValidators queries the validators of a delegator. */
    get: operations["DistDelegatorValidators"];
  };
  "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address": {
    /** DelegatorWithdrawAddress queries withdraw address of a delegator. */
    get: operations["DelegatorWithdrawAddress"];
  };
  "/cosmos/distribution/v1beta1/params": {
    /** Params queries params of the distribution module. */
    get: operations["DistributionParams"];
  };
  "/cosmos/distribution/v1beta1/validators/{validator_address}": {
    /** ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator */
    get: operations["ValidatorDistributionInfo"];
  };
  "/cosmos/distribution/v1beta1/validators/{validator_address}/commission": {
    /** ValidatorCommission queries accumulated commission for a validator. */
    get: operations["ValidatorCommission"];
  };
  "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards": {
    /** ValidatorOutstandingRewards queries rewards of a validator address. */
    get: operations["ValidatorOutstandingRewards"];
  };
  "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes": {
    /** ValidatorSlashes queries slash events of a validator. */
    get: operations["ValidatorSlashes"];
  };
  "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
    /** Allowance returns granted allwance to the grantee by the granter. */
    get: operations["Allowance"];
  };
  "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
    /** Allowances returns all the grants for the given grantee address. */
    get: operations["Allowances"];
  };
  "/cosmos/feegrant/v1beta1/issued/{granter}": {
    /**
     * AllowancesByGranter returns all the grants given by an address
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["AllowancesByGranter"];
  };
  "/cosmos/evidence/v1beta1/evidence": {
    /** AllEvidence queries all evidence. */
    get: operations["AllEvidence"];
  };
  "/cosmos/evidence/v1beta1/evidence/{hash}": {
    /** Evidence queries evidence based on evidence hash. */
    get: operations["Evidence"];
  };
  "/cosmos/gov/v1beta1/params/{params_type}": {
    /** Params queries all parameters of the gov module. */
    get: operations["GovParams"];
  };
  "/cosmos/gov/v1beta1/proposals": {
    /** Proposals queries all proposals based on given status. */
    get: operations["Proposals"];
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}": {
    /** Proposal queries proposal details based on ProposalID. */
    get: operations["Proposal"];
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits": {
    /** Deposits queries all deposits of a single proposal. */
    get: operations["Deposits"];
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}": {
    /** Deposit queries single deposit information based on proposalID, depositor address. */
    get: operations["Deposit"];
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally": {
    /** TallyResult queries the tally of a proposal vote. */
    get: operations["TallyResult"];
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes": {
    /** Votes queries votes of a given proposal. */
    get: operations["Votes"];
  };
  "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}": {
    /**
     * Vote queries voted information based on proposalID, voterAddr.
     * Due to how we handle state, this query would error for proposals that has already been finished.
     */
    get: operations["Vote"];
  };
  "/cosmos/gov/v1/constitution": {
    /** Constitution queries the chain's constitution. */
    get: operations["Constitution"];
  };
  "/cosmos/gov/v1/params/{params_type}": {
    /** Params queries all parameters of the gov module. */
    get: operations["GovV1Params"];
  };
  "/cosmos/gov/v1/proposals": {
    /** Proposals queries all proposals based on given status. */
    get: operations["GovV1Proposal"];
  };
  "/cosmos/gov/v1/proposals/{proposal_id}": {
    /** Proposal queries proposal details based on ProposalID. */
    get: operations["GovV1Proposal"];
  };
  "/cosmos/gov/v1/proposals/{proposal_id}/deposits": {
    /** Deposits queries all deposits of a single proposal. */
    get: operations["GovV1Deposit"];
  };
  "/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}": {
    /** Deposit queries single deposit information based on proposalID, depositAddr. */
    get: operations["GovV1Deposit"];
  };
  "/cosmos/gov/v1/proposals/{proposal_id}/tally": {
    /** TallyResult queries the tally of a proposal vote. */
    get: operations["GovV1TallyResult"];
  };
  "/cosmos/gov/v1/proposals/{proposal_id}/votes": {
    /** Votes queries votes of a given proposal. */
    get: operations["GovV1Votes"];
  };
  "/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}": {
    /** Vote queries voted information based on proposalID, voterAddr. */
    get: operations["GovV1Vote"];
  };
  "/cosmos/slashing/v1beta1/params": {
    /** Params queries the parameters of slashing module */
    get: operations["SlashingParams"];
  };
  "/cosmos/slashing/v1beta1/signing_infos": {
    /** SigningInfos queries signing info of all validators */
    get: operations["SigningInfos"];
  };
  "/cosmos/slashing/v1beta1/signing_infos/{cons_address}": {
    /** SigningInfo queries the signing info of given cons address */
    get: operations["SigningInfo"];
  };
  "/cosmos/staking/v1beta1/delegations/{delegator_addr}": {
    /**
     * DelegatorDelegations queries all delegations of a given delegator address.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["DelegatorDelegations"];
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations": {
    /**
     * Redelegations queries redelegations of given address.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["Redelegations"];
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations": {
    /**
     * DelegatorUnbondingDelegations queries all unbonding delegations of a given
     * delegator address.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["DelegatorUnbondingDelegations"];
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators": {
    /**
     * DelegatorValidators queries all validators info for given delegator
     * address.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["DelegatorValidators"];
  };
  "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}": {
    /**
     * DelegatorValidator queries validator info for given delegator validator
     * pair.
     */
    get: operations["DelegatorValidator"];
  };
  "/cosmos/staking/v1beta1/historical_info/{height}": {
    /** HistoricalInfo queries the historical info for given height. */
    get: operations["HistoricalInfo"];
  };
  "/cosmos/staking/v1beta1/params": {
    /** Parameters queries the staking parameters. */
    get: operations["StakingParams"];
  };
  "/cosmos/staking/v1beta1/pool": {
    /** Pool queries the pool info. */
    get: operations["Pool"];
  };
  "/cosmos/staking/v1beta1/validators": {
    /**
     * Validators queries all validators that match the given status.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["Validators"];
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}": {
    /** Validator queries validator info for given validator address. */
    get: operations["Validator"];
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations": {
    /**
     * ValidatorDelegations queries delegate info for given validator.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["ValidatorDelegations"];
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}": {
    /** Delegation queries delegate info for given validator delegator pair. */
    get: operations["Delegation"];
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation": {
    /**
     * UnbondingDelegation queries unbonding info for given validator delegator
     * pair.
     */
    get: operations["UnbondingDelegation"];
  };
  "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations": {
    /**
     * ValidatorUnbondingDelegations queries unbonding delegations of a validator.
     * @description When called from another module, this query might consume a high amount of
     * gas if the pagination field is incorrectly set.
     */
    get: operations["ValidatorUnbondingDelegations"];
  };
  "/cosmos/tx/v1beta1/decode": {
    /**
     * TxDecode decodes the transaction.
     * @description Since: cosmos-sdk 0.47
     */
    post: operations["TxDecode"];
  };
  "/cosmos/tx/v1beta1/decode/amino": {
    /**
     * TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.
     * @description Since: cosmos-sdk 0.47
     */
    post: operations["TxDecodeAmino"];
  };
  "/cosmos/tx/v1beta1/encode": {
    /**
     * TxEncode encodes the transaction.
     * @description Since: cosmos-sdk 0.47
     */
    post: operations["TxEncode"];
  };
  "/cosmos/tx/v1beta1/encode/amino": {
    /**
     * TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.
     * @description Since: cosmos-sdk 0.47
     */
    post: operations["TxEncodeAmino"];
  };
  "/cosmos/tx/v1beta1/simulate": {
    /** Simulate simulates executing a transaction for estimating gas usage. */
    post: operations["Simulate"];
  };
  "/cosmos/tx/v1beta1/txs": {
    /** GetTxsEvent fetches txs by event. */
    get: operations["GetTxsEvent"];
    /** BroadcastTx broadcast transaction. */
    post: operations["BroadcastTx"];
  };
  "/cosmos/tx/v1beta1/txs/block/{height}": {
    /**
     * GetBlockWithTxs fetches a block with decoded txs.
     * @description Since: cosmos-sdk 0.45.2
     */
    get: operations["GetBlockWithTxs"];
  };
  "/cosmos/tx/v1beta1/txs/{hash}": {
    /** GetTx fetches a tx by hash. */
    get: operations["GetTx"];
  };
  "/cosmos/base/tendermint/v1beta1/abci_query": {
    /**
     * ABCIQuery defines a query handler that supports ABCI queries directly to the
     * application, bypassing Tendermint completely. The ABCI query must contain
     * a valid and supported path, including app, custom, p2p, and store.
     * @description Since: cosmos-sdk 0.46
     */
    get: operations["ABCIQuery"];
  };
  "/cosmos/base/tendermint/v1beta1/blocks/latest": {
    /** GetLatestBlock returns the latest block. */
    get: operations["GetLatestBlock"];
  };
  "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
    /** GetBlockByHeight queries block for given height. */
    get: operations["GetBlockByHeight"];
  };
  "/cosmos/base/tendermint/v1beta1/node_info": {
    /** GetNodeInfo queries the current node info. */
    get: operations["GetNodeInfo"];
  };
  "/cosmos/base/tendermint/v1beta1/syncing": {
    /** GetSyncing queries node syncing. */
    get: operations["GetSyncing"];
  };
  "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
    /** GetLatestValidatorSet queries latest validator-set. */
    get: operations["GetLatestValidatorSet"];
  };
  "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
    /** GetValidatorSetByHeight queries validator-set at a given height. */
    get: operations["GetValidatorSetByHeight"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /**
     * PageRequest is to be embedded in gRPC request messages for efficient
     * pagination. Ex:
     * @description message SomeRequest {
     *          Foo some_parameter = 1;
     *          PageRequest pagination = 2;
     *  }
     */
    "cosmos.base.query.v1beta1.PageRequest": {
      /**
       * Format: byte
       * @description key is a value returned in PageResponse.next_key to begin
       * querying the next page most efficiently. Only one of offset or key
       * should be set.
       */
      key?: string;
      /**
       * Format: uint64
       * @description offset is a numeric offset that can be used when key is unavailable.
       * It is less efficient than using key. Only one of offset or key should
       * be set.
       */
      offset?: string;
      /**
       * Format: uint64
       * @description limit is the total number of results to be returned in the result page.
       * If left empty it will default to a value to be set by each app.
       */
      limit?: string;
      /**
       * @description count_total is set to true  to indicate that the result set should include
       * a count of the total number of items available for pagination in UIs.
       * count_total is only respected when offset is used. It is ignored when key
       * is set.
       */
      count_total?: boolean;
      /**
       * @description reverse is set to true if results are to be returned in the descending order.
       *
       * Since: cosmos-sdk 0.43
       */
      reverse?: boolean;
    };
    /**
     * @description PageResponse is to be embedded in gRPC response messages where the
     * corresponding request message has used PageRequest.
     *
     *  message SomeResponse {
     *          repeated Bar results = 1;
     *          PageResponse page = 2;
     *  }
     */
    "cosmos.base.query.v1beta1.PageResponse": {
      /**
       * Format: byte
       * @description next_key is the key to be passed to PageRequest.key to
       * query the next page most efficiently. It will be empty if
       * there are no more results.
       */
      next_key?: string;
      /**
       * total is total number of results available if PageRequest.count_total
       * was set, its value is undefined otherwise
       * Format: uint64
       */
      total?: string;
    };
    /**
     * @description Coin defines a token with a denomination and an amount.
     *
     * NOTE: The amount field is an Int which implements the custom method
     * signatures required by gogoproto.
     */
    "cosmos.base.v1beta1.Coin": {
      denom?: string;
      amount?: string;
    };
    /**
     * @description Action defines the list of available actions to claim the airdrop tokens.
     *
     *  - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.
     *  - ACTION_VOTE: ACTION_VOTE defines a proposal vote.
     *  - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.
     *  - ACTION_EVM: ACTION_EVM defines an EVM transaction.
     *  - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.
     * @default ACTION_UNSPECIFIED
     * @enum {string}
     */
    "evmos.claims.v1.Action":
      | "ACTION_UNSPECIFIED"
      | "ACTION_VOTE"
      | "ACTION_DELEGATE"
      | "ACTION_EVM"
      | "ACTION_IBC_TRANSFER";
    /**
     * @description Claim defines the action, completed flag and the remaining claimable amount
     * for a given user. This is only used during client queries.
     */
    "evmos.claims.v1.Claim": {
      /**
       * action enum
       * @description Action defines the list of available actions to claim the airdrop tokens.
       *
       *  - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.
       *  - ACTION_VOTE: ACTION_VOTE defines a proposal vote.
       *  - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.
       *  - ACTION_EVM: ACTION_EVM defines an EVM transaction.
       *  - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.
       * @default ACTION_UNSPECIFIED
       * @enum {string}
       */
      action?:
        | "ACTION_UNSPECIFIED"
        | "ACTION_VOTE"
        | "ACTION_DELEGATE"
        | "ACTION_EVM"
        | "ACTION_IBC_TRANSFER";
      /** completed is true if the action has been completed */
      completed?: boolean;
      /** claimable_amount of tokens for the action. Zero if completed */
      claimable_amount?: string;
    };
    /**
     * @description ClaimsRecordAddress is the claims metadata per address that is used at
     * Genesis.
     */
    "evmos.claims.v1.ClaimsRecordAddress": {
      /** address of claiming user in either bech32 or hex format */
      address?: string;
      /** initial_claimable_amount for the user */
      initial_claimable_amount?: string;
      /** actions_completed is a slice that describes which actions were completed */
      actions_completed?: boolean[];
    };
    /** @description Params defines the claims module's parameters. */
    "evmos.claims.v1.Params": {
      /** enable_claims is the parameter to enable the claiming process */
      enable_claims?: boolean;
      /**
       * airdrop_start_time defines the timestamp of the airdrop start
       * Format: date-time
       */
      airdrop_start_time?: string;
      /** duration_until_decay of claimable tokens begin */
      duration_until_decay?: string;
      /** duration_of_decay for token claim decay period */
      duration_of_decay?: string;
      /** claims_denom is the denomination of the claimable coin */
      claims_denom?: string;
      /**
       * @description authorized_channels is the list of authorized channel identifiers that can perform address
       * attestations via IBC.
       */
      authorized_channels?: string[];
      /** evm_channels is the list of channel identifiers from EVM compatible chains */
      evm_channels?: string[];
    };
    /**
     * @description QueryClaimsRecordResponse is the response type for the Query/ClaimsRecord RPC
     * method.
     */
    "evmos.claims.v1.QueryClaimsRecordResponse": {
      /** initial_claimable_amount of the user */
      initial_claimable_amount?: string;
      /** claims of the user */
      claims?: {
        /**
         * action enum
         * @description Action defines the list of available actions to claim the airdrop tokens.
         *
         *  - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.
         *  - ACTION_VOTE: ACTION_VOTE defines a proposal vote.
         *  - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.
         *  - ACTION_EVM: ACTION_EVM defines an EVM transaction.
         *  - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.
         * @default ACTION_UNSPECIFIED
         * @enum {string}
         */
        action?:
          | "ACTION_UNSPECIFIED"
          | "ACTION_VOTE"
          | "ACTION_DELEGATE"
          | "ACTION_EVM"
          | "ACTION_IBC_TRANSFER";
        /** completed is true if the action has been completed */
        completed?: boolean;
        /** claimable_amount of tokens for the action. Zero if completed */
        claimable_amount?: string;
      }[];
    };
    /**
     * @description QueryClaimsRecordsResponse is the response type for the Query/ClaimsRecords
     * RPC method.
     */
    "evmos.claims.v1.QueryClaimsRecordsResponse": {
      /** claims defines all claims records */
      claims?: {
        /** address of claiming user in either bech32 or hex format */
        address?: string;
        /** initial_claimable_amount for the user */
        initial_claimable_amount?: string;
        /** actions_completed is a slice that describes which actions were completed */
        actions_completed?: boolean[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "evmos.claims.v1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /** enable_claims is the parameter to enable the claiming process */
        enable_claims?: boolean;
        /**
         * airdrop_start_time defines the timestamp of the airdrop start
         * Format: date-time
         */
        airdrop_start_time?: string;
        /** duration_until_decay of claimable tokens begin */
        duration_until_decay?: string;
        /** duration_of_decay for token claim decay period */
        duration_of_decay?: string;
        /** claims_denom is the denomination of the claimable coin */
        claims_denom?: string;
        /**
         * @description authorized_channels is the list of authorized channel identifiers that can perform address
         * attestations via IBC.
         */
        authorized_channels?: string[];
        /** evm_channels is the list of channel identifiers from EVM compatible chains */
        evm_channels?: string[];
      };
    };
    /**
     * @description QueryTotalUnclaimedResponse is the response type for the Query/TotalUnclaimed
     * RPC method.
     */
    "evmos.claims.v1.QueryTotalUnclaimedResponse": {
      /** coins defines the unclaimed coins */
      coins?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /**
     * @description `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     *     Foo foo = ...;
     *     Any any;
     *     any.PackFrom(foo);
     *     ...
     *     if (any.UnpackTo(&foo)) {
     *       ...
     *     }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     *     Foo foo = ...;
     *     Any any = Any.pack(foo);
     *     ...
     *     if (any.is(Foo.class)) {
     *       foo = any.unpack(Foo.class);
     *     }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     *     foo = Foo(...)
     *     any = Any()
     *     any.Pack(foo)
     *     ...
     *     if any.Is(Foo.DESCRIPTOR):
     *       any.Unpack(foo)
     *       ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     *      foo := &pb.Foo{...}
     *      any, err := anypb.New(foo)
     *      if err != nil {
     *        ...
     *      }
     *      ...
     *      foo := &pb.Foo{}
     *      if err := any.UnmarshalTo(foo); err != nil {
     *        ...
     *      }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     *
     * JSON
     *
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     *     package google.profile;
     *     message Person {
     *       string first_name = 1;
     *       string last_name = 2;
     *     }
     *
     *     {
     *       "@type": "type.googleapis.com/google.profile.Person",
     *       "firstName": <string>,
     *       "lastName": <string>
     *     }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     *     {
     *       "@type": "type.googleapis.com/google.protobuf.Duration",
     *       "value": "1.212s"
     *     }
     */
    "google.protobuf.Any": {
      /**
       * @description A URL/resource name that uniquely identifies the type of the serialized
       * protocol buffer message. This string must contain at least
       * one "/" character. The last segment of the URL's path must represent
       * the fully qualified name of the type (as in
       * `path/google.protobuf.Duration`). The name should be in a canonical form
       * (e.g., leading "." is not accepted).
       *
       * In practice, teams usually precompile into the binary all types that they
       * expect it to use in the context of Any. However, for URLs which use the
       * scheme `http`, `https`, or no scheme, one can optionally set up a type
       * server that maps type URLs to message definitions as follows:
       *
       * * If no scheme is provided, `https` is assumed.
       * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
       *   value in binary format, or produce an error.
       * * Applications are allowed to cache lookup results based on the
       *   URL, or have them precompiled into a binary to avoid any
       *   lookup. Therefore, binary compatibility needs to be preserved
       *   on changes to types. (Use versioned type names to manage
       *   breaking changes.)
       *
       * Note: this functionality is not currently available in the official
       * protobuf release, and it is not used for type URLs beginning with
       * type.googleapis.com.
       *
       * Schemes other than `http`, `https` (or the empty scheme) might be
       * used with implementation specific semantics.
       */
      type_url?: string;
      /**
       * Format: byte
       * @description Must be a valid serialized protocol buffer of the above specified type.
       */
      value?: string;
    };
    "grpc.gateway.runtime.Error": {
      error?: string;
      /** Format: int32 */
      code?: number;
      message?: string;
      details?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
    };
    /**
     * @description EpochInfo defines the message interface containing the relevant informations about
     * an epoch.
     */
    "evmos.epochs.v1.EpochInfo": {
      /** identifier of the epoch */
      identifier?: string;
      /**
       * start_time of the epoch
       * Format: date-time
       */
      start_time?: string;
      /** duration of the epoch */
      duration?: string;
      /**
       * current_epoch is the integer identifier of the epoch
       * Format: int64
       */
      current_epoch?: string;
      /**
       * current_epoch_start_time defines the timestamp of the start of the epoch
       * Format: date-time
       */
      current_epoch_start_time?: string;
      /** epoch_counting_started reflects if the counting for the epoch has started */
      epoch_counting_started?: boolean;
      /**
       * current_epoch_start_height of the epoch
       * Format: int64
       */
      current_epoch_start_height?: string;
    };
    /**
     * @description QueryCurrentEpochResponse is the response type for the Query/EpochInfos RPC
     * method.
     */
    "evmos.epochs.v1.QueryCurrentEpochResponse": {
      /**
       * current_epoch is the number of the current epoch
       * Format: int64
       */
      current_epoch?: string;
    };
    /**
     * @description QueryEpochsInfoResponse is the response type for the Query/EpochInfos RPC
     * method.
     */
    "evmos.epochs.v1.QueryEpochsInfoResponse": {
      /** epochs is a slice of all EpochInfos */
      epochs?: {
        /** identifier of the epoch */
        identifier?: string;
        /**
         * start_time of the epoch
         * Format: date-time
         */
        start_time?: string;
        /** duration of the epoch */
        duration?: string;
        /**
         * current_epoch is the integer identifier of the epoch
         * Format: int64
         */
        current_epoch?: string;
        /**
         * current_epoch_start_time defines the timestamp of the start of the epoch
         * Format: date-time
         */
        current_epoch_start_time?: string;
        /** epoch_counting_started reflects if the counting for the epoch has started */
        epoch_counting_started?: boolean;
        /**
         * current_epoch_start_height of the epoch
         * Format: int64
         */
        current_epoch_start_height?: string;
      }[];
      /** @description pagination defines an optional pagination for the request. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description Owner enumerates the ownership of a ERC20 contract.
     *
     *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
     *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
     *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
     * @default OWNER_UNSPECIFIED
     * @enum {string}
     */
    "evmos.erc20.v1.Owner":
      | "OWNER_UNSPECIFIED"
      | "OWNER_MODULE"
      | "OWNER_EXTERNAL";
    /** Params defines the erc20 module params */
    "evmos.erc20.v1.Params": {
      /** @description enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens. */
      enable_erc20?: boolean;
      /**
       * @description enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos
       * Coin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address.
       */
      enable_evm_hook?: boolean;
    };
    /**
     * @description QueryParamsResponse is the response type for the Query/Params RPC
     * method.
     */
    "evmos.erc20.v1.QueryParamsResponse": {
      /** params are the erc20 module parameters */
      params?: {
        /** @description enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens. */
        enable_erc20?: boolean;
        /**
         * @description enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos
         * Coin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address.
         */
        enable_evm_hook?: boolean;
      };
    };
    /**
     * @description QueryTokenPairResponse is the response type for the Query/TokenPair RPC
     * method.
     */
    "evmos.erc20.v1.QueryTokenPairResponse": {
      /**
       * token_pairs returns the info about a registered token pair for the erc20 module
       * @description TokenPair defines an instance that records a pairing consisting of a native
       *  Cosmos Coin and an ERC20 token address.
       */
      token_pair?: {
        /** erc20_address is the hex address of ERC20 contract token */
        erc20_address?: string;
        /** denom defines the cosmos base denomination to be mapped to */
        denom?: string;
        /** enabled defines the token mapping enable status */
        enabled?: boolean;
        /**
         * contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)
         * @description Owner enumerates the ownership of a ERC20 contract.
         *
         *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
         *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
         *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
         * @default OWNER_UNSPECIFIED
         * @enum {string}
         */
        contract_owner?:
          | "OWNER_UNSPECIFIED"
          | "OWNER_MODULE"
          | "OWNER_EXTERNAL";
      };
    };
    /**
     * @description QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC
     * method.
     */
    "evmos.erc20.v1.QueryTokenPairsResponse": {
      /** token_pairs is a slice of registered token pairs for the erc20 module */
      token_pairs?: {
        /** erc20_address is the hex address of ERC20 contract token */
        erc20_address?: string;
        /** denom defines the cosmos base denomination to be mapped to */
        denom?: string;
        /** enabled defines the token mapping enable status */
        enabled?: boolean;
        /**
         * contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)
         * @description Owner enumerates the ownership of a ERC20 contract.
         *
         *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
         *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
         *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
         * @default OWNER_UNSPECIFIED
         * @enum {string}
         */
        contract_owner?:
          | "OWNER_UNSPECIFIED"
          | "OWNER_MODULE"
          | "OWNER_EXTERNAL";
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description TokenPair defines an instance that records a pairing consisting of a native
     *  Cosmos Coin and an ERC20 token address.
     */
    "evmos.erc20.v1.TokenPair": {
      /** erc20_address is the hex address of ERC20 contract token */
      erc20_address?: string;
      /** denom defines the cosmos base denomination to be mapped to */
      denom?: string;
      /** enabled defines the token mapping enable status */
      enabled?: boolean;
      /**
       * contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)
       * @description Owner enumerates the ownership of a ERC20 contract.
       *
       *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
       *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
       *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
       * @default OWNER_UNSPECIFIED
       * @enum {string}
       */
      contract_owner?: "OWNER_UNSPECIFIED" | "OWNER_MODULE" | "OWNER_EXTERNAL";
    };
    /**
     * @description DecCoin defines a token with a denomination and a decimal amount.
     *
     * NOTE: The amount field is an Dec which implements the custom method
     * signatures required by gogoproto.
     */
    "cosmos.base.v1beta1.DecCoin": {
      denom?: string;
      amount?: string;
    };
    /** GasMeter tracks the cumulative gas spent per participant in one epoch */
    "evmos.incentives.v1.GasMeter": {
      /** contract is the hex address of the incentivized smart contract */
      contract?: string;
      /** participant address that interacts with the incentive */
      participant?: string;
      /**
       * cumulative_gas spent during the epoch
       * Format: uint64
       */
      cumulative_gas?: string;
    };
    /**
     * Incentive defines an instance that organizes distribution conditions for a
     * given smart contract
     */
    "evmos.incentives.v1.Incentive": {
      /** contract address of the smart contract to be incentivized */
      contract?: string;
      /** allocations is a slice of denoms and percentages of rewards to be allocated */
      allocations?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * epochs defines the number of remaining epochs for the incentive
       * Format: int64
       */
      epochs?: number;
      /**
       * start_time of the incentive distribution
       * Format: date-time
       */
      start_time?: string;
      /**
       * total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch
       * Format: uint64
       */
      total_gas?: string;
    };
    /** Params defines the incentives module params */
    "evmos.incentives.v1.Params": {
      /** enable_incentives is the parameter to enable incentives */
      enable_incentives?: boolean;
      /** allocation_limit is the maximum percentage an incentive can allocate per denomination */
      allocation_limit?: string;
      /** incentives_epoch_identifier for the epochs module hooks */
      incentives_epoch_identifier?: string;
      /** reward_scaler is the scaling factor for capping rewards */
      reward_scaler?: string;
    };
    /**
     * @description QueryAllocationMeterResponse is the response type for the
     * Query/AllocationMeter RPC method.
     */
    "evmos.incentives.v1.QueryAllocationMeterResponse": {
      /**
       * allocation_meter defines the allocation of the queried denom
       * @description DecCoin defines a token with a denomination and a decimal amount.
       *
       * NOTE: The amount field is an Dec which implements the custom method
       * signatures required by gogoproto.
       */
      allocation_meter?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * @description QueryAllocationMetersResponse is the response type for the
     * Query/AllocationMeters RPC method.
     */
    "evmos.incentives.v1.QueryAllocationMetersResponse": {
      /** allocation_meters is a slice of all allocations */
      allocation_meters?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryGasMeterResponse is the response type for the Query/Incentive RPC
     * method.
     */
    "evmos.incentives.v1.QueryGasMeterResponse": {
      /**
       * gas_meter is a gas meter for one participant on an incentivized smart contract
       * Format: uint64
       */
      gas_meter?: string;
    };
    /**
     * @description QueryGasMetersResponse is the response type for the Query/Incentives RPC
     * method.
     */
    "evmos.incentives.v1.QueryGasMetersResponse": {
      /** gas_meters is a slice of the gas meters for an incentivized smart contract */
      gas_meters?: {
        /** contract is the hex address of the incentivized smart contract */
        contract?: string;
        /** participant address that interacts with the incentive */
        participant?: string;
        /**
         * cumulative_gas spent during the epoch
         * Format: uint64
         */
        cumulative_gas?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryIncentiveResponse is the response type for the Query/Incentive RPC
     * method.
     */
    "evmos.incentives.v1.QueryIncentiveResponse": {
      /**
       * Incentive defines an instance that organizes distribution conditions for a
       * given smart contract
       */
      incentive?: {
        /** contract address of the smart contract to be incentivized */
        contract?: string;
        /** allocations is a slice of denoms and percentages of rewards to be allocated */
        allocations?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * epochs defines the number of remaining epochs for the incentive
         * Format: int64
         */
        epochs?: number;
        /**
         * start_time of the incentive distribution
         * Format: date-time
         */
        start_time?: string;
        /**
         * total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch
         * Format: uint64
         */
        total_gas?: string;
      };
    };
    /**
     * @description QueryIncentivesResponse is the response type for the Query/Incentives RPC
     * method.
     */
    "evmos.incentives.v1.QueryIncentivesResponse": {
      /** incentives is a slice of all incentives */
      incentives?: {
        /** contract address of the smart contract to be incentivized */
        contract?: string;
        /** allocations is a slice of denoms and percentages of rewards to be allocated */
        allocations?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * epochs defines the number of remaining epochs for the incentive
         * Format: int64
         */
        epochs?: number;
        /**
         * start_time of the incentive distribution
         * Format: date-time
         */
        start_time?: string;
        /**
         * total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch
         * Format: uint64
         */
        total_gas?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryParamsResponse is the response type for the Query/Params RPC
     * method.
     */
    "evmos.incentives.v1.QueryParamsResponse": {
      /** params are the incentives module parameters */
      params?: {
        /** enable_incentives is the parameter to enable incentives */
        enable_incentives?: boolean;
        /** allocation_limit is the maximum percentage an incentive can allocate per denomination */
        allocation_limit?: string;
        /** incentives_epoch_identifier for the epochs module hooks */
        incentives_epoch_identifier?: string;
        /** reward_scaler is the scaling factor for capping rewards */
        reward_scaler?: string;
      };
    };
    /**
     * ExponentialCalculation holds factors to calculate exponential inflation on
     * each period. Calculation reference:
     * periodProvision = exponentialDecay       *  bondingIncentive
     * f(x)            = (a * (1 - r) ^ x + c)  *  (1 + max_variance - bondedRatio *
     * (max_variance / bonding_target))
     */
    "evmos.inflation.v1.ExponentialCalculation": {
      /** a defines the initial value */
      a?: string;
      /** r defines the reduction factor */
      r?: string;
      /** c defines the parameter for long term inflation */
      c?: string;
      /** bonding_target */
      bonding_target?: string;
      /** max_variance */
      max_variance?: string;
    };
    /**
     * InflationDistribution defines the distribution in which inflation is
     * allocated through minting on each epoch (staking, incentives, community). It
     * excludes the team vesting distribution, as this is minted once at genesis.
     * The initial InflationDistribution can be calculated from the Evmos Token
     * Model like this:
     * mintDistribution1 = distribution1 / (1 - teamVestingDistribution)
     * 0.5333333         = 40%           / (1 - 25%)
     */
    "evmos.inflation.v1.InflationDistribution": {
      /**
       * staking_rewards defines the proportion of the minted minted_denom that is
       * to be allocated as staking rewards
       */
      staking_rewards?: string;
      /**
       * usage_incentives defines the proportion of the minted minted_denom that is
       * to be allocated to the incentives module address
       */
      usage_incentives?: string;
      /**
       * community_pool defines the proportion of the minted minted_denom that is to
       * be allocated to the community pool
       */
      community_pool?: string;
    };
    /** @description Params holds parameters for the inflation module. */
    "evmos.inflation.v1.Params": {
      /** mint_denom specifies the type of coin to mint */
      mint_denom?: string;
      /** exponential_calculation takes in the variables to calculate exponential inflation */
      exponential_calculation?: {
        /** a defines the initial value */
        a?: string;
        /** r defines the reduction factor */
        r?: string;
        /** c defines the parameter for long term inflation */
        c?: string;
        /** bonding_target */
        bonding_target?: string;
        /** max_variance */
        max_variance?: string;
      };
      /** inflation_distribution of the minted denom */
      inflation_distribution?: {
        /**
         * staking_rewards defines the proportion of the minted minted_denom that is
         * to be allocated as staking rewards
         */
        staking_rewards?: string;
        /**
         * usage_incentives defines the proportion of the minted minted_denom that is
         * to be allocated to the incentives module address
         */
        usage_incentives?: string;
        /**
         * community_pool defines the proportion of the minted minted_denom that is to
         * be allocated to the community pool
         */
        community_pool?: string;
      };
      /** enable_inflation is the parameter that enables inflation and halts increasing the skipped_epochs */
      enable_inflation?: boolean;
    };
    /**
     * @description QueryCirculatingSupplyResponse is the response type for the
     * Query/CirculatingSupply RPC method.
     */
    "evmos.inflation.v1.QueryCirculatingSupplyResponse": {
      /**
       * circulating_supply is the total amount of coins in circulation
       * @description DecCoin defines a token with a denomination and a decimal amount.
       *
       * NOTE: The amount field is an Dec which implements the custom method
       * signatures required by gogoproto.
       */
      circulating_supply?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * @description QueryEpochMintProvisionResponse is the response type for the
     * Query/EpochMintProvision RPC method.
     */
    "evmos.inflation.v1.QueryEpochMintProvisionResponse": {
      /** @description epoch_mint_provision is the current minting per epoch provision value. */
      epoch_mint_provision?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * @description QueryInflationRateResponse is the response type for the Query/InflationRate
     * RPC method.
     */
    "evmos.inflation.v1.QueryInflationRateResponse": {
      /** inflation_rate by which the total supply increases within one period */
      inflation_rate?: string;
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "evmos.inflation.v1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /** mint_denom specifies the type of coin to mint */
        mint_denom?: string;
        /** exponential_calculation takes in the variables to calculate exponential inflation */
        exponential_calculation?: {
          /** a defines the initial value */
          a?: string;
          /** r defines the reduction factor */
          r?: string;
          /** c defines the parameter for long term inflation */
          c?: string;
          /** bonding_target */
          bonding_target?: string;
          /** max_variance */
          max_variance?: string;
        };
        /** inflation_distribution of the minted denom */
        inflation_distribution?: {
          /**
           * staking_rewards defines the proportion of the minted minted_denom that is
           * to be allocated as staking rewards
           */
          staking_rewards?: string;
          /**
           * usage_incentives defines the proportion of the minted minted_denom that is
           * to be allocated to the incentives module address
           */
          usage_incentives?: string;
          /**
           * community_pool defines the proportion of the minted minted_denom that is to
           * be allocated to the community pool
           */
          community_pool?: string;
        };
        /** enable_inflation is the parameter that enables inflation and halts increasing the skipped_epochs */
        enable_inflation?: boolean;
      };
    };
    /** @description QueryPeriodResponse is the response type for the Query/Period RPC method. */
    "evmos.inflation.v1.QueryPeriodResponse": {
      /**
       * Format: uint64
       * @description period is the current minting per epoch provision value.
       */
      period?: string;
    };
    /**
     * @description QuerySkippedEpochsResponse is the response type for the Query/SkippedEpochs
     * RPC method.
     */
    "evmos.inflation.v1.QuerySkippedEpochsResponse": {
      /**
       * Format: uint64
       * @description skipped_epochs is the number of epochs that the inflation module has been disabled.
       */
      skipped_epochs?: string;
    };
    /**
     * @description QueryBalancesResponse is the response type for the Query/Balances RPC
     * method.
     */
    "evmos.vesting.v1.QueryBalancesResponse": {
      /** locked defines the current amount of locked tokens */
      locked?: {
        denom?: string;
        amount?: string;
      }[];
      /** unvested defines the current amount of unvested tokens */
      unvested?: {
        denom?: string;
        amount?: string;
      }[];
      /** vested defines the current amount of vested tokens */
      vested?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** Params holds parameters for the recovery module */
    "evmos.recovery.v1.Params": {
      /** enable_recovery IBC middleware */
      enable_recovery?: boolean;
      /** packet_timeout_duration is the duration added to timeout timestamp for balances recovered via IBC packets */
      packet_timeout_duration?: string;
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "evmos.recovery.v1.QueryParamsResponse": {
      /**
       * Params holds parameters for the recovery module
       * @description params defines the parameters of the module.
       */
      params?: {
        /** enable_recovery IBC middleware */
        enable_recovery?: boolean;
        /** packet_timeout_duration is the duration added to timeout timestamp for balances recovered via IBC packets */
        packet_timeout_duration?: string;
      };
    };
    /** Params defines the revenue module params */
    "evmos.revenue.v1.Params": {
      /** enable_revenue defines a parameter to enable the revenue module */
      enable_revenue?: boolean;
      /**
       * developer_shares defines the proportion of the transaction fees to be
       * distributed to the registered contract owner
       */
      developer_shares?: string;
      /**
       * addr_derivation_cost_create defines the cost of address derivation for
       * verifying the contract deployer at fee registration
       * Format: uint64
       */
      addr_derivation_cost_create?: string;
    };
    /**
     * @description QueryDeployerRevenuesResponse is the response type for the
     * Query/DeployerRevenues RPC method.
     */
    "evmos.revenue.v1.QueryDeployerRevenuesResponse": {
      /** contract_addresses is the slice of registered contract addresses for a deployer */
      contract_addresses?: string[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "evmos.revenue.v1.QueryParamsResponse": {
      /** params is the returned revenue parameter */
      params?: {
        /** enable_revenue defines a parameter to enable the revenue module */
        enable_revenue?: boolean;
        /**
         * developer_shares defines the proportion of the transaction fees to be
         * distributed to the registered contract owner
         */
        developer_shares?: string;
        /**
         * addr_derivation_cost_create defines the cost of address derivation for
         * verifying the contract deployer at fee registration
         * Format: uint64
         */
        addr_derivation_cost_create?: string;
      };
    };
    /** @description QueryRevenueResponse is the response type for the Query/Revenue RPC method. */
    "evmos.revenue.v1.QueryRevenueResponse": {
      /**
       * Revenue defines an instance that organizes fee distribution conditions for
       * the owner of a given smart contract
       */
      revenue?: {
        /** contract_address is the hex address of a registered contract */
        contract_address?: string;
        /**
         * deployer_address is the bech32 address of message sender. It must be the same as the origin EOA
         * sending the transaction which deploys the contract
         */
        deployer_address?: string;
        /**
         * withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to
         * deployer_address
         */
        withdrawer_address?: string;
      };
    };
    /** @description QueryRevenuesResponse is the response type for the Query/Revenues RPC method. */
    "evmos.revenue.v1.QueryRevenuesResponse": {
      /** revenues is a slice of all stored Reveneue */
      revenues?: {
        /** contract_address is the hex address of a registered contract */
        contract_address?: string;
        /**
         * deployer_address is the bech32 address of message sender. It must be the same as the origin EOA
         * sending the transaction which deploys the contract
         */
        deployer_address?: string;
        /**
         * withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to
         * deployer_address
         */
        withdrawer_address?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryWithdrawerRevenuesResponse is the response type for the
     * Query/WithdrawerRevenues RPC method.
     */
    "evmos.revenue.v1.QueryWithdrawerRevenuesResponse": {
      /** contract_addresses is the slice of registered contract addresses for a withdrawer */
      contract_addresses?: string[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * Revenue defines an instance that organizes fee distribution conditions for
     * the owner of a given smart contract
     */
    "evmos.revenue.v1.Revenue": {
      /** contract_address is the hex address of a registered contract */
      contract_address?: string;
      /**
       * deployer_address is the bech32 address of message sender. It must be the same as the origin EOA
       * sending the transaction which deploys the contract
       */
      deployer_address?: string;
      /**
       * withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to
       * deployer_address
       */
      withdrawer_address?: string;
    };
    /**
     * @description ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
     * instead of *big.Int.
     */
    "ethermint.evm.v1.ChainConfig": {
      /** homestead_block switch (nil no fork, 0 = already homestead) */
      homestead_block?: string;
      /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
      dao_fork_block?: string;
      /** dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork */
      dao_fork_support?: boolean;
      /**
       * eip150_block: EIP150 implements the Gas price changes
       * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
       */
      eip150_block?: string;
      /** eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed) */
      eip150_hash?: string;
      /** eip155_block: EIP155Block HF block */
      eip155_block?: string;
      /** eip158_block: EIP158 HF block */
      eip158_block?: string;
      /** byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium) */
      byzantium_block?: string;
      /** constantinople_block: Constantinople switch block (nil no fork, 0 = already activated) */
      constantinople_block?: string;
      /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
      petersburg_block?: string;
      /** istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul) */
      istanbul_block?: string;
      /** muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
      muir_glacier_block?: string;
      /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
      berlin_block?: string;
      /** london_block: London switch block (nil = no fork, 0 = already on london) */
      london_block?: string;
      /** arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
      arrow_glacier_block?: string;
      /** gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) */
      gray_glacier_block?: string;
      /** merge_netsplit_block: Virtual fork after The Merge to use as a network splitter */
      merge_netsplit_block?: string;
      /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
      shanghai_block?: string;
      /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
      cancun_block?: string;
    };
    /** EstimateGasResponse defines EstimateGas response */
    "ethermint.evm.v1.EstimateGasResponse": {
      /**
       * gas returns the estimated gas
       * Format: uint64
       */
      gas?: string;
    };
    /**
     * @description Log represents an protobuf compatible Ethereum Log that defines a contract
     * log event. These events are generated by the LOG opcode and stored/indexed by
     * the node.
     *
     * NOTE: address, topics and data are consensus fields. The rest of the fields
     * are derived, i.e. filled in by the nodes, but not secured by consensus.
     */
    "ethermint.evm.v1.Log": {
      /** address of the contract that generated the event */
      address?: string;
      /** @description topics is a list of topics provided by the contract. */
      topics?: string[];
      /**
       * data which is supplied by the contract, usually ABI-encoded
       * Format: byte
       */
      data?: string;
      /**
       * block_number of the block in which the transaction was included
       * Format: uint64
       */
      block_number?: string;
      /** tx_hash is the transaction hash */
      tx_hash?: string;
      /**
       * tx_index of the transaction in the block
       * Format: uint64
       */
      tx_index?: string;
      /** block_hash of the block in which the transaction was included */
      block_hash?: string;
      /**
       * index of the log in the block
       * Format: uint64
       */
      index?: string;
      /**
       * @description removed is true if this log was reverted due to a chain
       * reorganisation. You must pay attention to this field if you receive logs
       * through a filter query.
       */
      removed?: boolean;
    };
    /** @description MsgEthereumTx encapsulates an Ethereum transaction as an SDK message. */
    "ethermint.evm.v1.MsgEthereumTx": {
      /**
       * data is inner transaction data of the Ethereum transaction
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      data?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * size is the encoded storage size of the transaction (DEPRECATED)
       * Format: double
       */
      size?: number;
      /** hash of the transaction in hex format */
      hash?: string;
      /**
       * from is the ethereum signer address in hex format. This address value is checked
       * against the address derived from the signature (V, R, S) using the
       * secp256k1 elliptic curve
       */
      from?: string;
    };
    /** @description MsgEthereumTxResponse defines the Msg/EthereumTx response type. */
    "ethermint.evm.v1.MsgEthereumTxResponse": {
      /**
       * hash of the ethereum transaction in hex format. This hash differs from the
       * Tendermint sha256 hash of the transaction bytes. See
       * https://github.com/tendermint/tendermint/issues/6539 for reference
       */
      hash?: string;
      /**
       * @description logs contains the transaction hash and the proto-compatible ethereum
       * logs.
       */
      logs?: {
        /** address of the contract that generated the event */
        address?: string;
        /** @description topics is a list of topics provided by the contract. */
        topics?: string[];
        /**
         * data which is supplied by the contract, usually ABI-encoded
         * Format: byte
         */
        data?: string;
        /**
         * block_number of the block in which the transaction was included
         * Format: uint64
         */
        block_number?: string;
        /** tx_hash is the transaction hash */
        tx_hash?: string;
        /**
         * tx_index of the transaction in the block
         * Format: uint64
         */
        tx_index?: string;
        /** block_hash of the block in which the transaction was included */
        block_hash?: string;
        /**
         * index of the log in the block
         * Format: uint64
         */
        index?: string;
        /**
         * @description removed is true if this log was reverted due to a chain
         * reorganisation. You must pay attention to this field if you receive logs
         * through a filter query.
         */
        removed?: boolean;
      }[];
      /**
       * ret is the returned data from evm function (result or data supplied with revert
       * opcode)
       * Format: byte
       */
      ret?: string;
      /** vm_error is the error returned by vm execution */
      vm_error?: string;
      /**
       * gas_used specifies how much gas was consumed by the transaction
       * Format: uint64
       */
      gas_used?: string;
    };
    /** Params defines the EVM module parameters */
    "ethermint.evm.v1.Params": {
      /**
       * @description evm_denom represents the token denomination used to run the EVM state
       * transitions.
       */
      evm_denom?: string;
      /** enable_create toggles state transitions that use the vm.Create function */
      enable_create?: boolean;
      /** enable_call toggles state transitions that use the vm.Call function */
      enable_call?: boolean;
      /** extra_eips defines the additional EIPs for the vm.Config */
      extra_eips?: string[];
      /**
       * chain_config defines the EVM chain configuration parameters
       * @description ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
       * instead of *big.Int.
       */
      chain_config?: {
        /** homestead_block switch (nil no fork, 0 = already homestead) */
        homestead_block?: string;
        /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
        dao_fork_block?: string;
        /** dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork */
        dao_fork_support?: boolean;
        /**
         * eip150_block: EIP150 implements the Gas price changes
         * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
         */
        eip150_block?: string;
        /** eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed) */
        eip150_hash?: string;
        /** eip155_block: EIP155Block HF block */
        eip155_block?: string;
        /** eip158_block: EIP158 HF block */
        eip158_block?: string;
        /** byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium) */
        byzantium_block?: string;
        /** constantinople_block: Constantinople switch block (nil no fork, 0 = already activated) */
        constantinople_block?: string;
        /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
        petersburg_block?: string;
        /** istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul) */
        istanbul_block?: string;
        /** muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
        muir_glacier_block?: string;
        /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
        berlin_block?: string;
        /** london_block: London switch block (nil = no fork, 0 = already on london) */
        london_block?: string;
        /** arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
        arrow_glacier_block?: string;
        /** gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) */
        gray_glacier_block?: string;
        /** merge_netsplit_block: Virtual fork after The Merge to use as a network splitter */
        merge_netsplit_block?: string;
        /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
        shanghai_block?: string;
        /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
        cancun_block?: string;
      };
      /**
       * @description allow_unprotected_txs defines if replay-protected (i.e non EIP155
       * signed) transactions can be executed on the state machine.
       */
      allow_unprotected_txs?: boolean;
      /**
       * active_precompiles defines the slice of hex addresses of the precompiled
       * contracts that are active
       */
      active_precompiles?: string[];
    };
    /** @description QueryAccountResponse is the response type for the Query/Account RPC method. */
    "ethermint.evm.v1.QueryAccountResponse": {
      /** @description balance is the balance of the EVM denomination. */
      balance?: string;
      /** @description code_hash is the hex-formatted code bytes from the EOA. */
      code_hash?: string;
      /**
       * Format: uint64
       * @description nonce is the account's sequence number.
       */
      nonce?: string;
    };
    /** @description QueryBalanceResponse is the response type for the Query/Balance RPC method. */
    "ethermint.evm.v1.QueryBalanceResponse": {
      /** @description balance is the balance of the EVM denomination. */
      balance?: string;
    };
    /** @description QueryBaseFeeResponse returns the EIP1559 base fee. */
    "ethermint.evm.v1.QueryBaseFeeResponse": {
      /** base_fee is the EIP1559 base fee */
      base_fee?: string;
    };
    /**
     * @description QueryCodeResponse is the response type for the Query/Code RPC
     * method.
     */
    "ethermint.evm.v1.QueryCodeResponse": {
      /**
       * Format: byte
       * @description code represents the code bytes from an ethereum address.
       */
      code?: string;
    };
    /**
     * @description QueryCosmosAccountResponse is the response type for the Query/CosmosAccount
     * RPC method.
     */
    "ethermint.evm.v1.QueryCosmosAccountResponse": {
      /** @description cosmos_address is the cosmos address of the account. */
      cosmos_address?: string;
      /**
       * Format: uint64
       * @description sequence is the account's sequence number.
       */
      sequence?: string;
      /**
       * account_number is the account number
       * Format: uint64
       */
      account_number?: string;
    };
    /** @description QueryParamsResponse defines the response type for querying x/evm parameters. */
    "ethermint.evm.v1.QueryParamsResponse": {
      /**
       * Params defines the EVM module parameters
       * @description params define the evm module parameters.
       */
      params?: {
        /**
         * @description evm_denom represents the token denomination used to run the EVM state
         * transitions.
         */
        evm_denom?: string;
        /** enable_create toggles state transitions that use the vm.Create function */
        enable_create?: boolean;
        /** enable_call toggles state transitions that use the vm.Call function */
        enable_call?: boolean;
        /** extra_eips defines the additional EIPs for the vm.Config */
        extra_eips?: string[];
        /**
         * chain_config defines the EVM chain configuration parameters
         * @description ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
         * instead of *big.Int.
         */
        chain_config?: {
          /** homestead_block switch (nil no fork, 0 = already homestead) */
          homestead_block?: string;
          /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
          dao_fork_block?: string;
          /** dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork */
          dao_fork_support?: boolean;
          /**
           * eip150_block: EIP150 implements the Gas price changes
           * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
           */
          eip150_block?: string;
          /** eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed) */
          eip150_hash?: string;
          /** eip155_block: EIP155Block HF block */
          eip155_block?: string;
          /** eip158_block: EIP158 HF block */
          eip158_block?: string;
          /** byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium) */
          byzantium_block?: string;
          /** constantinople_block: Constantinople switch block (nil no fork, 0 = already activated) */
          constantinople_block?: string;
          /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
          petersburg_block?: string;
          /** istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul) */
          istanbul_block?: string;
          /** muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
          muir_glacier_block?: string;
          /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
          berlin_block?: string;
          /** london_block: London switch block (nil = no fork, 0 = already on london) */
          london_block?: string;
          /** arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
          arrow_glacier_block?: string;
          /** gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) */
          gray_glacier_block?: string;
          /** merge_netsplit_block: Virtual fork after The Merge to use as a network splitter */
          merge_netsplit_block?: string;
          /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
          shanghai_block?: string;
          /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
          cancun_block?: string;
        };
        /**
         * @description allow_unprotected_txs defines if replay-protected (i.e non EIP155
         * signed) transactions can be executed on the state machine.
         */
        allow_unprotected_txs?: boolean;
        /**
         * active_precompiles defines the slice of hex addresses of the precompiled
         * contracts that are active
         */
        active_precompiles?: string[];
      };
    };
    /**
     * @description QueryStorageResponse is the response type for the Query/Storage RPC
     * method.
     */
    "ethermint.evm.v1.QueryStorageResponse": {
      /** @description value defines the storage state value hash associated with the given key. */
      value?: string;
    };
    /** QueryTraceBlockResponse defines TraceBlock response */
    "ethermint.evm.v1.QueryTraceBlockResponse": {
      /**
       * data is the response serialized in bytes
       * Format: byte
       */
      data?: string;
    };
    /** QueryTraceTxResponse defines TraceTx response */
    "ethermint.evm.v1.QueryTraceTxResponse": {
      /**
       * data is the response serialized in bytes
       * Format: byte
       */
      data?: string;
    };
    /**
     * @description QueryValidatorAccountResponse is the response type for the
     * Query/ValidatorAccount RPC method.
     */
    "ethermint.evm.v1.QueryValidatorAccountResponse": {
      /** @description account_address is the cosmos address of the account in bech32 format. */
      account_address?: string;
      /**
       * Format: uint64
       * @description sequence is the account's sequence number.
       */
      sequence?: string;
      /**
       * account_number is the account number
       * Format: uint64
       */
      account_number?: string;
    };
    /** @description TraceConfig holds extra parameters to trace functions. */
    "ethermint.evm.v1.TraceConfig": {
      /** tracer is a custom javascript tracer */
      tracer?: string;
      /**
       * timeout overrides the default timeout of 5 seconds for JavaScript-based tracing
       * calls
       */
      timeout?: string;
      /**
       * reexec defines the number of blocks the tracer is willing to go back
       * Format: uint64
       */
      reexec?: string;
      /** disable_stack switches stack capture */
      disable_stack?: boolean;
      /** disable_storage switches storage capture */
      disable_storage?: boolean;
      /** debug can be used to print output during capture end */
      debug?: boolean;
      /**
       * limit defines the maximum length of output, but zero means unlimited
       * Format: int32
       */
      limit?: number;
      /**
       * overrides can be used to execute a trace using future fork rules
       * @description ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
       * instead of *big.Int.
       */
      overrides?: {
        /** homestead_block switch (nil no fork, 0 = already homestead) */
        homestead_block?: string;
        /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
        dao_fork_block?: string;
        /** dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork */
        dao_fork_support?: boolean;
        /**
         * eip150_block: EIP150 implements the Gas price changes
         * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
         */
        eip150_block?: string;
        /** eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed) */
        eip150_hash?: string;
        /** eip155_block: EIP155Block HF block */
        eip155_block?: string;
        /** eip158_block: EIP158 HF block */
        eip158_block?: string;
        /** byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium) */
        byzantium_block?: string;
        /** constantinople_block: Constantinople switch block (nil no fork, 0 = already activated) */
        constantinople_block?: string;
        /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
        petersburg_block?: string;
        /** istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul) */
        istanbul_block?: string;
        /** muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
        muir_glacier_block?: string;
        /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
        berlin_block?: string;
        /** london_block: London switch block (nil = no fork, 0 = already on london) */
        london_block?: string;
        /** arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
        arrow_glacier_block?: string;
        /** gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) */
        gray_glacier_block?: string;
        /** merge_netsplit_block: Virtual fork after The Merge to use as a network splitter */
        merge_netsplit_block?: string;
        /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
        shanghai_block?: string;
        /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
        cancun_block?: string;
      };
      /** enable_memory switches memory capture */
      enable_memory?: boolean;
      /** enable_return_data switches the capture of return data */
      enable_return_data?: boolean;
      /** tracer_json_config configures the tracer using a JSON string */
      tracer_json_config?: string;
    };
    /** Params defines the EVM module parameters */
    "ethermint.feemarket.v1.Params": {
      /** no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
      no_base_fee?: boolean;
      /**
       * Format: int64
       * @description base_fee_change_denominator bounds the amount the base fee can change
       * between blocks.
       */
      base_fee_change_denominator?: number;
      /**
       * Format: int64
       * @description elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may
       * have.
       */
      elasticity_multiplier?: number;
      /**
       * Format: int64
       * @description enable_height defines at which block height the base fee calculation is enabled.
       */
      enable_height?: string;
      /** @description base_fee for EIP-1559 blocks. */
      base_fee?: string;
      /** min_gas_price defines the minimum gas price value for cosmos and eth transactions */
      min_gas_price?: string;
      /**
       * min_gas_multiplier bounds the minimum gas used to be charged
       * to senders based on gas limit
       */
      min_gas_multiplier?: string;
    };
    /** @description QueryBaseFeeResponse returns the EIP1559 base fee. */
    "ethermint.feemarket.v1.QueryBaseFeeResponse": {
      /** base_fee is the EIP1559 base fee */
      base_fee?: string;
    };
    /** @description QueryBlockGasResponse returns block gas used for a given height. */
    "ethermint.feemarket.v1.QueryBlockGasResponse": {
      /**
       * gas is the returned block gas
       * Format: int64
       */
      gas?: string;
    };
    /** @description QueryParamsResponse defines the response type for querying x/evm parameters. */
    "ethermint.feemarket.v1.QueryParamsResponse": {
      /**
       * Params defines the EVM module parameters
       * @description params define the evm module parameters.
       */
      params?: {
        /** no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
        no_base_fee?: boolean;
        /**
         * Format: int64
         * @description base_fee_change_denominator bounds the amount the base fee can change
         * between blocks.
         */
        base_fee_change_denominator?: number;
        /**
         * Format: int64
         * @description elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may
         * have.
         */
        elasticity_multiplier?: number;
        /**
         * Format: int64
         * @description enable_height defines at which block height the base fee calculation is enabled.
         */
        enable_height?: string;
        /** @description base_fee for EIP-1559 blocks. */
        base_fee?: string;
        /** min_gas_price defines the minimum gas price value for cosmos and eth transactions */
        min_gas_price?: string;
        /**
         * min_gas_multiplier bounds the minimum gas used to be charged
         * to senders based on gas limit
         */
        min_gas_multiplier?: string;
      };
    };
    /**
     * @description DenomTrace contains the base denomination for ICS20 fungible tokens and the
     * source tracing information path.
     */
    "ibc.applications.transfer.v1.DenomTrace": {
      /**
       * @description path defines the chain of port/channel identifiers used for tracing the
       * source of the fungible token.
       */
      path?: string;
      /** @description base denomination of the relayed fungible token. */
      base_denom?: string;
    };
    /**
     * @description Params defines the set of IBC transfer parameters.
     * NOTE: To prevent a single token from being transferred, set the
     * TransfersEnabled parameter to true and then set the bank module's SendEnabled
     * parameter for the denomination to false.
     */
    "ibc.applications.transfer.v1.Params": {
      /**
       * @description send_enabled enables or disables all cross-chain token transfers from this
       * chain.
       */
      send_enabled?: boolean;
      /**
       * @description receive_enabled enables or disables all cross-chain token transfers to this
       * chain.
       */
      receive_enabled?: boolean;
    };
    /**
     * @description QueryDenomHashResponse is the response type for the Query/DenomHash RPC
     * method.
     */
    "ibc.applications.transfer.v1.QueryDenomHashResponse": {
      /** @description hash (in hex format) of the denomination trace information. */
      hash?: string;
    };
    /**
     * @description QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
     * method.
     */
    "ibc.applications.transfer.v1.QueryDenomTraceResponse": {
      /**
       * @description DenomTrace contains the base denomination for ICS20 fungible tokens and the
       * source tracing information path.
       */
      denom_trace?: {
        /**
         * @description path defines the chain of port/channel identifiers used for tracing the
         * source of the fungible token.
         */
        path?: string;
        /** @description base denomination of the relayed fungible token. */
        base_denom?: string;
      };
    };
    /**
     * @description QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
     * method.
     */
    "ibc.applications.transfer.v1.QueryDenomTracesResponse": {
      /** @description denom_traces returns all denominations trace information. */
      denom_traces?: {
        /**
         * @description path defines the chain of port/channel identifiers used for tracing the
         * source of the fungible token.
         */
        path?: string;
        /** @description base denomination of the relayed fungible token. */
        base_denom?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method. */
    "ibc.applications.transfer.v1.QueryEscrowAddressResponse": {
      /** the escrow account address */
      escrow_address?: string;
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "ibc.applications.transfer.v1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /**
         * @description send_enabled enables or disables all cross-chain token transfers from this
         * chain.
         */
        send_enabled?: boolean;
        /**
         * @description receive_enabled enables or disables all cross-chain token transfers to this
         * chain.
         */
        receive_enabled?: boolean;
      };
    };
    /** @description QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method. */
    "ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse": {
      /**
       * @description Coin defines a token with a denomination and an amount.
       *
       * NOTE: The amount field is an Int which implements the custom method
       * signatures required by gogoproto.
       */
      amount?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * @description ConsensusStateWithHeight defines a consensus state with an additional height
     * field.
     */
    "ibc.core.client.v1.ConsensusStateWithHeight": {
      /**
       * consensus state height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
      /**
       * consensus state
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      consensus_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /**
     * Height is a monotonically increasing data type
     * that can be compared against another Height for the purposes of updating and
     * freezing clients
     * @description Normally the RevisionHeight is incremented at each height while keeping
     * RevisionNumber the same. However some consensus algorithms may choose to
     * reset the height in certain conditions e.g. hard forks, state-machine
     * breaking changes In these cases, the RevisionNumber is incremented so that
     * height continues to be monitonically increasing even as the RevisionHeight
     * gets reset
     */
    "ibc.core.client.v1.Height": {
      /**
       * the revision that the client is currently on
       * Format: uint64
       */
      revision_number?: string;
      /**
       * the height within the given revision
       * Format: uint64
       */
      revision_height?: string;
    };
    /**
     * @description IdentifiedClientState defines a client state with an additional client
     * identifier field.
     */
    "ibc.core.client.v1.IdentifiedClientState": {
      /** client identifier */
      client_id?: string;
      /**
       * client state
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      client_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description Params defines the set of IBC light client parameters. */
    "ibc.core.client.v1.Params": {
      /**
       * @description allowed_clients defines the list of allowed client state types which can be created
       * and interacted with. If a client type is removed from the allowed clients list, usage
       * of this client will be disabled until it is added again to the list.
       */
      allowed_clients?: string[];
    };
    /**
     * @description QueryClientParamsResponse is the response type for the Query/ClientParams RPC
     * method.
     */
    "ibc.core.client.v1.QueryClientParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /**
         * @description allowed_clients defines the list of allowed client state types which can be created
         * and interacted with. If a client type is removed from the allowed clients list, usage
         * of this client will be disabled until it is added again to the list.
         */
        allowed_clients?: string[];
      };
    };
    /**
     * @description QueryClientStateResponse is the response type for the Query/ClientState RPC
     * method. Besides the client state, it includes a proof and the height from
     * which the proof was retrieved.
     */
    "ibc.core.client.v1.QueryClientStateResponse": {
      /**
       * client state associated with the request identifier
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      client_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * @description QueryClientStatesResponse is the response type for the Query/ClientStates RPC
     * method.
     */
    "ibc.core.client.v1.QueryClientStatesResponse": {
      /** @description list of stored ClientStates of the chain. */
      client_states?: {
        /** client identifier */
        client_id?: string;
        /**
         * client state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        client_state?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
     * method. It returns the current status of the IBC client.
     */
    "ibc.core.client.v1.QueryClientStatusResponse": {
      status?: string;
    };
    /**
     * QueryConsensusStateHeightsResponse is the response type for the
     * Query/ConsensusStateHeights RPC method
     */
    "ibc.core.client.v1.QueryConsensusStateHeightsResponse": {
      /** consensus state heights */
      consensus_state_heights?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * QueryConsensusStateResponse is the response type for the Query/ConsensusState
     * RPC method
     */
    "ibc.core.client.v1.QueryConsensusStateResponse": {
      /**
       * consensus state associated with the client identifier at the given height
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      consensus_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * Height is a monotonically increasing data type
       * that can be compared against another Height for the purposes of updating and
       * freezing clients
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryConsensusStatesResponse is the response type for the
     * Query/ConsensusStates RPC method
     */
    "ibc.core.client.v1.QueryConsensusStatesResponse": {
      /** consensus states associated with the identifier */
      consensus_states?: {
        /**
         * consensus state height
         * @description Normally the RevisionHeight is incremented at each height while keeping
         * RevisionNumber the same. However some consensus algorithms may choose to
         * reset the height in certain conditions e.g. hard forks, state-machine
         * breaking changes In these cases, the RevisionNumber is incremented so that
         * height continues to be monitonically increasing even as the RevisionHeight
         * gets reset
         */
        height?: {
          /**
           * the revision that the client is currently on
           * Format: uint64
           */
          revision_number?: string;
          /**
           * the height within the given revision
           * Format: uint64
           */
          revision_height?: string;
        };
        /**
         * consensus state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        consensus_state?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryUpgradedClientStateResponse is the response type for the
     * Query/UpgradedClientState RPC method.
     */
    "ibc.core.client.v1.QueryUpgradedClientStateResponse": {
      /**
       * client state associated with the request identifier
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      upgraded_client_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /**
     * @description QueryUpgradedConsensusStateResponse is the response type for the
     * Query/UpgradedConsensusState RPC method.
     */
    "ibc.core.client.v1.QueryUpgradedConsensusStateResponse": {
      /**
       * Consensus state associated with the request identifier
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      upgraded_consensus_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /**
     * MerklePrefix is merkle path prefixed to the key.
     * The constructed key from the Path and the key will be append(Path.KeyPath,
     * append(Path.KeyPrefix, key...))
     */
    "ibc.core.commitment.v1.MerklePrefix": {
      /** Format: byte */
      key_prefix?: string;
    };
    /**
     * @description ConnectionEnd defines a stateful object on a chain connected to another
     * separate one.
     * NOTE: there must only be 2 defined ConnectionEnds to establish
     * a connection between two chains.
     */
    "ibc.core.connection.v1.ConnectionEnd": {
      /** @description client associated with this connection. */
      client_id?: string;
      /**
       * @description IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection.
       */
      versions?: {
        /** unique version identifier */
        identifier?: string;
        /** list of features compatible with the specified identifier */
        features?: string[];
      }[];
      /**
       * @description current state of the connection end.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state?:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN";
      /** @description counterparty chain associated with this connection. */
      counterparty?: {
        /**
         * @description identifies the client on the counterparty chain associated with a given
         * connection.
         */
        client_id?: string;
        /**
         * @description identifies the connection end on the counterparty chain associated with a
         * given connection.
         */
        connection_id?: string;
        /**
         * MerklePrefix is merkle path prefixed to the key.
         * The constructed key from the Path and the key will be append(Path.KeyPath,
         * append(Path.KeyPrefix, key...))
         * @description commitment merkle prefix of the counterparty chain.
         */
        prefix?: {
          /** Format: byte */
          key_prefix?: string;
        };
      };
      /**
       * Format: uint64
       * @description delay period that must pass before a consensus state can be used for
       * packet-verification NOTE: delay period logic is only implemented by some
       * clients.
       */
      delay_period?: string;
    };
    /** @description Counterparty defines the counterparty chain associated with a connection end. */
    "ibc.core.connection.v1.Counterparty": {
      /**
       * @description identifies the client on the counterparty chain associated with a given
       * connection.
       */
      client_id?: string;
      /**
       * @description identifies the connection end on the counterparty chain associated with a
       * given connection.
       */
      connection_id?: string;
      /**
       * MerklePrefix is merkle path prefixed to the key.
       * The constructed key from the Path and the key will be append(Path.KeyPath,
       * append(Path.KeyPrefix, key...))
       * @description commitment merkle prefix of the counterparty chain.
       */
      prefix?: {
        /** Format: byte */
        key_prefix?: string;
      };
    };
    /**
     * @description IdentifiedConnection defines a connection with additional connection
     * identifier field.
     */
    "ibc.core.connection.v1.IdentifiedConnection": {
      /** @description connection identifier. */
      id?: string;
      /** @description client associated with this connection. */
      client_id?: string;
      /**
       * IBC version which can be utilised to determine encodings or protocols for
       * channels or packets utilising this connection
       */
      versions?: {
        /** unique version identifier */
        identifier?: string;
        /** list of features compatible with the specified identifier */
        features?: string[];
      }[];
      /**
       * @description current state of the connection end.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state?:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN";
      /** @description counterparty chain associated with this connection. */
      counterparty?: {
        /**
         * @description identifies the client on the counterparty chain associated with a given
         * connection.
         */
        client_id?: string;
        /**
         * @description identifies the connection end on the counterparty chain associated with a
         * given connection.
         */
        connection_id?: string;
        /**
         * MerklePrefix is merkle path prefixed to the key.
         * The constructed key from the Path and the key will be append(Path.KeyPath,
         * append(Path.KeyPrefix, key...))
         * @description commitment merkle prefix of the counterparty chain.
         */
        prefix?: {
          /** Format: byte */
          key_prefix?: string;
        };
      };
      /**
       * Format: uint64
       * @description delay period associated with this connection.
       */
      delay_period?: string;
    };
    /** @description Params defines the set of Connection parameters. */
    "ibc.core.connection.v1.Params": {
      /**
       * Format: uint64
       * @description maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
       * largest amount of time that the chain might reasonably take to produce the next block under normal operating
       * conditions. A safe choice is 3-5x the expected time per block.
       */
      max_expected_time_per_block?: string;
    };
    /**
     * QueryClientConnectionsResponse is the response type for the
     * Query/ClientConnections RPC method
     */
    "ibc.core.connection.v1.QueryClientConnectionsResponse": {
      /** @description slice of all the connection paths associated with a client. */
      connection_paths?: string[];
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was generated
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryConnectionClientStateResponse is the response type for the
     * Query/ConnectionClientState RPC method
     */
    "ibc.core.connection.v1.QueryConnectionClientStateResponse": {
      /**
       * client state associated with the channel
       * @description IdentifiedClientState defines a client state with an additional client
       * identifier field.
       */
      identified_client_state?: {
        /** client identifier */
        client_id?: string;
        /**
         * client state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        client_state?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryConnectionConsensusStateResponse is the response type for the
     * Query/ConnectionConsensusState RPC method
     */
    "ibc.core.connection.v1.QueryConnectionConsensusStateResponse": {
      /**
       * consensus state associated with the channel
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      consensus_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** client ID associated with the consensus state */
      client_id?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** @description QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method. */
    "ibc.core.connection.v1.QueryConnectionParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /**
         * Format: uint64
         * @description maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
         * largest amount of time that the chain might reasonably take to produce the next block under normal operating
         * conditions. A safe choice is 3-5x the expected time per block.
         */
        max_expected_time_per_block?: string;
      };
    };
    /**
     * @description QueryConnectionResponse is the response type for the Query/Connection RPC
     * method. Besides the connection end, it includes a proof and the height from
     * which the proof was retrieved.
     */
    "ibc.core.connection.v1.QueryConnectionResponse": {
      /**
       * connection associated with the request identifier
       * @description ConnectionEnd defines a stateful object on a chain connected to another
       * separate one.
       * NOTE: there must only be 2 defined ConnectionEnds to establish
       * a connection between two chains.
       */
      connection?: {
        /** @description client associated with this connection. */
        client_id?: string;
        /**
         * @description IBC version which can be utilised to determine encodings or protocols for
         * channels or packets utilising this connection.
         */
        versions?: {
          /** unique version identifier */
          identifier?: string;
          /** list of features compatible with the specified identifier */
          features?: string[];
        }[];
        /**
         * @description current state of the connection end.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state?:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN";
        /** @description counterparty chain associated with this connection. */
        counterparty?: {
          /**
           * @description identifies the client on the counterparty chain associated with a given
           * connection.
           */
          client_id?: string;
          /**
           * @description identifies the connection end on the counterparty chain associated with a
           * given connection.
           */
          connection_id?: string;
          /**
           * MerklePrefix is merkle path prefixed to the key.
           * The constructed key from the Path and the key will be append(Path.KeyPath,
           * append(Path.KeyPrefix, key...))
           * @description commitment merkle prefix of the counterparty chain.
           */
          prefix?: {
            /** Format: byte */
            key_prefix?: string;
          };
        };
        /**
         * Format: uint64
         * @description delay period that must pass before a consensus state can be used for
         * packet-verification NOTE: delay period logic is only implemented by some
         * clients.
         */
        delay_period?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * @description QueryConnectionsResponse is the response type for the Query/Connections RPC
     * method.
     */
    "ibc.core.connection.v1.QueryConnectionsResponse": {
      /** @description list of stored connections of the chain. */
      connections?: {
        /** @description connection identifier. */
        id?: string;
        /** @description client associated with this connection. */
        client_id?: string;
        /**
         * IBC version which can be utilised to determine encodings or protocols for
         * channels or packets utilising this connection
         */
        versions?: {
          /** unique version identifier */
          identifier?: string;
          /** list of features compatible with the specified identifier */
          features?: string[];
        }[];
        /**
         * @description current state of the connection end.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state?:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN";
        /** @description counterparty chain associated with this connection. */
        counterparty?: {
          /**
           * @description identifies the client on the counterparty chain associated with a given
           * connection.
           */
          client_id?: string;
          /**
           * @description identifies the connection end on the counterparty chain associated with a
           * given connection.
           */
          connection_id?: string;
          /**
           * MerklePrefix is merkle path prefixed to the key.
           * The constructed key from the Path and the key will be append(Path.KeyPath,
           * append(Path.KeyPrefix, key...))
           * @description commitment merkle prefix of the counterparty chain.
           */
          prefix?: {
            /** Format: byte */
            key_prefix?: string;
          };
        };
        /**
         * Format: uint64
         * @description delay period associated with this connection.
         */
        delay_period?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * @description State defines if a connection is in one of the following states:
     * INIT, TRYOPEN, OPEN or UNINITIALIZED.
     *
     *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
     *  - STATE_INIT: A connection end has just started the opening handshake.
     *  - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty
     * chain.
     *  - STATE_OPEN: A connection end has completed the handshake.
     * @default STATE_UNINITIALIZED_UNSPECIFIED
     * @enum {string}
     */
    "ibc.core.connection.v1.State":
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN";
    /**
     * @description Version defines the versioning scheme used to negotiate the IBC verison in
     * the connection handshake.
     */
    "ibc.core.connection.v1.Version": {
      /** unique version identifier */
      identifier?: string;
      /** list of features compatible with the specified identifier */
      features?: string[];
    };
    /**
     * @description Channel defines pipeline for exactly-once packet delivery between specific
     * modules on separate blockchains, which has at least one end capable of
     * sending packets and one end capable of receiving packets.
     */
    "ibc.core.channel.v1.Channel": {
      /**
       * current state of the channel end
       * @description State defines if a channel is in one of the following states:
       * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
       *
       *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
       *  - STATE_INIT: A channel has just started the opening handshake.
       *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
       *  - STATE_OPEN: A channel has completed the handshake. Open channels are
       * ready to send and receive packets.
       *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
       * packets.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state?:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN"
        | "STATE_CLOSED";
      /**
       * whether the channel is ordered or unordered
       * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
       *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
       * which they were sent.
       *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
       * @default ORDER_NONE_UNSPECIFIED
       * @enum {string}
       */
      ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
      /** counterparty channel end */
      counterparty?: {
        /** @description port on the counterparty chain which owns the other end of the channel. */
        port_id?: string;
        /** channel end on the counterparty chain */
        channel_id?: string;
      };
      /**
       * list of connection identifiers, in order, along which packets sent on
       * this channel will travel
       */
      connection_hops?: string[];
      /** opaque channel version, which is agreed upon during the handshake */
      version?: string;
    };
    /** Counterparty defines a channel end counterparty */
    "ibc.core.channel.v1.Counterparty": {
      /** @description port on the counterparty chain which owns the other end of the channel. */
      port_id?: string;
      /** channel end on the counterparty chain */
      channel_id?: string;
    };
    /**
     * @description IdentifiedChannel defines a channel with additional port and channel
     * identifier fields.
     */
    "ibc.core.channel.v1.IdentifiedChannel": {
      /**
       * current state of the channel end
       * @description State defines if a channel is in one of the following states:
       * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
       *
       *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
       *  - STATE_INIT: A channel has just started the opening handshake.
       *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
       *  - STATE_OPEN: A channel has completed the handshake. Open channels are
       * ready to send and receive packets.
       *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
       * packets.
       * @default STATE_UNINITIALIZED_UNSPECIFIED
       * @enum {string}
       */
      state?:
        | "STATE_UNINITIALIZED_UNSPECIFIED"
        | "STATE_INIT"
        | "STATE_TRYOPEN"
        | "STATE_OPEN"
        | "STATE_CLOSED";
      /**
       * whether the channel is ordered or unordered
       * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
       *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
       * which they were sent.
       *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
       * @default ORDER_NONE_UNSPECIFIED
       * @enum {string}
       */
      ordering?: "ORDER_NONE_UNSPECIFIED" | "ORDER_UNORDERED" | "ORDER_ORDERED";
      /** counterparty channel end */
      counterparty?: {
        /** @description port on the counterparty chain which owns the other end of the channel. */
        port_id?: string;
        /** channel end on the counterparty chain */
        channel_id?: string;
      };
      /**
       * list of connection identifiers, in order, along which packets sent on
       * this channel will travel
       */
      connection_hops?: string[];
      /** opaque channel version, which is agreed upon during the handshake */
      version?: string;
      /** port identifier */
      port_id?: string;
      /** channel identifier */
      channel_id?: string;
    };
    /**
     * Order defines if a channel is ORDERED or UNORDERED
     * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
     *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
     * which they were sent.
     *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
     * @default ORDER_NONE_UNSPECIFIED
     * @enum {string}
     */
    "ibc.core.channel.v1.Order":
      | "ORDER_NONE_UNSPECIFIED"
      | "ORDER_UNORDERED"
      | "ORDER_ORDERED";
    /**
     * @description PacketState defines the generic type necessary to retrieve and store
     * packet commitments, acknowledgements, and receipts.
     * Caller is responsible for knowing the context necessary to interpret this
     * state as a commitment, acknowledgement, or a receipt.
     */
    "ibc.core.channel.v1.PacketState": {
      /** @description channel port identifier. */
      port_id?: string;
      /** @description channel unique identifier. */
      channel_id?: string;
      /**
       * Format: uint64
       * @description packet sequence.
       */
      sequence?: string;
      /**
       * Format: byte
       * @description embedded data that represents packet state.
       */
      data?: string;
    };
    /**
     * QueryChannelClientStateResponse is the Response type for the
     * Query/QueryChannelClientState RPC method
     */
    "ibc.core.channel.v1.QueryChannelClientStateResponse": {
      /**
       * client state associated with the channel
       * @description IdentifiedClientState defines a client state with an additional client
       * identifier field.
       */
      identified_client_state?: {
        /** client identifier */
        client_id?: string;
        /**
         * client state
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        client_state?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryChannelClientStateResponse is the Response type for the
     * Query/QueryChannelClientState RPC method
     */
    "ibc.core.channel.v1.QueryChannelConsensusStateResponse": {
      /**
       * consensus state associated with the channel
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      consensus_state?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** client ID associated with the consensus state */
      client_id?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * @description QueryChannelResponse is the response type for the Query/Channel RPC method.
     * Besides the Channel end, it includes a proof and the height from which the
     * proof was retrieved.
     */
    "ibc.core.channel.v1.QueryChannelResponse": {
      /**
       * channel associated with the request identifiers
       * @description Channel defines pipeline for exactly-once packet delivery between specific
       * modules on separate blockchains, which has at least one end capable of
       * sending packets and one end capable of receiving packets.
       */
      channel?: {
        /**
         * current state of the channel end
         * @description State defines if a channel is in one of the following states:
         * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
         *
         *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
         *  - STATE_INIT: A channel has just started the opening handshake.
         *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
         *  - STATE_OPEN: A channel has completed the handshake. Open channels are
         * ready to send and receive packets.
         *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
         * packets.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state?:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN"
          | "STATE_CLOSED";
        /**
         * whether the channel is ordered or unordered
         * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
         *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
         * which they were sent.
         *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
         * @default ORDER_NONE_UNSPECIFIED
         * @enum {string}
         */
        ordering?:
          | "ORDER_NONE_UNSPECIFIED"
          | "ORDER_UNORDERED"
          | "ORDER_ORDERED";
        /** counterparty channel end */
        counterparty?: {
          /** @description port on the counterparty chain which owns the other end of the channel. */
          port_id?: string;
          /** channel end on the counterparty chain */
          channel_id?: string;
        };
        /**
         * list of connection identifiers, in order, along which packets sent on
         * this channel will travel
         */
        connection_hops?: string[];
        /** opaque channel version, which is agreed upon during the handshake */
        version?: string;
      };
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /** @description QueryChannelsResponse is the response type for the Query/Channels RPC method. */
    "ibc.core.channel.v1.QueryChannelsResponse": {
      /** @description list of stored channels of the chain. */
      channels?: {
        /**
         * current state of the channel end
         * @description State defines if a channel is in one of the following states:
         * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
         *
         *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
         *  - STATE_INIT: A channel has just started the opening handshake.
         *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
         *  - STATE_OPEN: A channel has completed the handshake. Open channels are
         * ready to send and receive packets.
         *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
         * packets.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state?:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN"
          | "STATE_CLOSED";
        /**
         * whether the channel is ordered or unordered
         * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
         *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
         * which they were sent.
         *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
         * @default ORDER_NONE_UNSPECIFIED
         * @enum {string}
         */
        ordering?:
          | "ORDER_NONE_UNSPECIFIED"
          | "ORDER_UNORDERED"
          | "ORDER_ORDERED";
        /** counterparty channel end */
        counterparty?: {
          /** @description port on the counterparty chain which owns the other end of the channel. */
          port_id?: string;
          /** channel end on the counterparty chain */
          channel_id?: string;
        };
        /**
         * list of connection identifiers, in order, along which packets sent on
         * this channel will travel
         */
        connection_hops?: string[];
        /** opaque channel version, which is agreed upon during the handshake */
        version?: string;
        /** port identifier */
        port_id?: string;
        /** channel identifier */
        channel_id?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryConnectionChannelsResponse is the Response type for the
     * Query/QueryConnectionChannels RPC method
     */
    "ibc.core.channel.v1.QueryConnectionChannelsResponse": {
      /** @description list of channels associated with a connection. */
      channels?: {
        /**
         * current state of the channel end
         * @description State defines if a channel is in one of the following states:
         * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
         *
         *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
         *  - STATE_INIT: A channel has just started the opening handshake.
         *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
         *  - STATE_OPEN: A channel has completed the handshake. Open channels are
         * ready to send and receive packets.
         *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
         * packets.
         * @default STATE_UNINITIALIZED_UNSPECIFIED
         * @enum {string}
         */
        state?:
          | "STATE_UNINITIALIZED_UNSPECIFIED"
          | "STATE_INIT"
          | "STATE_TRYOPEN"
          | "STATE_OPEN"
          | "STATE_CLOSED";
        /**
         * whether the channel is ordered or unordered
         * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
         *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
         * which they were sent.
         *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
         * @default ORDER_NONE_UNSPECIFIED
         * @enum {string}
         */
        ordering?:
          | "ORDER_NONE_UNSPECIFIED"
          | "ORDER_UNORDERED"
          | "ORDER_ORDERED";
        /** counterparty channel end */
        counterparty?: {
          /** @description port on the counterparty chain which owns the other end of the channel. */
          port_id?: string;
          /** channel end on the counterparty chain */
          channel_id?: string;
        };
        /**
         * list of connection identifiers, in order, along which packets sent on
         * this channel will travel
         */
        connection_hops?: string[];
        /** opaque channel version, which is agreed upon during the handshake */
        version?: string;
        /** port identifier */
        port_id?: string;
        /** channel identifier */
        channel_id?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QuerySequenceResponse is the request type for the
     * Query/QueryNextSequenceReceiveResponse RPC method
     */
    "ibc.core.channel.v1.QueryNextSequenceReceiveResponse": {
      /**
       * next sequence receive number
       * Format: uint64
       */
      next_sequence_receive?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryNextSequenceSendResponse is the request type for the
     * Query/QueryNextSequenceSend RPC method
     */
    "ibc.core.channel.v1.QueryNextSequenceSendResponse": {
      /**
       * next sequence send number
       * Format: uint64
       */
      next_sequence_send?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryPacketAcknowledgementResponse defines the client query response for a
     * packet which also includes a proof and the height from which the
     * proof was retrieved
     */
    "ibc.core.channel.v1.QueryPacketAcknowledgementResponse": {
      /**
       * packet associated with the request fields
       * Format: byte
       */
      acknowledgement?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryPacketAcknowledgemetsResponse is the request type for the
     * Query/QueryPacketAcknowledgements RPC method
     */
    "ibc.core.channel.v1.QueryPacketAcknowledgementsResponse": {
      acknowledgements?: {
        /** @description channel port identifier. */
        port_id?: string;
        /** @description channel unique identifier. */
        channel_id?: string;
        /**
         * Format: uint64
         * @description packet sequence.
         */
        sequence?: string;
        /**
         * Format: byte
         * @description embedded data that represents packet state.
         */
        data?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryPacketCommitmentResponse defines the client query response for a packet
     * which also includes a proof and the height from which the proof was
     * retrieved
     */
    "ibc.core.channel.v1.QueryPacketCommitmentResponse": {
      /**
       * packet associated with the request fields
       * Format: byte
       */
      commitment?: string;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryPacketCommitmentsResponse is the request type for the
     * Query/QueryPacketCommitments RPC method
     */
    "ibc.core.channel.v1.QueryPacketCommitmentsResponse": {
      commitments?: {
        /** @description channel port identifier. */
        port_id?: string;
        /** @description channel unique identifier. */
        channel_id?: string;
        /**
         * Format: uint64
         * @description packet sequence.
         */
        sequence?: string;
        /**
         * Format: byte
         * @description embedded data that represents packet state.
         */
        data?: string;
      }[];
      /**
       * pagination response
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryPacketReceiptResponse defines the client query response for a packet
     * receipt which also includes a proof, and the height from which the proof was
     * retrieved
     */
    "ibc.core.channel.v1.QueryPacketReceiptResponse": {
      /** success flag for if receipt exists */
      received?: boolean;
      /**
       * merkle proof of existence
       * Format: byte
       */
      proof?: string;
      /**
       * height at which the proof was retrieved
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      proof_height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryUnreceivedAcksResponse is the response type for the
     * Query/UnreceivedAcks RPC method
     */
    "ibc.core.channel.v1.QueryUnreceivedAcksResponse": {
      /** list of unreceived acknowledgement sequences */
      sequences?: string[];
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * QueryUnreceivedPacketsResponse is the response type for the
     * Query/UnreceivedPacketCommitments RPC method
     */
    "ibc.core.channel.v1.QueryUnreceivedPacketsResponse": {
      /** list of unreceived packet sequences */
      sequences?: string[];
      /**
       * query block height
       * @description Normally the RevisionHeight is incremented at each height while keeping
       * RevisionNumber the same. However some consensus algorithms may choose to
       * reset the height in certain conditions e.g. hard forks, state-machine
       * breaking changes In these cases, the RevisionNumber is incremented so that
       * height continues to be monitonically increasing even as the RevisionHeight
       * gets reset
       */
      height?: {
        /**
         * the revision that the client is currently on
         * Format: uint64
         */
        revision_number?: string;
        /**
         * the height within the given revision
         * Format: uint64
         */
        revision_height?: string;
      };
    };
    /**
     * @description State defines if a channel is in one of the following states:
     * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
     *
     *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
     *  - STATE_INIT: A channel has just started the opening handshake.
     *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
     *  - STATE_OPEN: A channel has completed the handshake. Open channels are
     * ready to send and receive packets.
     *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
     * packets.
     * @default STATE_UNINITIALIZED_UNSPECIFIED
     * @enum {string}
     */
    "ibc.core.channel.v1.State":
      | "STATE_UNINITIALIZED_UNSPECIFIED"
      | "STATE_INIT"
      | "STATE_TRYOPEN"
      | "STATE_OPEN"
      | "STATE_CLOSED";
    /**
     * @description AddressBytesToStringResponse is the response type for AddressString rpc method.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.auth.v1beta1.AddressBytesToStringResponse": {
      address_string?: string;
    };
    /**
     * @description AddressStringToBytesResponse is the response type for AddressBytes rpc method.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.auth.v1beta1.AddressStringToBytesResponse": {
      /** Format: byte */
      address_bytes?: string;
    };
    /**
     * @description BaseAccount defines a base account type. It contains all the necessary fields
     * for basic account functionality. Any custom account type should extend this
     * type for additional functionality (e.g. vesting).
     */
    "cosmos.auth.v1beta1.BaseAccount": {
      address?: string;
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      pub_key?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** Format: uint64 */
      account_number?: string;
      /** Format: uint64 */
      sequence?: string;
    };
    /**
     * @description Bech32PrefixResponse is the response type for Bech32Prefix rpc method.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.auth.v1beta1.Bech32PrefixResponse": {
      bech32_prefix?: string;
    };
    /** @description Params defines the parameters for the auth module. */
    "cosmos.auth.v1beta1.Params": {
      /** Format: uint64 */
      max_memo_characters?: string;
      /** Format: uint64 */
      tx_sig_limit?: string;
      /** Format: uint64 */
      tx_size_cost_per_byte?: string;
      /** Format: uint64 */
      sig_verify_cost_ed25519?: string;
      /** Format: uint64 */
      sig_verify_cost_secp256k1?: string;
    };
    /**
     * QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method
     * @description Since: cosmos-sdk 0.46.2
     */
    "cosmos.auth.v1beta1.QueryAccountAddressByIDResponse": {
      account_address?: string;
    };
    /**
     * @description QueryAccountInfoResponse is the Query/AccountInfo response type.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.auth.v1beta1.QueryAccountInfoResponse": {
      /** @description info is the account info which is represented by BaseAccount. */
      info?: {
        address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        pub_key?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** Format: uint64 */
        account_number?: string;
        /** Format: uint64 */
        sequence?: string;
      };
    };
    /** @description QueryAccountResponse is the response type for the Query/Account RPC method. */
    "cosmos.auth.v1beta1.QueryAccountResponse": {
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      account?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /**
     * @description QueryAccountsResponse is the response type for the Query/Accounts RPC method.
     *
     * Since: cosmos-sdk 0.43
     */
    "cosmos.auth.v1beta1.QueryAccountsResponse": {
      /** accounts are the existing accounts */
      accounts?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method. */
    "cosmos.auth.v1beta1.QueryModuleAccountByNameResponse": {
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      account?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /**
     * @description QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.auth.v1beta1.QueryModuleAccountsResponse": {
      accounts?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.auth.v1beta1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        /** Format: uint64 */
        max_memo_characters?: string;
        /** Format: uint64 */
        tx_sig_limit?: string;
        /** Format: uint64 */
        tx_size_cost_per_byte?: string;
        /** Format: uint64 */
        sig_verify_cost_ed25519?: string;
        /** Format: uint64 */
        sig_verify_cost_secp256k1?: string;
      };
    };
    /**
     * @description Grant gives permissions to execute
     * the provide method with expiration time.
     */
    "cosmos.authz.v1beta1.Grant": {
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      authorization?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * time when the grant will expire and will be pruned. If null, then the grant
       * doesn't have a time expiration (other conditions  in `authorization`
       * may apply to invalidate the grant)
       * Format: date-time
       */
      expiration?: string;
    };
    /**
     * GrantAuthorization extends a grant with both the addresses of the grantee and granter.
     * It is used in genesis.proto and query.proto
     */
    "cosmos.authz.v1beta1.GrantAuthorization": {
      granter?: string;
      grantee?: string;
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      authorization?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** Format: date-time */
      expiration?: string;
    };
    /** @description QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method. */
    "cosmos.authz.v1beta1.QueryGranteeGrantsResponse": {
      /** @description grants is a list of grants granted to the grantee. */
      grants?: {
        granter?: string;
        grantee?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        authorization?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** Format: date-time */
        expiration?: string;
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method. */
    "cosmos.authz.v1beta1.QueryGranterGrantsResponse": {
      /** @description grants is a list of grants granted by the granter. */
      grants?: {
        granter?: string;
        grantee?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        authorization?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** Format: date-time */
        expiration?: string;
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryGrantsResponse is the response type for the Query/Authorizations RPC method. */
    "cosmos.authz.v1beta1.QueryGrantsResponse": {
      /** @description authorizations is a list of grants granted for grantee by granter. */
      grants?: {
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        authorization?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * time when the grant will expire and will be pruned. If null, then the grant
         * doesn't have a time expiration (other conditions  in `authorization`
         * may apply to invalidate the grant)
         * Format: date-time
         */
        expiration?: string;
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description DenomOwner defines structure representing an account that owns or holds a
     * particular denominated token. It contains the account address and account
     * balance of the denominated token.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.bank.v1beta1.DenomOwner": {
      /** @description address defines the address that owns a particular denomination. */
      address?: string;
      /**
       * @description Coin defines a token with a denomination and an amount.
       *
       * NOTE: The amount field is an Int which implements the custom method
       * signatures required by gogoproto.
       */
      balance?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * @description DenomUnit represents a struct that describes a given
     * denomination unit of the basic token.
     */
    "cosmos.bank.v1beta1.DenomUnit": {
      /** @description denom represents the string name of the given denom unit (e.g uatom). */
      denom?: string;
      /**
       * Format: int64
       * @description exponent represents power of 10 exponent that one must
       * raise the base_denom to in order to equal the given DenomUnit's denom
       * 1 denom = 10^exponent base_denom
       * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
       * exponent = 6, thus: 1 atom = 10^6 uatom).
       */
      exponent?: number;
      /** aliases is a list of string aliases for the given denom */
      aliases?: string[];
    };
    /**
     * @description Metadata represents a struct that describes
     * a basic token.
     */
    "cosmos.bank.v1beta1.Metadata": {
      description?: string;
      /** denom_units represents the list of DenomUnit's for a given coin */
      denom_units?: {
        /** @description denom represents the string name of the given denom unit (e.g uatom). */
        denom?: string;
        /**
         * Format: int64
         * @description exponent represents power of 10 exponent that one must
         * raise the base_denom to in order to equal the given DenomUnit's denom
         * 1 denom = 10^exponent base_denom
         * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
         * exponent = 6, thus: 1 atom = 10^6 uatom).
         */
        exponent?: number;
        /** aliases is a list of string aliases for the given denom */
        aliases?: string[];
      }[];
      /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
      base?: string;
      /**
       * @description display indicates the suggested denom that should be
       * displayed in clients.
       */
      display?: string;
      /**
       * name defines the name of the token (eg: Cosmos Atom)
       * @description Since: cosmos-sdk 0.43
       */
      name?: string;
      /**
       * @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
       * be the same as the display.
       *
       * Since: cosmos-sdk 0.43
       */
      symbol?: string;
      /**
       * @description URI to a document (on or off-chain) that contains additional information. Optional.
       *
       * Since: cosmos-sdk 0.46
       */
      uri?: string;
      /**
       * @description URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
       * the document didn't change. Optional.
       *
       * Since: cosmos-sdk 0.46
       */
      uri_hash?: string;
    };
    /** @description Params defines the parameters for the bank module. */
    "cosmos.bank.v1beta1.Params": {
      /**
       * @description Deprecated: Use of SendEnabled in params is deprecated.
       * For genesis, use the newly added send_enabled field in the genesis object.
       * Storage, lookup, and manipulation of this information is now in the keeper.
       *
       * As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.
       */
      send_enabled?: {
        denom?: string;
        enabled?: boolean;
      }[];
      default_send_enabled?: boolean;
    };
    /**
     * @description QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
     * method.
     */
    "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
      /** @description balances is the balances of all the coins. */
      balances?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryBalanceResponse is the response type for the Query/Balance RPC method. */
    "cosmos.bank.v1beta1.QueryBalanceResponse": {
      /**
       * @description Coin defines a token with a denomination and an amount.
       *
       * NOTE: The amount field is an Int which implements the custom method
       * signatures required by gogoproto.
       */
      balance?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * @description QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC
     * method. Identical with QueryDenomMetadataResponse but receives denom as query string in request.
     */
    "cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse": {
      /**
       * @description Metadata represents a struct that describes
       * a basic token.
       */
      metadata?: {
        description?: string;
        /** denom_units represents the list of DenomUnit's for a given coin */
        denom_units?: {
          /** @description denom represents the string name of the given denom unit (e.g uatom). */
          denom?: string;
          /**
           * Format: int64
           * @description exponent represents power of 10 exponent that one must
           * raise the base_denom to in order to equal the given DenomUnit's denom
           * 1 denom = 10^exponent base_denom
           * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
           * exponent = 6, thus: 1 atom = 10^6 uatom).
           */
          exponent?: number;
          /** aliases is a list of string aliases for the given denom */
          aliases?: string[];
        }[];
        /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
        base?: string;
        /**
         * @description display indicates the suggested denom that should be
         * displayed in clients.
         */
        display?: string;
        /**
         * name defines the name of the token (eg: Cosmos Atom)
         * @description Since: cosmos-sdk 0.43
         */
        name?: string;
        /**
         * @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
         * be the same as the display.
         *
         * Since: cosmos-sdk 0.43
         */
        symbol?: string;
        /**
         * @description URI to a document (on or off-chain) that contains additional information. Optional.
         *
         * Since: cosmos-sdk 0.46
         */
        uri?: string;
        /**
         * @description URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
         * the document didn't change. Optional.
         *
         * Since: cosmos-sdk 0.46
         */
        uri_hash?: string;
      };
    };
    /**
     * @description QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
     * method.
     */
    "cosmos.bank.v1beta1.QueryDenomMetadataResponse": {
      /**
       * @description Metadata represents a struct that describes
       * a basic token.
       */
      metadata?: {
        description?: string;
        /** denom_units represents the list of DenomUnit's for a given coin */
        denom_units?: {
          /** @description denom represents the string name of the given denom unit (e.g uatom). */
          denom?: string;
          /**
           * Format: int64
           * @description exponent represents power of 10 exponent that one must
           * raise the base_denom to in order to equal the given DenomUnit's denom
           * 1 denom = 10^exponent base_denom
           * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
           * exponent = 6, thus: 1 atom = 10^6 uatom).
           */
          exponent?: number;
          /** aliases is a list of string aliases for the given denom */
          aliases?: string[];
        }[];
        /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
        base?: string;
        /**
         * @description display indicates the suggested denom that should be
         * displayed in clients.
         */
        display?: string;
        /**
         * name defines the name of the token (eg: Cosmos Atom)
         * @description Since: cosmos-sdk 0.43
         */
        name?: string;
        /**
         * @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
         * be the same as the display.
         *
         * Since: cosmos-sdk 0.43
         */
        symbol?: string;
        /**
         * @description URI to a document (on or off-chain) that contains additional information. Optional.
         *
         * Since: cosmos-sdk 0.46
         */
        uri?: string;
        /**
         * @description URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
         * the document didn't change. Optional.
         *
         * Since: cosmos-sdk 0.46
         */
        uri_hash?: string;
      };
    };
    /**
     * @description QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.bank.v1beta1.QueryDenomOwnersResponse": {
      denom_owners?: {
        /** @description address defines the address that owns a particular denomination. */
        address?: string;
        /**
         * @description Coin defines a token with a denomination and an amount.
         *
         * NOTE: The amount field is an Int which implements the custom method
         * signatures required by gogoproto.
         */
        balance?: {
          denom?: string;
          amount?: string;
        };
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
     * method.
     */
    "cosmos.bank.v1beta1.QueryDenomsMetadataResponse": {
      /** @description metadata provides the client information for all the registered tokens. */
      metadatas?: {
        description?: string;
        /** denom_units represents the list of DenomUnit's for a given coin */
        denom_units?: {
          /** @description denom represents the string name of the given denom unit (e.g uatom). */
          denom?: string;
          /**
           * Format: int64
           * @description exponent represents power of 10 exponent that one must
           * raise the base_denom to in order to equal the given DenomUnit's denom
           * 1 denom = 10^exponent base_denom
           * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
           * exponent = 6, thus: 1 atom = 10^6 uatom).
           */
          exponent?: number;
          /** aliases is a list of string aliases for the given denom */
          aliases?: string[];
        }[];
        /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
        base?: string;
        /**
         * @description display indicates the suggested denom that should be
         * displayed in clients.
         */
        display?: string;
        /**
         * name defines the name of the token (eg: Cosmos Atom)
         * @description Since: cosmos-sdk 0.43
         */
        name?: string;
        /**
         * @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
         * be the same as the display.
         *
         * Since: cosmos-sdk 0.43
         */
        symbol?: string;
        /**
         * @description URI to a document (on or off-chain) that contains additional information. Optional.
         *
         * Since: cosmos-sdk 0.46
         */
        uri?: string;
        /**
         * @description URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
         * the document didn't change. Optional.
         *
         * Since: cosmos-sdk 0.46
         */
        uri_hash?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse defines the response type for querying x/bank parameters. */
    "cosmos.bank.v1beta1.QueryParamsResponse": {
      /** @description params provides the parameters of the bank module. */
      params?: {
        /**
         * @description Deprecated: Use of SendEnabled in params is deprecated.
         * For genesis, use the newly added send_enabled field in the genesis object.
         * Storage, lookup, and manipulation of this information is now in the keeper.
         *
         * As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.
         */
        send_enabled?: {
          denom?: string;
          enabled?: boolean;
        }[];
        default_send_enabled?: boolean;
      };
    };
    /**
     * @description QuerySendEnabledResponse defines the RPC response of a SendEnable query.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.bank.v1beta1.QuerySendEnabledResponse": {
      send_enabled?: {
        denom?: string;
        enabled?: boolean;
      }[];
      /**
       * @description pagination defines the pagination in the response. This field is only
       * populated if the denoms field in the request is empty.
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QuerySpendableBalanceByDenomResponse defines the gRPC response structure for
     * querying an account's spendable balance for a specific denom.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse": {
      /**
       * @description Coin defines a token with a denomination and an amount.
       *
       * NOTE: The amount field is an Int which implements the custom method
       * signatures required by gogoproto.
       */
      balance?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * @description QuerySpendableBalancesResponse defines the gRPC response structure for querying
     * an account's spendable balances.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.bank.v1beta1.QuerySpendableBalancesResponse": {
      /** @description balances is the spendable balances of all the coins. */
      balances?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
    "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
      /**
       * @description Coin defines a token with a denomination and an amount.
       *
       * NOTE: The amount field is an Int which implements the custom method
       * signatures required by gogoproto.
       */
      amount?: {
        denom?: string;
        amount?: string;
      };
    };
    /**
     * QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
     * method
     */
    "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
      /** supply is the supply of the coins */
      supply?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * @description pagination defines the pagination in the response.
       *
       * Since: cosmos-sdk 0.43
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description SendEnabled maps coin denom to a send_enabled status (whether a denom is
     * sendable).
     */
    "cosmos.bank.v1beta1.SendEnabled": {
      denom?: string;
      enabled?: boolean;
    };
    /**
     * @description DelegationDelegatorReward represents the properties
     * of a delegator's delegation reward.
     */
    "cosmos.distribution.v1beta1.DelegationDelegatorReward": {
      validator_address?: string;
      reward?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description Params defines the set of params for the distribution module. */
    "cosmos.distribution.v1beta1.Params": {
      community_tax?: string;
      /**
       * @description Deprecated: The base_proposer_reward field is deprecated and is no longer used
       * in the x/distribution module's reward mechanism.
       */
      base_proposer_reward?: string;
      /**
       * @description Deprecated: The bonus_proposer_reward field is deprecated and is no longer used
       * in the x/distribution module's reward mechanism.
       */
      bonus_proposer_reward?: string;
      withdraw_addr_enabled?: boolean;
    };
    /**
     * @description QueryCommunityPoolResponse is the response type for the Query/CommunityPool
     * RPC method.
     */
    "cosmos.distribution.v1beta1.QueryCommunityPoolResponse": {
      /** @description pool defines community pool's coins. */
      pool?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /**
     * @description QueryDelegationRewardsResponse is the response type for the
     * Query/DelegationRewards RPC method.
     */
    "cosmos.distribution.v1beta1.QueryDelegationRewardsResponse": {
      /** @description rewards defines the rewards accrued by a delegation. */
      rewards?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /**
     * @description QueryDelegationTotalRewardsResponse is the response type for the
     * Query/DelegationTotalRewards RPC method.
     */
    "cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse": {
      /** @description rewards defines all the rewards accrued by a delegator. */
      rewards?: {
        validator_address?: string;
        reward?: {
          denom?: string;
          amount?: string;
        }[];
      }[];
      /** @description total defines the sum of all the rewards. */
      total?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /**
     * @description QueryDelegatorValidatorsResponse is the response type for the
     * Query/DelegatorValidators RPC method.
     */
    "cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse": {
      /** @description validators defines the validators a delegator is delegating for. */
      validators?: string[];
    };
    /**
     * @description QueryDelegatorWithdrawAddressResponse is the response type for the
     * Query/DelegatorWithdrawAddress RPC method.
     */
    "cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse": {
      /** @description withdraw_address defines the delegator address to query for. */
      withdraw_address?: string;
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.distribution.v1beta1.QueryParamsResponse": {
      /** @description params defines the parameters of the module. */
      params?: {
        community_tax?: string;
        /**
         * @description Deprecated: The base_proposer_reward field is deprecated and is no longer used
         * in the x/distribution module's reward mechanism.
         */
        base_proposer_reward?: string;
        /**
         * @description Deprecated: The bonus_proposer_reward field is deprecated and is no longer used
         * in the x/distribution module's reward mechanism.
         */
        bonus_proposer_reward?: string;
        withdraw_addr_enabled?: boolean;
      };
    };
    /**
     * QueryValidatorCommissionResponse is the response type for the
     * Query/ValidatorCommission RPC method
     */
    "cosmos.distribution.v1beta1.QueryValidatorCommissionResponse": {
      /** @description commission defines the commission the validator received. */
      commission?: {
        commission?: {
          denom?: string;
          amount?: string;
        }[];
      };
    };
    /** @description QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method. */
    "cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse": {
      /** @description operator_address defines the validator operator address. */
      operator_address?: string;
      /** @description self_bond_rewards defines the self delegations rewards. */
      self_bond_rewards?: {
        denom?: string;
        amount?: string;
      }[];
      /** @description commission defines the commission the validator received. */
      commission?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /**
     * @description QueryValidatorOutstandingRewardsResponse is the response type for the
     * Query/ValidatorOutstandingRewards RPC method.
     */
    "cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse": {
      /**
       * @description ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
       * for a validator inexpensive to track, allows simple sanity checks.
       */
      rewards?: {
        rewards?: {
          denom?: string;
          amount?: string;
        }[];
      };
    };
    /**
     * @description QueryValidatorSlashesResponse is the response type for the
     * Query/ValidatorSlashes RPC method.
     */
    "cosmos.distribution.v1beta1.QueryValidatorSlashesResponse": {
      /** @description slashes defines the slashes the validator received. */
      slashes?: {
        /** Format: uint64 */
        validator_period?: string;
        fraction?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description ValidatorAccumulatedCommission represents accumulated commission
     * for a validator kept as a running counter, can be withdrawn at any time.
     */
    "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission": {
      commission?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /**
     * @description ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
     * for a validator inexpensive to track, allows simple sanity checks.
     */
    "cosmos.distribution.v1beta1.ValidatorOutstandingRewards": {
      rewards?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /**
     * @description ValidatorSlashEvent represents a validator slash event.
     * Height is implicit within the store key.
     * This is needed to calculate appropriate amount of staking tokens
     * for delegations which are withdrawn after a slash has occurred.
     */
    "cosmos.distribution.v1beta1.ValidatorSlashEvent": {
      /** Format: uint64 */
      validator_period?: string;
      fraction?: string;
    };
    /** Grant is stored in the KVStore to record a grant with full context */
    "cosmos.feegrant.v1beta1.Grant": {
      /** @description granter is the address of the user granting an allowance of their funds. */
      granter?: string;
      /** @description grantee is the address of the user being granted an allowance of another user's funds. */
      grantee?: string;
      /** @description allowance can be any of basic, periodic, allowed fee allowance. */
      allowance?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /** @description QueryAllowanceResponse is the response type for the Query/Allowance RPC method. */
    "cosmos.feegrant.v1beta1.QueryAllowanceResponse": {
      /**
       * Grant is stored in the KVStore to record a grant with full context
       * @description allowance is a allowance granted for grantee by granter.
       */
      allowance?: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter?: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee?: string;
        /** @description allowance can be any of basic, periodic, allowed fee allowance. */
        allowance?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      };
    };
    /**
     * @description QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse": {
      /** @description allowances that have been issued by the granter. */
      allowances?: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter?: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee?: string;
        /** @description allowance can be any of basic, periodic, allowed fee allowance. */
        allowance?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryAllowancesResponse is the response type for the Query/Allowances RPC method. */
    "cosmos.feegrant.v1beta1.QueryAllowancesResponse": {
      /** @description allowances are allowance's granted for grantee by granter. */
      allowances?: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter?: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee?: string;
        /** @description allowance can be any of basic, periodic, allowed fee allowance. */
        allowance?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
     * method.
     */
    "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
      /** @description evidence returns all evidences. */
      evidence?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryEvidenceResponse is the response type for the Query/Evidence RPC method. */
    "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      evidence?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
    };
    /**
     * @description Deposit defines an amount deposited by an account address to an active
     * proposal.
     */
    "cosmos.gov.v1beta1.Deposit": {
      /**
       * Format: uint64
       * @description proposal_id defines the unique id of the proposal.
       */
      proposal_id?: string;
      /** @description depositor defines the deposit addresses from the proposals. */
      depositor?: string;
      /** @description amount to be deposited by depositor. */
      amount?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description DepositParams defines the params for deposits on governance proposals. */
    "cosmos.gov.v1beta1.DepositParams": {
      /** @description Minimum deposit for a proposal to enter voting period. */
      min_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
       * months.
       */
      max_deposit_period?: string;
    };
    /** @description Proposal defines the core field members of a governance proposal. */
    "cosmos.gov.v1beta1.Proposal": {
      /**
       * Format: uint64
       * @description proposal_id defines the unique id of the proposal.
       */
      proposal_id?: string;
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      content?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * @description status defines the proposal status.
       * @default PROPOSAL_STATUS_UNSPECIFIED
       * @enum {string}
       */
      status?:
        | "PROPOSAL_STATUS_UNSPECIFIED"
        | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
        | "PROPOSAL_STATUS_VOTING_PERIOD"
        | "PROPOSAL_STATUS_PASSED"
        | "PROPOSAL_STATUS_REJECTED"
        | "PROPOSAL_STATUS_FAILED";
      /**
       * @description final_tally_result is the final tally result of the proposal. When
       * querying a proposal via gRPC, this field is not populated until the
       * proposal's voting period has ended.
       */
      final_tally_result?: {
        /** @description yes is the number of yes votes on a proposal. */
        yes?: string;
        /** @description abstain is the number of abstain votes on a proposal. */
        abstain?: string;
        /** @description no is the number of no votes on a proposal. */
        no?: string;
        /** @description no_with_veto is the number of no with veto votes on a proposal. */
        no_with_veto?: string;
      };
      /**
       * Format: date-time
       * @description submit_time is the time of proposal submission.
       */
      submit_time?: string;
      /**
       * Format: date-time
       * @description deposit_end_time is the end time for deposition.
       */
      deposit_end_time?: string;
      /** @description total_deposit is the total deposit on the proposal. */
      total_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * Format: date-time
       * @description voting_start_time is the starting time to vote on a proposal.
       */
      voting_start_time?: string;
      /**
       * Format: date-time
       * @description voting_end_time is the end time of voting on a proposal.
       */
      voting_end_time?: string;
    };
    /**
     * @description ProposalStatus enumerates the valid statuses of a proposal.
     *
     *  - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
     *  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
     * period.
     *  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
     * period.
     *  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
     * passed.
     *  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
     * been rejected.
     *  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
     * failed.
     * @default PROPOSAL_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.gov.v1beta1.ProposalStatus":
      | "PROPOSAL_STATUS_UNSPECIFIED"
      | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
      | "PROPOSAL_STATUS_VOTING_PERIOD"
      | "PROPOSAL_STATUS_PASSED"
      | "PROPOSAL_STATUS_REJECTED"
      | "PROPOSAL_STATUS_FAILED";
    /** @description QueryDepositResponse is the response type for the Query/Deposit RPC method. */
    "cosmos.gov.v1beta1.QueryDepositResponse": {
      /**
       * @description Deposit defines an amount deposited by an account address to an active
       * proposal.
       */
      deposit?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /** @description amount to be deposited by depositor. */
        amount?: {
          denom?: string;
          amount?: string;
        }[];
      };
    };
    /** @description QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
    "cosmos.gov.v1beta1.QueryDepositsResponse": {
      /** @description deposits defines the requested deposits. */
      deposits?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /** @description amount to be deposited by depositor. */
        amount?: {
          denom?: string;
          amount?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.gov.v1beta1.QueryParamsResponse": {
      /** @description voting_params defines the parameters related to voting. */
      voting_params?: {
        /** @description Duration of the voting period. */
        voting_period?: string;
      };
      /** @description deposit_params defines the parameters related to deposit. */
      deposit_params?: {
        /** @description Minimum deposit for a proposal to enter voting period. */
        min_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
         * months.
         */
        max_deposit_period?: string;
      };
      /** @description tally_params defines the parameters related to tally. */
      tally_params?: {
        /**
         * Format: byte
         * @description Minimum percentage of total stake needed to vote for a result to be
         * considered valid.
         */
        quorum?: string;
        /**
         * Format: byte
         * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
         */
        threshold?: string;
        /**
         * Format: byte
         * @description Minimum value of Veto votes to Total votes ratio for proposal to be
         * vetoed. Default value: 1/3.
         */
        veto_threshold?: string;
      };
    };
    /** @description QueryProposalResponse is the response type for the Query/Proposal RPC method. */
    "cosmos.gov.v1beta1.QueryProposalResponse": {
      /** @description Proposal defines the core field members of a governance proposal. */
      proposal?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        content?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * @description status defines the proposal status.
         * @default PROPOSAL_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /**
         * @description final_tally_result is the final tally result of the proposal. When
         * querying a proposal via gRPC, this field is not populated until the
         * proposal's voting period has ended.
         */
        final_tally_result?: {
          /** @description yes is the number of yes votes on a proposal. */
          yes?: string;
          /** @description abstain is the number of abstain votes on a proposal. */
          abstain?: string;
          /** @description no is the number of no votes on a proposal. */
          no?: string;
          /** @description no_with_veto is the number of no with veto votes on a proposal. */
          no_with_veto?: string;
        };
        /**
         * Format: date-time
         * @description submit_time is the time of proposal submission.
         */
        submit_time?: string;
        /**
         * Format: date-time
         * @description deposit_end_time is the end time for deposition.
         */
        deposit_end_time?: string;
        /** @description total_deposit is the total deposit on the proposal. */
        total_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * Format: date-time
         * @description voting_start_time is the starting time to vote on a proposal.
         */
        voting_start_time?: string;
        /**
         * Format: date-time
         * @description voting_end_time is the end time of voting on a proposal.
         */
        voting_end_time?: string;
      };
    };
    /**
     * @description QueryProposalsResponse is the response type for the Query/Proposals RPC
     * method.
     */
    "cosmos.gov.v1beta1.QueryProposalsResponse": {
      /** @description proposals defines all the requested governance proposals. */
      proposals?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        content?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * @description status defines the proposal status.
         * @default PROPOSAL_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /**
         * @description final_tally_result is the final tally result of the proposal. When
         * querying a proposal via gRPC, this field is not populated until the
         * proposal's voting period has ended.
         */
        final_tally_result?: {
          /** @description yes is the number of yes votes on a proposal. */
          yes?: string;
          /** @description abstain is the number of abstain votes on a proposal. */
          abstain?: string;
          /** @description no is the number of no votes on a proposal. */
          no?: string;
          /** @description no_with_veto is the number of no with veto votes on a proposal. */
          no_with_veto?: string;
        };
        /**
         * Format: date-time
         * @description submit_time is the time of proposal submission.
         */
        submit_time?: string;
        /**
         * Format: date-time
         * @description deposit_end_time is the end time for deposition.
         */
        deposit_end_time?: string;
        /** @description total_deposit is the total deposit on the proposal. */
        total_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * Format: date-time
         * @description voting_start_time is the starting time to vote on a proposal.
         */
        voting_start_time?: string;
        /**
         * Format: date-time
         * @description voting_end_time is the end time of voting on a proposal.
         */
        voting_end_time?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
    "cosmos.gov.v1beta1.QueryTallyResultResponse": {
      /** @description tally defines the requested tally. */
      tally?: {
        /** @description yes is the number of yes votes on a proposal. */
        yes?: string;
        /** @description abstain is the number of abstain votes on a proposal. */
        abstain?: string;
        /** @description no is the number of no votes on a proposal. */
        no?: string;
        /** @description no_with_veto is the number of no with veto votes on a proposal. */
        no_with_veto?: string;
      };
    };
    /** @description QueryVoteResponse is the response type for the Query/Vote RPC method. */
    "cosmos.gov.v1beta1.QueryVoteResponse": {
      /**
       * @description Vote defines a vote on a governance proposal.
       * A Vote consists of a proposal ID, the voter, and the vote option.
       */
      vote?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description voter is the voter address of the proposal. */
        voter?: string;
        /**
         * @description Deprecated: Prefer to use `options` instead. This field is set in queries
         * if and only if `len(options) == 1` and that option has weight 1. In all
         * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
         * @default VOTE_OPTION_UNSPECIFIED
         * @enum {string}
         */
        option?:
          | "VOTE_OPTION_UNSPECIFIED"
          | "VOTE_OPTION_YES"
          | "VOTE_OPTION_ABSTAIN"
          | "VOTE_OPTION_NO"
          | "VOTE_OPTION_NO_WITH_VETO";
        /**
         * @description options is the weighted vote options.
         *
         * Since: cosmos-sdk 0.43
         */
        options?: {
          /**
           * @description option defines the valid vote options, it must not contain duplicate vote options.
           * @default VOTE_OPTION_UNSPECIFIED
           * @enum {string}
           */
          option?:
            | "VOTE_OPTION_UNSPECIFIED"
            | "VOTE_OPTION_YES"
            | "VOTE_OPTION_ABSTAIN"
            | "VOTE_OPTION_NO"
            | "VOTE_OPTION_NO_WITH_VETO";
          /** @description weight is the vote weight associated with the vote option. */
          weight?: string;
        }[];
      };
    };
    /** @description QueryVotesResponse is the response type for the Query/Votes RPC method. */
    "cosmos.gov.v1beta1.QueryVotesResponse": {
      /** @description votes defines the queried votes. */
      votes?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description voter is the voter address of the proposal. */
        voter?: string;
        /**
         * @description Deprecated: Prefer to use `options` instead. This field is set in queries
         * if and only if `len(options) == 1` and that option has weight 1. In all
         * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
         * @default VOTE_OPTION_UNSPECIFIED
         * @enum {string}
         */
        option?:
          | "VOTE_OPTION_UNSPECIFIED"
          | "VOTE_OPTION_YES"
          | "VOTE_OPTION_ABSTAIN"
          | "VOTE_OPTION_NO"
          | "VOTE_OPTION_NO_WITH_VETO";
        /**
         * @description options is the weighted vote options.
         *
         * Since: cosmos-sdk 0.43
         */
        options?: {
          /**
           * @description option defines the valid vote options, it must not contain duplicate vote options.
           * @default VOTE_OPTION_UNSPECIFIED
           * @enum {string}
           */
          option?:
            | "VOTE_OPTION_UNSPECIFIED"
            | "VOTE_OPTION_YES"
            | "VOTE_OPTION_ABSTAIN"
            | "VOTE_OPTION_NO"
            | "VOTE_OPTION_NO_WITH_VETO";
          /** @description weight is the vote weight associated with the vote option. */
          weight?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description TallyParams defines the params for tallying votes on governance proposals. */
    "cosmos.gov.v1beta1.TallyParams": {
      /**
       * Format: byte
       * @description Minimum percentage of total stake needed to vote for a result to be
       * considered valid.
       */
      quorum?: string;
      /**
       * Format: byte
       * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
       */
      threshold?: string;
      /**
       * Format: byte
       * @description Minimum value of Veto votes to Total votes ratio for proposal to be
       * vetoed. Default value: 1/3.
       */
      veto_threshold?: string;
    };
    /** @description TallyResult defines a standard tally for a governance proposal. */
    "cosmos.gov.v1beta1.TallyResult": {
      /** @description yes is the number of yes votes on a proposal. */
      yes?: string;
      /** @description abstain is the number of abstain votes on a proposal. */
      abstain?: string;
      /** @description no is the number of no votes on a proposal. */
      no?: string;
      /** @description no_with_veto is the number of no with veto votes on a proposal. */
      no_with_veto?: string;
    };
    /**
     * @description Vote defines a vote on a governance proposal.
     * A Vote consists of a proposal ID, the voter, and the vote option.
     */
    "cosmos.gov.v1beta1.Vote": {
      /**
       * Format: uint64
       * @description proposal_id defines the unique id of the proposal.
       */
      proposal_id?: string;
      /** @description voter is the voter address of the proposal. */
      voter?: string;
      /**
       * @description Deprecated: Prefer to use `options` instead. This field is set in queries
       * if and only if `len(options) == 1` and that option has weight 1. In all
       * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
       * @default VOTE_OPTION_UNSPECIFIED
       * @enum {string}
       */
      option?:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /**
       * @description options is the weighted vote options.
       *
       * Since: cosmos-sdk 0.43
       */
      options?: {
        /**
         * @description option defines the valid vote options, it must not contain duplicate vote options.
         * @default VOTE_OPTION_UNSPECIFIED
         * @enum {string}
         */
        option?:
          | "VOTE_OPTION_UNSPECIFIED"
          | "VOTE_OPTION_YES"
          | "VOTE_OPTION_ABSTAIN"
          | "VOTE_OPTION_NO"
          | "VOTE_OPTION_NO_WITH_VETO";
        /** @description weight is the vote weight associated with the vote option. */
        weight?: string;
      }[];
    };
    /**
     * @description VoteOption enumerates the valid vote options for a given governance proposal.
     *
     *  - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
     *  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
     *  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
     *  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
     *  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @default VOTE_OPTION_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.gov.v1beta1.VoteOption":
      | "VOTE_OPTION_UNSPECIFIED"
      | "VOTE_OPTION_YES"
      | "VOTE_OPTION_ABSTAIN"
      | "VOTE_OPTION_NO"
      | "VOTE_OPTION_NO_WITH_VETO";
    /** @description VotingParams defines the params for voting on governance proposals. */
    "cosmos.gov.v1beta1.VotingParams": {
      /** @description Duration of the voting period. */
      voting_period?: string;
    };
    /**
     * @description WeightedVoteOption defines a unit of vote for vote split.
     *
     * Since: cosmos-sdk 0.43
     */
    "cosmos.gov.v1beta1.WeightedVoteOption": {
      /**
       * @description option defines the valid vote options, it must not contain duplicate vote options.
       * @default VOTE_OPTION_UNSPECIFIED
       * @enum {string}
       */
      option?:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /** @description weight is the vote weight associated with the vote option. */
      weight?: string;
    };
    /**
     * @description Deposit defines an amount deposited by an account address to an active
     * proposal.
     */
    "cosmos.gov.v1.Deposit": {
      /**
       * Format: uint64
       * @description proposal_id defines the unique id of the proposal.
       */
      proposal_id?: string;
      /** @description depositor defines the deposit addresses from the proposals. */
      depositor?: string;
      /** @description amount to be deposited by depositor. */
      amount?: {
        denom?: string;
        amount?: string;
      }[];
    };
    /** @description DepositParams defines the params for deposits on governance proposals. */
    "cosmos.gov.v1.DepositParams": {
      /** @description Minimum deposit for a proposal to enter voting period. */
      min_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
       * months.
       */
      max_deposit_period?: string;
    };
    /**
     * @description Params defines the parameters for the x/gov module.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.gov.v1.Params": {
      /** @description Minimum deposit for a proposal to enter voting period. */
      min_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
       * months.
       */
      max_deposit_period?: string;
      /** @description Duration of the voting period. */
      voting_period?: string;
      /**
       * @description Minimum percentage of total stake needed to vote for a result to be
       *  considered valid.
       */
      quorum?: string;
      /** @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
      threshold?: string;
      /**
       * @description Minimum value of Veto votes to Total votes ratio for proposal to be
       *  vetoed. Default value: 1/3.
       */
      veto_threshold?: string;
      /** @description The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
      min_initial_deposit_ratio?: string;
      /**
       * @description The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.
       *
       * Since: cosmos-sdk 0.50
       */
      proposal_cancel_ratio?: string;
      /**
       * @description The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.
       * If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.
       *
       * Since: cosmos-sdk 0.50
       */
      proposal_cancel_dest?: string;
      /**
       * @description Duration of the voting period of an expedited proposal.
       *
       * Since: cosmos-sdk 0.50
       */
      expedited_voting_period?: string;
      /**
       * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.
       *
       * Since: cosmos-sdk 0.50
       */
      expedited_threshold?: string;
      /** @description Minimum expedited deposit for a proposal to enter voting period. */
      expedited_min_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /** burn deposits if a proposal does not meet quorum */
      burn_vote_quorum?: boolean;
      /** burn deposits if the proposal does not enter voting period */
      burn_proposal_deposit_prevote?: boolean;
      /** burn deposits if quorum with vote type no_veto is met */
      burn_vote_veto?: boolean;
    };
    /** @description Proposal defines the core field members of a governance proposal. */
    "cosmos.gov.v1.Proposal": {
      /**
       * Format: uint64
       * @description id defines the unique id of the proposal.
       */
      id?: string;
      /** @description messages are the arbitrary messages to be executed if the proposal passes. */
      messages?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /**
       * @description status defines the proposal status.
       * @default PROPOSAL_STATUS_UNSPECIFIED
       * @enum {string}
       */
      status?:
        | "PROPOSAL_STATUS_UNSPECIFIED"
        | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
        | "PROPOSAL_STATUS_VOTING_PERIOD"
        | "PROPOSAL_STATUS_PASSED"
        | "PROPOSAL_STATUS_REJECTED"
        | "PROPOSAL_STATUS_FAILED";
      /**
       * @description final_tally_result is the final tally result of the proposal. When
       * querying a proposal via gRPC, this field is not populated until the
       * proposal's voting period has ended.
       */
      final_tally_result?: {
        /** @description yes_count is the number of yes votes on a proposal. */
        yes_count?: string;
        /** @description abstain_count is the number of abstain votes on a proposal. */
        abstain_count?: string;
        /** @description no_count is the number of no votes on a proposal. */
        no_count?: string;
        /** @description no_with_veto_count is the number of no with veto votes on a proposal. */
        no_with_veto_count?: string;
      };
      /**
       * Format: date-time
       * @description submit_time is the time of proposal submission.
       */
      submit_time?: string;
      /**
       * Format: date-time
       * @description deposit_end_time is the end time for deposition.
       */
      deposit_end_time?: string;
      /** @description total_deposit is the total deposit on the proposal. */
      total_deposit?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * Format: date-time
       * @description voting_start_time is the starting time to vote on a proposal.
       */
      voting_start_time?: string;
      /**
       * Format: date-time
       * @description voting_end_time is the end time of voting on a proposal.
       */
      voting_end_time?: string;
      /**
       * metadata is any arbitrary metadata attached to the proposal.
       * the recommended format of the metadata is to be found here:
       * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
       */
      metadata?: string;
      /**
       * title is the title of the proposal
       * @description Since: cosmos-sdk 0.47
       */
      title?: string;
      /**
       * summary is a short summary of the proposal
       * @description Since: cosmos-sdk 0.47
       */
      summary?: string;
      /**
       * proposer is the address of the proposal sumbitter
       * @description Since: cosmos-sdk 0.47
       */
      proposer?: string;
      /**
       * expedited defines if the proposal is expedited
       * @description Since: cosmos-sdk 0.50
       */
      expedited?: boolean;
      /**
       * failed_reason defines the reason why the proposal failed
       * @description Since: cosmos-sdk 0.50
       */
      failed_reason?: string;
    };
    /**
     * @description ProposalStatus enumerates the valid statuses of a proposal.
     *
     *  - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
     *  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
     * period.
     *  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
     * period.
     *  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
     * passed.
     *  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
     * been rejected.
     *  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
     * failed.
     * @default PROPOSAL_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.gov.v1.ProposalStatus":
      | "PROPOSAL_STATUS_UNSPECIFIED"
      | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
      | "PROPOSAL_STATUS_VOTING_PERIOD"
      | "PROPOSAL_STATUS_PASSED"
      | "PROPOSAL_STATUS_REJECTED"
      | "PROPOSAL_STATUS_FAILED";
    /** QueryConstitutionResponse is the response type for the Query/Constitution RPC method */
    "cosmos.gov.v1.QueryConstitutionResponse": {
      constitution?: string;
    };
    /** @description QueryDepositResponse is the response type for the Query/Deposit RPC method. */
    "cosmos.gov.v1.QueryDepositResponse": {
      /**
       * @description Deposit defines an amount deposited by an account address to an active
       * proposal.
       */
      deposit?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /** @description amount to be deposited by depositor. */
        amount?: {
          denom?: string;
          amount?: string;
        }[];
      };
    };
    /** @description QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
    "cosmos.gov.v1.QueryDepositsResponse": {
      /** @description deposits defines the requested deposits. */
      deposits?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /** @description amount to be deposited by depositor. */
        amount?: {
          denom?: string;
          amount?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryParamsResponse is the response type for the Query/Params RPC method. */
    "cosmos.gov.v1.QueryParamsResponse": {
      /**
       * @description Deprecated: Prefer to use `params` instead.
       * voting_params defines the parameters related to voting.
       */
      voting_params?: {
        /** @description Duration of the voting period. */
        voting_period?: string;
      };
      /**
       * @description Deprecated: Prefer to use `params` instead.
       * deposit_params defines the parameters related to deposit.
       */
      deposit_params?: {
        /** @description Minimum deposit for a proposal to enter voting period. */
        min_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
         * months.
         */
        max_deposit_period?: string;
      };
      /**
       * @description Deprecated: Prefer to use `params` instead.
       * tally_params defines the parameters related to tally.
       */
      tally_params?: {
        /**
         * @description Minimum percentage of total stake needed to vote for a result to be
         * considered valid.
         */
        quorum?: string;
        /** @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
        threshold?: string;
        /**
         * @description Minimum value of Veto votes to Total votes ratio for proposal to be
         * vetoed. Default value: 1/3.
         */
        veto_threshold?: string;
      };
      /**
       * @description params defines all the paramaters of x/gov module.
       *
       * Since: cosmos-sdk 0.47
       */
      params?: {
        /** @description Minimum deposit for a proposal to enter voting period. */
        min_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
         * months.
         */
        max_deposit_period?: string;
        /** @description Duration of the voting period. */
        voting_period?: string;
        /**
         * @description Minimum percentage of total stake needed to vote for a result to be
         *  considered valid.
         */
        quorum?: string;
        /** @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
        threshold?: string;
        /**
         * @description Minimum value of Veto votes to Total votes ratio for proposal to be
         *  vetoed. Default value: 1/3.
         */
        veto_threshold?: string;
        /** @description The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
        min_initial_deposit_ratio?: string;
        /**
         * @description The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.
         *
         * Since: cosmos-sdk 0.50
         */
        proposal_cancel_ratio?: string;
        /**
         * @description The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.
         * If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.
         *
         * Since: cosmos-sdk 0.50
         */
        proposal_cancel_dest?: string;
        /**
         * @description Duration of the voting period of an expedited proposal.
         *
         * Since: cosmos-sdk 0.50
         */
        expedited_voting_period?: string;
        /**
         * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.
         *
         * Since: cosmos-sdk 0.50
         */
        expedited_threshold?: string;
        /** @description Minimum expedited deposit for a proposal to enter voting period. */
        expedited_min_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /** burn deposits if a proposal does not meet quorum */
        burn_vote_quorum?: boolean;
        /** burn deposits if the proposal does not enter voting period */
        burn_proposal_deposit_prevote?: boolean;
        /** burn deposits if quorum with vote type no_veto is met */
        burn_vote_veto?: boolean;
      };
    };
    /** @description QueryProposalResponse is the response type for the Query/Proposal RPC method. */
    "cosmos.gov.v1.QueryProposalResponse": {
      /** @description Proposal defines the core field members of a governance proposal. */
      proposal?: {
        /**
         * Format: uint64
         * @description id defines the unique id of the proposal.
         */
        id?: string;
        /** @description messages are the arbitrary messages to be executed if the proposal passes. */
        messages?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
        /**
         * @description status defines the proposal status.
         * @default PROPOSAL_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /**
         * @description final_tally_result is the final tally result of the proposal. When
         * querying a proposal via gRPC, this field is not populated until the
         * proposal's voting period has ended.
         */
        final_tally_result?: {
          /** @description yes_count is the number of yes votes on a proposal. */
          yes_count?: string;
          /** @description abstain_count is the number of abstain votes on a proposal. */
          abstain_count?: string;
          /** @description no_count is the number of no votes on a proposal. */
          no_count?: string;
          /** @description no_with_veto_count is the number of no with veto votes on a proposal. */
          no_with_veto_count?: string;
        };
        /**
         * Format: date-time
         * @description submit_time is the time of proposal submission.
         */
        submit_time?: string;
        /**
         * Format: date-time
         * @description deposit_end_time is the end time for deposition.
         */
        deposit_end_time?: string;
        /** @description total_deposit is the total deposit on the proposal. */
        total_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * Format: date-time
         * @description voting_start_time is the starting time to vote on a proposal.
         */
        voting_start_time?: string;
        /**
         * Format: date-time
         * @description voting_end_time is the end time of voting on a proposal.
         */
        voting_end_time?: string;
        /**
         * metadata is any arbitrary metadata attached to the proposal.
         * the recommended format of the metadata is to be found here:
         * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
         */
        metadata?: string;
        /**
         * title is the title of the proposal
         * @description Since: cosmos-sdk 0.47
         */
        title?: string;
        /**
         * summary is a short summary of the proposal
         * @description Since: cosmos-sdk 0.47
         */
        summary?: string;
        /**
         * proposer is the address of the proposal sumbitter
         * @description Since: cosmos-sdk 0.47
         */
        proposer?: string;
        /**
         * expedited defines if the proposal is expedited
         * @description Since: cosmos-sdk 0.50
         */
        expedited?: boolean;
        /**
         * failed_reason defines the reason why the proposal failed
         * @description Since: cosmos-sdk 0.50
         */
        failed_reason?: string;
      };
    };
    /**
     * @description QueryProposalsResponse is the response type for the Query/Proposals RPC
     * method.
     */
    "cosmos.gov.v1.QueryProposalsResponse": {
      /** @description proposals defines all the requested governance proposals. */
      proposals?: {
        /**
         * Format: uint64
         * @description id defines the unique id of the proposal.
         */
        id?: string;
        /** @description messages are the arbitrary messages to be executed if the proposal passes. */
        messages?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
        /**
         * @description status defines the proposal status.
         * @default PROPOSAL_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /**
         * @description final_tally_result is the final tally result of the proposal. When
         * querying a proposal via gRPC, this field is not populated until the
         * proposal's voting period has ended.
         */
        final_tally_result?: {
          /** @description yes_count is the number of yes votes on a proposal. */
          yes_count?: string;
          /** @description abstain_count is the number of abstain votes on a proposal. */
          abstain_count?: string;
          /** @description no_count is the number of no votes on a proposal. */
          no_count?: string;
          /** @description no_with_veto_count is the number of no with veto votes on a proposal. */
          no_with_veto_count?: string;
        };
        /**
         * Format: date-time
         * @description submit_time is the time of proposal submission.
         */
        submit_time?: string;
        /**
         * Format: date-time
         * @description deposit_end_time is the end time for deposition.
         */
        deposit_end_time?: string;
        /** @description total_deposit is the total deposit on the proposal. */
        total_deposit?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * Format: date-time
         * @description voting_start_time is the starting time to vote on a proposal.
         */
        voting_start_time?: string;
        /**
         * Format: date-time
         * @description voting_end_time is the end time of voting on a proposal.
         */
        voting_end_time?: string;
        /**
         * metadata is any arbitrary metadata attached to the proposal.
         * the recommended format of the metadata is to be found here:
         * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
         */
        metadata?: string;
        /**
         * title is the title of the proposal
         * @description Since: cosmos-sdk 0.47
         */
        title?: string;
        /**
         * summary is a short summary of the proposal
         * @description Since: cosmos-sdk 0.47
         */
        summary?: string;
        /**
         * proposer is the address of the proposal sumbitter
         * @description Since: cosmos-sdk 0.47
         */
        proposer?: string;
        /**
         * expedited defines if the proposal is expedited
         * @description Since: cosmos-sdk 0.50
         */
        expedited?: boolean;
        /**
         * failed_reason defines the reason why the proposal failed
         * @description Since: cosmos-sdk 0.50
         */
        failed_reason?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
    "cosmos.gov.v1.QueryTallyResultResponse": {
      /** @description tally defines the requested tally. */
      tally?: {
        /** @description yes_count is the number of yes votes on a proposal. */
        yes_count?: string;
        /** @description abstain_count is the number of abstain votes on a proposal. */
        abstain_count?: string;
        /** @description no_count is the number of no votes on a proposal. */
        no_count?: string;
        /** @description no_with_veto_count is the number of no with veto votes on a proposal. */
        no_with_veto_count?: string;
      };
    };
    /** @description QueryVoteResponse is the response type for the Query/Vote RPC method. */
    "cosmos.gov.v1.QueryVoteResponse": {
      /**
       * @description Vote defines a vote on a governance proposal.
       * A Vote consists of a proposal ID, the voter, and the vote option.
       */
      vote?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description voter is the voter address of the proposal. */
        voter?: string;
        /** @description options is the weighted vote options. */
        options?: {
          /**
           * @description option defines the valid vote options, it must not contain duplicate vote options.
           * @default VOTE_OPTION_UNSPECIFIED
           * @enum {string}
           */
          option?:
            | "VOTE_OPTION_UNSPECIFIED"
            | "VOTE_OPTION_YES"
            | "VOTE_OPTION_ABSTAIN"
            | "VOTE_OPTION_NO"
            | "VOTE_OPTION_NO_WITH_VETO";
          /** @description weight is the vote weight associated with the vote option. */
          weight?: string;
        }[];
        /**
         * metadata is any arbitrary metadata attached to the vote.
         * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
         */
        metadata?: string;
      };
    };
    /** @description QueryVotesResponse is the response type for the Query/Votes RPC method. */
    "cosmos.gov.v1.QueryVotesResponse": {
      /** @description votes defines the queried votes. */
      votes?: {
        /**
         * Format: uint64
         * @description proposal_id defines the unique id of the proposal.
         */
        proposal_id?: string;
        /** @description voter is the voter address of the proposal. */
        voter?: string;
        /** @description options is the weighted vote options. */
        options?: {
          /**
           * @description option defines the valid vote options, it must not contain duplicate vote options.
           * @default VOTE_OPTION_UNSPECIFIED
           * @enum {string}
           */
          option?:
            | "VOTE_OPTION_UNSPECIFIED"
            | "VOTE_OPTION_YES"
            | "VOTE_OPTION_ABSTAIN"
            | "VOTE_OPTION_NO"
            | "VOTE_OPTION_NO_WITH_VETO";
          /** @description weight is the vote weight associated with the vote option. */
          weight?: string;
        }[];
        /**
         * metadata is any arbitrary metadata attached to the vote.
         * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
         */
        metadata?: string;
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description TallyParams defines the params for tallying votes on governance proposals. */
    "cosmos.gov.v1.TallyParams": {
      /**
       * @description Minimum percentage of total stake needed to vote for a result to be
       * considered valid.
       */
      quorum?: string;
      /** @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
      threshold?: string;
      /**
       * @description Minimum value of Veto votes to Total votes ratio for proposal to be
       * vetoed. Default value: 1/3.
       */
      veto_threshold?: string;
    };
    /** @description TallyResult defines a standard tally for a governance proposal. */
    "cosmos.gov.v1.TallyResult": {
      /** @description yes_count is the number of yes votes on a proposal. */
      yes_count?: string;
      /** @description abstain_count is the number of abstain votes on a proposal. */
      abstain_count?: string;
      /** @description no_count is the number of no votes on a proposal. */
      no_count?: string;
      /** @description no_with_veto_count is the number of no with veto votes on a proposal. */
      no_with_veto_count?: string;
    };
    /**
     * @description Vote defines a vote on a governance proposal.
     * A Vote consists of a proposal ID, the voter, and the vote option.
     */
    "cosmos.gov.v1.Vote": {
      /**
       * Format: uint64
       * @description proposal_id defines the unique id of the proposal.
       */
      proposal_id?: string;
      /** @description voter is the voter address of the proposal. */
      voter?: string;
      /** @description options is the weighted vote options. */
      options?: {
        /**
         * @description option defines the valid vote options, it must not contain duplicate vote options.
         * @default VOTE_OPTION_UNSPECIFIED
         * @enum {string}
         */
        option?:
          | "VOTE_OPTION_UNSPECIFIED"
          | "VOTE_OPTION_YES"
          | "VOTE_OPTION_ABSTAIN"
          | "VOTE_OPTION_NO"
          | "VOTE_OPTION_NO_WITH_VETO";
        /** @description weight is the vote weight associated with the vote option. */
        weight?: string;
      }[];
      /**
       * metadata is any arbitrary metadata attached to the vote.
       * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
       */
      metadata?: string;
    };
    /**
     * @description VoteOption enumerates the valid vote options for a given governance proposal.
     *
     *  - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
     *  - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
     *  - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
     *  - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
     *  - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
     * @default VOTE_OPTION_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.gov.v1.VoteOption":
      | "VOTE_OPTION_UNSPECIFIED"
      | "VOTE_OPTION_YES"
      | "VOTE_OPTION_ABSTAIN"
      | "VOTE_OPTION_NO"
      | "VOTE_OPTION_NO_WITH_VETO";
    /** @description VotingParams defines the params for voting on governance proposals. */
    "cosmos.gov.v1.VotingParams": {
      /** @description Duration of the voting period. */
      voting_period?: string;
    };
    /** @description WeightedVoteOption defines a unit of vote for vote split. */
    "cosmos.gov.v1.WeightedVoteOption": {
      /**
       * @description option defines the valid vote options, it must not contain duplicate vote options.
       * @default VOTE_OPTION_UNSPECIFIED
       * @enum {string}
       */
      option?:
        | "VOTE_OPTION_UNSPECIFIED"
        | "VOTE_OPTION_YES"
        | "VOTE_OPTION_ABSTAIN"
        | "VOTE_OPTION_NO"
        | "VOTE_OPTION_NO_WITH_VETO";
      /** @description weight is the vote weight associated with the vote option. */
      weight?: string;
    };
    /** @description Params represents the parameters used for by the slashing module. */
    "cosmos.slashing.v1beta1.Params": {
      /** Format: int64 */
      signed_blocks_window?: string;
      /** Format: byte */
      min_signed_per_window?: string;
      downtime_jail_duration?: string;
      /** Format: byte */
      slash_fraction_double_sign?: string;
      /** Format: byte */
      slash_fraction_downtime?: string;
    };
    /** QueryParamsResponse is the response type for the Query/Params RPC method */
    "cosmos.slashing.v1beta1.QueryParamsResponse": {
      /** @description Params represents the parameters used for by the slashing module. */
      params?: {
        /** Format: int64 */
        signed_blocks_window?: string;
        /** Format: byte */
        min_signed_per_window?: string;
        downtime_jail_duration?: string;
        /** Format: byte */
        slash_fraction_double_sign?: string;
        /** Format: byte */
        slash_fraction_downtime?: string;
      };
    };
    /**
     * QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
     * method
     */
    "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
      /**
       * val_signing_info is the signing info of requested val cons address
       * @description ValidatorSigningInfo defines a validator's signing info for monitoring their
       * liveness activity.
       */
      val_signing_info?: {
        address?: string;
        /**
         * Height at which validator was first a candidate OR was un-jailed
         * Format: int64
         */
        start_height?: string;
        /**
         * Format: int64
         * @description Index which is incremented every time a validator is bonded in a block and
         * _may_ have signed a pre-commit or not. This in conjunction with the
         * signed_blocks_window param determines the index in the missed block bitmap.
         */
        index_offset?: string;
        /**
         * Format: date-time
         * @description Timestamp until which the validator is jailed due to liveness downtime.
         */
        jailed_until?: string;
        /**
         * @description Whether or not a validator has been tombstoned (killed out of validator
         * set). It is set once the validator commits an equivocation or for any other
         * configured misbehavior.
         */
        tombstoned?: boolean;
        /**
         * Format: int64
         * @description A counter of missed (unsigned) blocks. It is used to avoid unnecessary
         * reads in the missed block bitmap.
         */
        missed_blocks_counter?: string;
      };
    };
    /**
     * QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
     * method
     */
    "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
      /** info is the signing info of all validators */
      info?: {
        address?: string;
        /**
         * Height at which validator was first a candidate OR was un-jailed
         * Format: int64
         */
        start_height?: string;
        /**
         * Format: int64
         * @description Index which is incremented every time a validator is bonded in a block and
         * _may_ have signed a pre-commit or not. This in conjunction with the
         * signed_blocks_window param determines the index in the missed block bitmap.
         */
        index_offset?: string;
        /**
         * Format: date-time
         * @description Timestamp until which the validator is jailed due to liveness downtime.
         */
        jailed_until?: string;
        /**
         * @description Whether or not a validator has been tombstoned (killed out of validator
         * set). It is set once the validator commits an equivocation or for any other
         * configured misbehavior.
         */
        tombstoned?: boolean;
        /**
         * Format: int64
         * @description A counter of missed (unsigned) blocks. It is used to avoid unnecessary
         * reads in the missed block bitmap.
         */
        missed_blocks_counter?: string;
      }[];
      /**
       * @description PageResponse is to be embedded in gRPC response messages where the
       * corresponding request message has used PageRequest.
       *
       *  message SomeResponse {
       *          repeated Bar results = 1;
       *          PageResponse page = 2;
       *  }
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description ValidatorSigningInfo defines a validator's signing info for monitoring their
     * liveness activity.
     */
    "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
      address?: string;
      /**
       * Height at which validator was first a candidate OR was un-jailed
       * Format: int64
       */
      start_height?: string;
      /**
       * Format: int64
       * @description Index which is incremented every time a validator is bonded in a block and
       * _may_ have signed a pre-commit or not. This in conjunction with the
       * signed_blocks_window param determines the index in the missed block bitmap.
       */
      index_offset?: string;
      /**
       * Format: date-time
       * @description Timestamp until which the validator is jailed due to liveness downtime.
       */
      jailed_until?: string;
      /**
       * @description Whether or not a validator has been tombstoned (killed out of validator
       * set). It is set once the validator commits an equivocation or for any other
       * configured misbehavior.
       */
      tombstoned?: boolean;
      /**
       * Format: int64
       * @description A counter of missed (unsigned) blocks. It is used to avoid unnecessary
       * reads in the missed block bitmap.
       */
      missed_blocks_counter?: string;
    };
    /**
     * @description BondStatus is the status of a validator.
     *
     *  - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.
     *  - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.
     *  - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.
     *  - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.
     * @default BOND_STATUS_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.staking.v1beta1.BondStatus":
      | "BOND_STATUS_UNSPECIFIED"
      | "BOND_STATUS_UNBONDED"
      | "BOND_STATUS_UNBONDING"
      | "BOND_STATUS_BONDED";
    /** @description Commission defines commission parameters for a given validator. */
    "cosmos.staking.v1beta1.Commission": {
      /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
      commission_rates?: {
        /** @description rate is the commission rate charged to delegators, as a fraction. */
        rate?: string;
        /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
        max_rate?: string;
        /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
        max_change_rate?: string;
      };
      /**
       * Format: date-time
       * @description update_time is the last time the commission rate was changed.
       */
      update_time?: string;
    };
    /**
     * @description CommissionRates defines the initial commission rates to be used for creating
     * a validator.
     */
    "cosmos.staking.v1beta1.CommissionRates": {
      /** @description rate is the commission rate charged to delegators, as a fraction. */
      rate?: string;
      /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
      max_rate?: string;
      /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
      max_change_rate?: string;
    };
    /**
     * @description Delegation represents the bond with tokens held by an account. It is
     * owned by one delegator, and is associated with the voting power of one
     * validator.
     */
    "cosmos.staking.v1beta1.Delegation": {
      /** @description delegator_address is the encoded address of the delegator. */
      delegator_address?: string;
      /** @description validator_address is the encoded address of the validator. */
      validator_address?: string;
      /** @description shares define the delegation shares received. */
      shares?: string;
    };
    /**
     * @description DelegationResponse is equivalent to Delegation except that it contains a
     * balance in addition to shares which is more suitable for client responses.
     */
    "cosmos.staking.v1beta1.DelegationResponse": {
      /**
       * @description Delegation represents the bond with tokens held by an account. It is
       * owned by one delegator, and is associated with the voting power of one
       * validator.
       */
      delegation?: {
        /** @description delegator_address is the encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the encoded address of the validator. */
        validator_address?: string;
        /** @description shares define the delegation shares received. */
        shares?: string;
      };
      /**
       * @description Coin defines a token with a denomination and an amount.
       *
       * NOTE: The amount field is an Int which implements the custom method
       * signatures required by gogoproto.
       */
      balance?: {
        denom?: string;
        amount?: string;
      };
    };
    /** @description Description defines a validator description. */
    "cosmos.staking.v1beta1.Description": {
      /** @description moniker defines a human-readable name for the validator. */
      moniker?: string;
      /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
      identity?: string;
      /** @description website defines an optional website link. */
      website?: string;
      /** @description security_contact defines an optional email for security contact. */
      security_contact?: string;
      /** @description details define other optional details. */
      details?: string;
    };
    /**
     * @description HistoricalInfo contains header and validator information for a given block.
     * It is stored as part of staking module's state, which persists the `n` most
     * recent HistoricalInfo
     * (`n` is set by the staking module's `historical_entries` parameter).
     */
    "cosmos.staking.v1beta1.HistoricalInfo": {
      /** @description Header defines the structure of a block header. */
      header?: {
        /**
         * basic block info
         * @description Consensus captures the consensus rules for processing a block in the blockchain,
         * including all blockchain data structures and the rules of the application's
         * state transition machine.
         */
        version?: {
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        chain_id?: string;
        /** Format: int64 */
        height?: string;
        /** Format: date-time */
        time?: string;
        /** prev block info */
        last_block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * Format: byte
         */
        last_commit_hash?: string;
        /** Format: byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * Format: byte
         */
        validators_hash?: string;
        /** Format: byte */
        next_validators_hash?: string;
        /** Format: byte */
        consensus_hash?: string;
        /** Format: byte */
        app_hash?: string;
        /** Format: byte */
        last_results_hash?: string;
        /**
         * consensus info
         * Format: byte
         */
        evidence_hash?: string;
        /** Format: byte */
        proposer_address?: string;
      };
      valset?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        consensus_pubkey?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description jailed defined whether the validator has been jailed from bonded status or not. */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /**
         * @description min_self_delegation is the validator's self declared minimum self delegation.
         *
         * Since: cosmos-sdk 0.46
         */
        min_self_delegation?: string;
        /**
         * strictly positive if this validator's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
        /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
        unbonding_ids?: string[];
      }[];
    };
    /** @description Params defines the parameters for the x/staking module. */
    "cosmos.staking.v1beta1.Params": {
      /** @description unbonding_time is the time duration of unbonding. */
      unbonding_time?: string;
      /**
       * Format: int64
       * @description max_validators is the maximum number of validators.
       */
      max_validators?: number;
      /**
       * Format: int64
       * @description max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
       */
      max_entries?: number;
      /**
       * Format: int64
       * @description historical_entries is the number of historical entries to persist.
       */
      historical_entries?: number;
      /** @description bond_denom defines the bondable coin denomination. */
      bond_denom?: string;
      /** min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators */
      min_commission_rate?: string;
    };
    /**
     * @description Pool is used for tracking bonded and not-bonded token supply of the bond
     * denomination.
     */
    "cosmos.staking.v1beta1.Pool": {
      not_bonded_tokens?: string;
      bonded_tokens?: string;
    };
    /** @description QueryDelegationResponse is response type for the Query/Delegation RPC method. */
    "cosmos.staking.v1beta1.QueryDelegationResponse": {
      /**
       * @description DelegationResponse is equivalent to Delegation except that it contains a
       * balance in addition to shares which is more suitable for client responses.
       */
      delegation_response?: {
        /**
         * @description Delegation represents the bond with tokens held by an account. It is
         * owned by one delegator, and is associated with the voting power of one
         * validator.
         */
        delegation?: {
          /** @description delegator_address is the encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_address is the encoded address of the validator. */
          validator_address?: string;
          /** @description shares define the delegation shares received. */
          shares?: string;
        };
        /**
         * @description Coin defines a token with a denomination and an amount.
         *
         * NOTE: The amount field is an Int which implements the custom method
         * signatures required by gogoproto.
         */
        balance?: {
          denom?: string;
          amount?: string;
        };
      };
    };
    /**
     * @description QueryDelegatorDelegationsResponse is response type for the
     * Query/DelegatorDelegations RPC method.
     */
    "cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse": {
      /** @description delegation_responses defines all the delegations' info of a delegator. */
      delegation_responses?: {
        /**
         * @description Delegation represents the bond with tokens held by an account. It is
         * owned by one delegator, and is associated with the voting power of one
         * validator.
         */
        delegation?: {
          /** @description delegator_address is the encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_address is the encoded address of the validator. */
          validator_address?: string;
          /** @description shares define the delegation shares received. */
          shares?: string;
        };
        /**
         * @description Coin defines a token with a denomination and an amount.
         *
         * NOTE: The amount field is an Int which implements the custom method
         * signatures required by gogoproto.
         */
        balance?: {
          denom?: string;
          amount?: string;
        };
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryUnbondingDelegatorDelegationsResponse is response type for the
     * Query/UnbondingDelegatorDelegations RPC method.
     */
    "cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse": {
      unbonding_responses?: {
        /** @description delegator_address is the encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the encoded address of the validator. */
        validator_address?: string;
        /** @description entries are the unbonding delegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height is the height which the unbonding took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time is the unix time for unbonding completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
          initial_balance?: string;
          /** @description balance defines the tokens to receive at completion. */
          balance?: string;
          /**
           * Incrementing id that uniquely identifies this entry
           * Format: uint64
           */
          unbonding_id?: string;
          /**
           * Strictly positive if this entry's unbonding has been stopped by external modules
           * Format: int64
           */
          unbonding_on_hold_ref_count?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryDelegatorValidatorResponse response type for the
     * Query/DelegatorValidator RPC method.
     */
    "cosmos.staking.v1beta1.QueryDelegatorValidatorResponse": {
      /**
       * @description Validator defines a validator, together with the total amount of the
       * Validator's bond shares and their exchange rate to coins. Slashing results in
       * a decrease in the exchange rate, allowing correct calculation of future
       * undelegations without iterating over delegators. When coins are delegated to
       * this validator, the validator is credited with a delegation whose number of
       * bond shares is based on the amount of coins delegated divided by the current
       * exchange rate. Voting power can be calculated as total bonded shares
       * multiplied by exchange rate.
       */
      validator?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        consensus_pubkey?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description jailed defined whether the validator has been jailed from bonded status or not. */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /**
         * @description min_self_delegation is the validator's self declared minimum self delegation.
         *
         * Since: cosmos-sdk 0.46
         */
        min_self_delegation?: string;
        /**
         * strictly positive if this validator's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
        /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
        unbonding_ids?: string[];
      };
    };
    /**
     * @description QueryDelegatorValidatorsResponse is response type for the
     * Query/DelegatorValidators RPC method.
     */
    "cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse": {
      /** @description validators defines the validators' info of a delegator. */
      validators?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        consensus_pubkey?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description jailed defined whether the validator has been jailed from bonded status or not. */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /**
         * @description min_self_delegation is the validator's self declared minimum self delegation.
         *
         * Since: cosmos-sdk 0.46
         */
        min_self_delegation?: string;
        /**
         * strictly positive if this validator's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
        /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
        unbonding_ids?: string[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
     * method.
     */
    "cosmos.staking.v1beta1.QueryHistoricalInfoResponse": {
      /** @description hist defines the historical info at the given height. */
      hist?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** prev block info */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        valset?: {
          /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
          operator_address?: string;
          /**
           * @description `Any` contains an arbitrary serialized protocol buffer message along with a
           * URL that describes the type of the serialized message.
           *
           * Protobuf library provides support to pack/unpack Any values in the form
           * of utility functions or additional generated methods of the Any type.
           *
           * Example 1: Pack and unpack a message in C++.
           *
           *     Foo foo = ...;
           *     Any any;
           *     any.PackFrom(foo);
           *     ...
           *     if (any.UnpackTo(&foo)) {
           *       ...
           *     }
           *
           * Example 2: Pack and unpack a message in Java.
           *
           *     Foo foo = ...;
           *     Any any = Any.pack(foo);
           *     ...
           *     if (any.is(Foo.class)) {
           *       foo = any.unpack(Foo.class);
           *     }
           *
           * Example 3: Pack and unpack a message in Python.
           *
           *     foo = Foo(...)
           *     any = Any()
           *     any.Pack(foo)
           *     ...
           *     if any.Is(Foo.DESCRIPTOR):
           *       any.Unpack(foo)
           *       ...
           *
           * Example 4: Pack and unpack a message in Go
           *
           *      foo := &pb.Foo{...}
           *      any, err := anypb.New(foo)
           *      if err != nil {
           *        ...
           *      }
           *      ...
           *      foo := &pb.Foo{}
           *      if err := any.UnmarshalTo(foo); err != nil {
           *        ...
           *      }
           *
           * The pack methods provided by protobuf library will by default use
           * 'type.googleapis.com/full.type.name' as the type URL and the unpack
           * methods only use the fully qualified type name after the last '/'
           * in the type URL, for example "foo.bar.com/x/y.z" will yield type
           * name "y.z".
           *
           *
           * JSON
           *
           * The JSON representation of an `Any` value uses the regular
           * representation of the deserialized, embedded message, with an
           * additional field `@type` which contains the type URL. Example:
           *
           *     package google.profile;
           *     message Person {
           *       string first_name = 1;
           *       string last_name = 2;
           *     }
           *
           *     {
           *       "@type": "type.googleapis.com/google.profile.Person",
           *       "firstName": <string>,
           *       "lastName": <string>
           *     }
           *
           * If the embedded message type is well-known and has a custom JSON
           * representation, that representation will be embedded adding a field
           * `value` which holds the custom JSON in addition to the `@type`
           * field. Example (for message [google.protobuf.Duration][]):
           *
           *     {
           *       "@type": "type.googleapis.com/google.protobuf.Duration",
           *       "value": "1.212s"
           *     }
           */
          consensus_pubkey?: {
            /**
             * @description A URL/resource name that uniquely identifies the type of the serialized
             * protocol buffer message. This string must contain at least
             * one "/" character. The last segment of the URL's path must represent
             * the fully qualified name of the type (as in
             * `path/google.protobuf.Duration`). The name should be in a canonical form
             * (e.g., leading "." is not accepted).
             *
             * In practice, teams usually precompile into the binary all types that they
             * expect it to use in the context of Any. However, for URLs which use the
             * scheme `http`, `https`, or no scheme, one can optionally set up a type
             * server that maps type URLs to message definitions as follows:
             *
             * * If no scheme is provided, `https` is assumed.
             * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
             *   value in binary format, or produce an error.
             * * Applications are allowed to cache lookup results based on the
             *   URL, or have them precompiled into a binary to avoid any
             *   lookup. Therefore, binary compatibility needs to be preserved
             *   on changes to types. (Use versioned type names to manage
             *   breaking changes.)
             *
             * Note: this functionality is not currently available in the official
             * protobuf release, and it is not used for type URLs beginning with
             * type.googleapis.com.
             *
             * Schemes other than `http`, `https` (or the empty scheme) might be
             * used with implementation specific semantics.
             */
            type_url?: string;
            /**
             * Format: byte
             * @description Must be a valid serialized protocol buffer of the above specified type.
             */
            value?: string;
          };
          /** @description jailed defined whether the validator has been jailed from bonded status or not. */
          jailed?: boolean;
          /**
           * @description status is the validator status (bonded/unbonding/unbonded).
           * @default BOND_STATUS_UNSPECIFIED
           * @enum {string}
           */
          status?:
            | "BOND_STATUS_UNSPECIFIED"
            | "BOND_STATUS_UNBONDED"
            | "BOND_STATUS_UNBONDING"
            | "BOND_STATUS_BONDED";
          /** @description tokens define the delegated tokens (incl. self-delegation). */
          tokens?: string;
          /** @description delegator_shares defines total shares issued to a validator's delegators. */
          delegator_shares?: string;
          /** @description description defines the description terms for the validator. */
          description?: {
            /** @description moniker defines a human-readable name for the validator. */
            moniker?: string;
            /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
            identity?: string;
            /** @description website defines an optional website link. */
            website?: string;
            /** @description security_contact defines an optional email for security contact. */
            security_contact?: string;
            /** @description details define other optional details. */
            details?: string;
          };
          /**
           * Format: int64
           * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
           */
          unbonding_height?: string;
          /**
           * Format: date-time
           * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
           */
          unbonding_time?: string;
          /** @description commission defines the commission parameters. */
          commission?: {
            /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
            commission_rates?: {
              /** @description rate is the commission rate charged to delegators, as a fraction. */
              rate?: string;
              /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
              max_rate?: string;
              /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
              max_change_rate?: string;
            };
            /**
             * Format: date-time
             * @description update_time is the last time the commission rate was changed.
             */
            update_time?: string;
          };
          /**
           * @description min_self_delegation is the validator's self declared minimum self delegation.
           *
           * Since: cosmos-sdk 0.46
           */
          min_self_delegation?: string;
          /**
           * strictly positive if this validator's unbonding has been stopped by external modules
           * Format: int64
           */
          unbonding_on_hold_ref_count?: string;
          /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
          unbonding_ids?: string[];
        }[];
      };
    };
    /** @description QueryParamsResponse is response type for the Query/Params RPC method. */
    "cosmos.staking.v1beta1.QueryParamsResponse": {
      /** @description params holds all the parameters of this module. */
      params?: {
        /** @description unbonding_time is the time duration of unbonding. */
        unbonding_time?: string;
        /**
         * Format: int64
         * @description max_validators is the maximum number of validators.
         */
        max_validators?: number;
        /**
         * Format: int64
         * @description max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
         */
        max_entries?: number;
        /**
         * Format: int64
         * @description historical_entries is the number of historical entries to persist.
         */
        historical_entries?: number;
        /** @description bond_denom defines the bondable coin denomination. */
        bond_denom?: string;
        /** min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators */
        min_commission_rate?: string;
      };
    };
    /** @description QueryPoolResponse is response type for the Query/Pool RPC method. */
    "cosmos.staking.v1beta1.QueryPoolResponse": {
      /** @description pool defines the pool info. */
      pool?: {
        not_bonded_tokens?: string;
        bonded_tokens?: string;
      };
    };
    /**
     * @description QueryRedelegationsResponse is response type for the Query/Redelegations RPC
     * method.
     */
    "cosmos.staking.v1beta1.QueryRedelegationsResponse": {
      redelegation_responses?: {
        /**
         * @description Redelegation contains the list of a particular delegator's redelegating bonds
         * from a particular source validator to a particular destination validator.
         */
        redelegation?: {
          /** @description delegator_address is the bech32-encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_src_address is the validator redelegation source operator address. */
          validator_src_address?: string;
          /** @description validator_dst_address is the validator redelegation destination operator address. */
          validator_dst_address?: string;
          /** @description entries are the redelegation entries. */
          entries?: {
            /**
             * Format: int64
             * @description creation_height  defines the height which the redelegation took place.
             */
            creation_height?: string;
            /**
             * Format: date-time
             * @description completion_time defines the unix time for redelegation completion.
             */
            completion_time?: string;
            /** @description initial_balance defines the initial balance when redelegation started. */
            initial_balance?: string;
            /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
            shares_dst?: string;
            /**
             * Incrementing id that uniquely identifies this entry
             * Format: uint64
             */
            unbonding_id?: string;
            /**
             * Strictly positive if this entry's unbonding has been stopped by external modules
             * Format: int64
             */
            unbonding_on_hold_ref_count?: string;
          }[];
        };
        entries?: {
          /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
          redelegation_entry?: {
            /**
             * Format: int64
             * @description creation_height  defines the height which the redelegation took place.
             */
            creation_height?: string;
            /**
             * Format: date-time
             * @description completion_time defines the unix time for redelegation completion.
             */
            completion_time?: string;
            /** @description initial_balance defines the initial balance when redelegation started. */
            initial_balance?: string;
            /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
            shares_dst?: string;
            /**
             * Incrementing id that uniquely identifies this entry
             * Format: uint64
             */
            unbonding_id?: string;
            /**
             * Strictly positive if this entry's unbonding has been stopped by external modules
             * Format: int64
             */
            unbonding_on_hold_ref_count?: string;
          };
          balance?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description QueryDelegationResponse is response type for the Query/UnbondingDelegation
     * RPC method.
     */
    "cosmos.staking.v1beta1.QueryUnbondingDelegationResponse": {
      /**
       * @description UnbondingDelegation stores all of a single delegator's unbonding bonds
       * for a single validator in an time-ordered list.
       */
      unbond?: {
        /** @description delegator_address is the encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the encoded address of the validator. */
        validator_address?: string;
        /** @description entries are the unbonding delegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height is the height which the unbonding took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time is the unix time for unbonding completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
          initial_balance?: string;
          /** @description balance defines the tokens to receive at completion. */
          balance?: string;
          /**
           * Incrementing id that uniquely identifies this entry
           * Format: uint64
           */
          unbonding_id?: string;
          /**
           * Strictly positive if this entry's unbonding has been stopped by external modules
           * Format: int64
           */
          unbonding_on_hold_ref_count?: string;
        }[];
      };
    };
    /**
     * QueryValidatorDelegationsResponse is response type for the
     * Query/ValidatorDelegations RPC method
     */
    "cosmos.staking.v1beta1.QueryValidatorDelegationsResponse": {
      delegation_responses?: {
        /**
         * @description Delegation represents the bond with tokens held by an account. It is
         * owned by one delegator, and is associated with the voting power of one
         * validator.
         */
        delegation?: {
          /** @description delegator_address is the encoded address of the delegator. */
          delegator_address?: string;
          /** @description validator_address is the encoded address of the validator. */
          validator_address?: string;
          /** @description shares define the delegation shares received. */
          shares?: string;
        };
        /**
         * @description Coin defines a token with a denomination and an amount.
         *
         * NOTE: The amount field is an Int which implements the custom method
         * signatures required by gogoproto.
         */
        balance?: {
          denom?: string;
          amount?: string;
        };
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryValidatorResponse is response type for the Query/Validator RPC method */
    "cosmos.staking.v1beta1.QueryValidatorResponse": {
      /**
       * @description Validator defines a validator, together with the total amount of the
       * Validator's bond shares and their exchange rate to coins. Slashing results in
       * a decrease in the exchange rate, allowing correct calculation of future
       * undelegations without iterating over delegators. When coins are delegated to
       * this validator, the validator is credited with a delegation whose number of
       * bond shares is based on the amount of coins delegated divided by the current
       * exchange rate. Voting power can be calculated as total bonded shares
       * multiplied by exchange rate.
       */
      validator?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        consensus_pubkey?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description jailed defined whether the validator has been jailed from bonded status or not. */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /**
         * @description min_self_delegation is the validator's self declared minimum self delegation.
         *
         * Since: cosmos-sdk 0.46
         */
        min_self_delegation?: string;
        /**
         * strictly positive if this validator's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
        /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
        unbonding_ids?: string[];
      };
    };
    /**
     * @description QueryValidatorUnbondingDelegationsResponse is response type for the
     * Query/ValidatorUnbondingDelegations RPC method.
     */
    "cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse": {
      unbonding_responses?: {
        /** @description delegator_address is the encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_address is the encoded address of the validator. */
        validator_address?: string;
        /** @description entries are the unbonding delegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height is the height which the unbonding took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time is the unix time for unbonding completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
          initial_balance?: string;
          /** @description balance defines the tokens to receive at completion. */
          balance?: string;
          /**
           * Incrementing id that uniquely identifies this entry
           * Format: uint64
           */
          unbonding_id?: string;
          /**
           * Strictly positive if this entry's unbonding has been stopped by external modules
           * Format: int64
           */
          unbonding_on_hold_ref_count?: string;
        }[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** QueryValidatorsResponse is response type for the Query/Validators RPC method */
    "cosmos.staking.v1beta1.QueryValidatorsResponse": {
      /** @description validators contains all the queried validators. */
      validators?: {
        /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
        operator_address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        consensus_pubkey?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** @description jailed defined whether the validator has been jailed from bonded status or not. */
        jailed?: boolean;
        /**
         * @description status is the validator status (bonded/unbonding/unbonded).
         * @default BOND_STATUS_UNSPECIFIED
         * @enum {string}
         */
        status?:
          | "BOND_STATUS_UNSPECIFIED"
          | "BOND_STATUS_UNBONDED"
          | "BOND_STATUS_UNBONDING"
          | "BOND_STATUS_BONDED";
        /** @description tokens define the delegated tokens (incl. self-delegation). */
        tokens?: string;
        /** @description delegator_shares defines total shares issued to a validator's delegators. */
        delegator_shares?: string;
        /** @description description defines the description terms for the validator. */
        description?: {
          /** @description moniker defines a human-readable name for the validator. */
          moniker?: string;
          /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
          identity?: string;
          /** @description website defines an optional website link. */
          website?: string;
          /** @description security_contact defines an optional email for security contact. */
          security_contact?: string;
          /** @description details define other optional details. */
          details?: string;
        };
        /**
         * Format: int64
         * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
         */
        unbonding_height?: string;
        /**
         * Format: date-time
         * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
         */
        unbonding_time?: string;
        /** @description commission defines the commission parameters. */
        commission?: {
          /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
          commission_rates?: {
            /** @description rate is the commission rate charged to delegators, as a fraction. */
            rate?: string;
            /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
            max_rate?: string;
            /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
            max_change_rate?: string;
          };
          /**
           * Format: date-time
           * @description update_time is the last time the commission rate was changed.
           */
          update_time?: string;
        };
        /**
         * @description min_self_delegation is the validator's self declared minimum self delegation.
         *
         * Since: cosmos-sdk 0.46
         */
        min_self_delegation?: string;
        /**
         * strictly positive if this validator's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
        /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
        unbonding_ids?: string[];
      }[];
      /** @description pagination defines the pagination in the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /**
     * @description Redelegation contains the list of a particular delegator's redelegating bonds
     * from a particular source validator to a particular destination validator.
     */
    "cosmos.staking.v1beta1.Redelegation": {
      /** @description delegator_address is the bech32-encoded address of the delegator. */
      delegator_address?: string;
      /** @description validator_src_address is the validator redelegation source operator address. */
      validator_src_address?: string;
      /** @description validator_dst_address is the validator redelegation destination operator address. */
      validator_dst_address?: string;
      /** @description entries are the redelegation entries. */
      entries?: {
        /**
         * Format: int64
         * @description creation_height  defines the height which the redelegation took place.
         */
        creation_height?: string;
        /**
         * Format: date-time
         * @description completion_time defines the unix time for redelegation completion.
         */
        completion_time?: string;
        /** @description initial_balance defines the initial balance when redelegation started. */
        initial_balance?: string;
        /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
        shares_dst?: string;
        /**
         * Incrementing id that uniquely identifies this entry
         * Format: uint64
         */
        unbonding_id?: string;
        /**
         * Strictly positive if this entry's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
      }[];
    };
    /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
    "cosmos.staking.v1beta1.RedelegationEntry": {
      /**
       * Format: int64
       * @description creation_height  defines the height which the redelegation took place.
       */
      creation_height?: string;
      /**
       * Format: date-time
       * @description completion_time defines the unix time for redelegation completion.
       */
      completion_time?: string;
      /** @description initial_balance defines the initial balance when redelegation started. */
      initial_balance?: string;
      /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
      shares_dst?: string;
      /**
       * Incrementing id that uniquely identifies this entry
       * Format: uint64
       */
      unbonding_id?: string;
      /**
       * Strictly positive if this entry's unbonding has been stopped by external modules
       * Format: int64
       */
      unbonding_on_hold_ref_count?: string;
    };
    /**
     * @description RedelegationEntryResponse is equivalent to a RedelegationEntry except that it
     * contains a balance in addition to shares which is more suitable for client
     * responses.
     */
    "cosmos.staking.v1beta1.RedelegationEntryResponse": {
      /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
      redelegation_entry?: {
        /**
         * Format: int64
         * @description creation_height  defines the height which the redelegation took place.
         */
        creation_height?: string;
        /**
         * Format: date-time
         * @description completion_time defines the unix time for redelegation completion.
         */
        completion_time?: string;
        /** @description initial_balance defines the initial balance when redelegation started. */
        initial_balance?: string;
        /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
        shares_dst?: string;
        /**
         * Incrementing id that uniquely identifies this entry
         * Format: uint64
         */
        unbonding_id?: string;
        /**
         * Strictly positive if this entry's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
      };
      balance?: string;
    };
    /**
     * @description RedelegationResponse is equivalent to a Redelegation except that its entries
     * contain a balance in addition to shares which is more suitable for client
     * responses.
     */
    "cosmos.staking.v1beta1.RedelegationResponse": {
      /**
       * @description Redelegation contains the list of a particular delegator's redelegating bonds
       * from a particular source validator to a particular destination validator.
       */
      redelegation?: {
        /** @description delegator_address is the bech32-encoded address of the delegator. */
        delegator_address?: string;
        /** @description validator_src_address is the validator redelegation source operator address. */
        validator_src_address?: string;
        /** @description validator_dst_address is the validator redelegation destination operator address. */
        validator_dst_address?: string;
        /** @description entries are the redelegation entries. */
        entries?: {
          /**
           * Format: int64
           * @description creation_height  defines the height which the redelegation took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time defines the unix time for redelegation completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the initial balance when redelegation started. */
          initial_balance?: string;
          /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
          shares_dst?: string;
          /**
           * Incrementing id that uniquely identifies this entry
           * Format: uint64
           */
          unbonding_id?: string;
          /**
           * Strictly positive if this entry's unbonding has been stopped by external modules
           * Format: int64
           */
          unbonding_on_hold_ref_count?: string;
        }[];
      };
      entries?: {
        /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
        redelegation_entry?: {
          /**
           * Format: int64
           * @description creation_height  defines the height which the redelegation took place.
           */
          creation_height?: string;
          /**
           * Format: date-time
           * @description completion_time defines the unix time for redelegation completion.
           */
          completion_time?: string;
          /** @description initial_balance defines the initial balance when redelegation started. */
          initial_balance?: string;
          /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
          shares_dst?: string;
          /**
           * Incrementing id that uniquely identifies this entry
           * Format: uint64
           */
          unbonding_id?: string;
          /**
           * Strictly positive if this entry's unbonding has been stopped by external modules
           * Format: int64
           */
          unbonding_on_hold_ref_count?: string;
        };
        balance?: string;
      }[];
    };
    /**
     * @description UnbondingDelegation stores all of a single delegator's unbonding bonds
     * for a single validator in an time-ordered list.
     */
    "cosmos.staking.v1beta1.UnbondingDelegation": {
      /** @description delegator_address is the encoded address of the delegator. */
      delegator_address?: string;
      /** @description validator_address is the encoded address of the validator. */
      validator_address?: string;
      /** @description entries are the unbonding delegation entries. */
      entries?: {
        /**
         * Format: int64
         * @description creation_height is the height which the unbonding took place.
         */
        creation_height?: string;
        /**
         * Format: date-time
         * @description completion_time is the unix time for unbonding completion.
         */
        completion_time?: string;
        /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
        initial_balance?: string;
        /** @description balance defines the tokens to receive at completion. */
        balance?: string;
        /**
         * Incrementing id that uniquely identifies this entry
         * Format: uint64
         */
        unbonding_id?: string;
        /**
         * Strictly positive if this entry's unbonding has been stopped by external modules
         * Format: int64
         */
        unbonding_on_hold_ref_count?: string;
      }[];
    };
    /** @description UnbondingDelegationEntry defines an unbonding object with relevant metadata. */
    "cosmos.staking.v1beta1.UnbondingDelegationEntry": {
      /**
       * Format: int64
       * @description creation_height is the height which the unbonding took place.
       */
      creation_height?: string;
      /**
       * Format: date-time
       * @description completion_time is the unix time for unbonding completion.
       */
      completion_time?: string;
      /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
      initial_balance?: string;
      /** @description balance defines the tokens to receive at completion. */
      balance?: string;
      /**
       * Incrementing id that uniquely identifies this entry
       * Format: uint64
       */
      unbonding_id?: string;
      /**
       * Strictly positive if this entry's unbonding has been stopped by external modules
       * Format: int64
       */
      unbonding_on_hold_ref_count?: string;
    };
    /**
     * @description Validator defines a validator, together with the total amount of the
     * Validator's bond shares and their exchange rate to coins. Slashing results in
     * a decrease in the exchange rate, allowing correct calculation of future
     * undelegations without iterating over delegators. When coins are delegated to
     * this validator, the validator is credited with a delegation whose number of
     * bond shares is based on the amount of coins delegated divided by the current
     * exchange rate. Voting power can be calculated as total bonded shares
     * multiplied by exchange rate.
     */
    "cosmos.staking.v1beta1.Validator": {
      /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
      operator_address?: string;
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      consensus_pubkey?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** @description jailed defined whether the validator has been jailed from bonded status or not. */
      jailed?: boolean;
      /**
       * @description status is the validator status (bonded/unbonding/unbonded).
       * @default BOND_STATUS_UNSPECIFIED
       * @enum {string}
       */
      status?:
        | "BOND_STATUS_UNSPECIFIED"
        | "BOND_STATUS_UNBONDED"
        | "BOND_STATUS_UNBONDING"
        | "BOND_STATUS_BONDED";
      /** @description tokens define the delegated tokens (incl. self-delegation). */
      tokens?: string;
      /** @description delegator_shares defines total shares issued to a validator's delegators. */
      delegator_shares?: string;
      /** @description description defines the description terms for the validator. */
      description?: {
        /** @description moniker defines a human-readable name for the validator. */
        moniker?: string;
        /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
        identity?: string;
        /** @description website defines an optional website link. */
        website?: string;
        /** @description security_contact defines an optional email for security contact. */
        security_contact?: string;
        /** @description details define other optional details. */
        details?: string;
      };
      /**
       * Format: int64
       * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
       */
      unbonding_height?: string;
      /**
       * Format: date-time
       * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
       */
      unbonding_time?: string;
      /** @description commission defines the commission parameters. */
      commission?: {
        /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
        commission_rates?: {
          /** @description rate is the commission rate charged to delegators, as a fraction. */
          rate?: string;
          /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
          max_rate?: string;
          /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
          max_change_rate?: string;
        };
        /**
         * Format: date-time
         * @description update_time is the last time the commission rate was changed.
         */
        update_time?: string;
      };
      /**
       * @description min_self_delegation is the validator's self declared minimum self delegation.
       *
       * Since: cosmos-sdk 0.46
       */
      min_self_delegation?: string;
      /**
       * strictly positive if this validator's unbonding has been stopped by external modules
       * Format: int64
       */
      unbonding_on_hold_ref_count?: string;
      /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
      unbonding_ids?: string[];
    };
    /** BlockID */
    "tendermint.types.BlockID": {
      /** Format: byte */
      hash?: string;
      /** PartsetHeader */
      part_set_header?: {
        /** Format: int64 */
        total?: number;
        /** Format: byte */
        hash?: string;
      };
    };
    /** @description Header defines the structure of a block header. */
    "tendermint.types.Header": {
      /**
       * basic block info
       * @description Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** Format: uint64 */
        block?: string;
        /** Format: uint64 */
        app?: string;
      };
      chain_id?: string;
      /** Format: int64 */
      height?: string;
      /** Format: date-time */
      time?: string;
      /** prev block info */
      last_block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * Format: byte
       */
      last_commit_hash?: string;
      /** Format: byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * Format: byte
       */
      validators_hash?: string;
      /** Format: byte */
      next_validators_hash?: string;
      /** Format: byte */
      consensus_hash?: string;
      /** Format: byte */
      app_hash?: string;
      /** Format: byte */
      last_results_hash?: string;
      /**
       * consensus info
       * Format: byte
       */
      evidence_hash?: string;
      /** Format: byte */
      proposer_address?: string;
    };
    /** PartsetHeader */
    "tendermint.types.PartSetHeader": {
      /** Format: int64 */
      total?: number;
      /** Format: byte */
      hash?: string;
    };
    /**
     * @description Consensus captures the consensus rules for processing a block in the blockchain,
     * including all blockchain data structures and the rules of the application's
     * state transition machine.
     */
    "tendermint.version.Consensus": {
      /** Format: uint64 */
      block?: string;
      /** Format: uint64 */
      app?: string;
    };
    /** @description ABCIMessageLog defines a structure containing an indexed tx ABCI message log. */
    "cosmos.base.abci.v1beta1.ABCIMessageLog": {
      /** Format: int64 */
      msg_index?: number;
      log?: string;
      /**
       * @description Events contains a slice of Event objects that were emitted during some
       * execution.
       */
      events?: {
        type?: string;
        attributes?: {
          key?: string;
          value?: string;
        }[];
      }[];
    };
    /**
     * @description Attribute defines an attribute wrapper where the key and value are
     * strings instead of raw bytes.
     */
    "cosmos.base.abci.v1beta1.Attribute": {
      key?: string;
      value?: string;
    };
    /** @description GasInfo defines tx execution gas context. */
    "cosmos.base.abci.v1beta1.GasInfo": {
      /**
       * Format: uint64
       * @description GasWanted is the maximum units of work we allow this tx to perform.
       */
      gas_wanted?: string;
      /**
       * Format: uint64
       * @description GasUsed is the amount of gas actually consumed.
       */
      gas_used?: string;
    };
    /** @description Result is the union of ResponseFormat and ResponseCheckTx. */
    "cosmos.base.abci.v1beta1.Result": {
      /**
       * Format: byte
       * @description Data is any data returned from message or handler execution. It MUST be
       * length prefixed in order to separate data from multiple message executions.
       * Deprecated. This field is still populated, but prefer msg_response instead
       * because it also contains the Msg response typeURL.
       */
      data?: string;
      /** @description Log contains the log information from message or handler execution. */
      log?: string;
      /**
       * @description Events contains a slice of Event objects that were emitted during message
       * or handler execution.
       */
      events?: {
        type?: string;
        attributes?: {
          key?: string;
          value?: string;
          index?: boolean;
        }[];
      }[];
      /**
       * @description msg_responses contains the Msg handler responses type packed in Anys.
       *
       * Since: cosmos-sdk 0.46
       */
      msg_responses?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
    };
    /**
     * @description StringEvent defines en Event object wrapper where all the attributes
     * contain key/value pairs that are strings instead of raw bytes.
     */
    "cosmos.base.abci.v1beta1.StringEvent": {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
      }[];
    };
    /**
     * @description TxResponse defines a structure containing relevant tx data and metadata. The
     * tags are stringified and the log is JSON decoded.
     */
    "cosmos.base.abci.v1beta1.TxResponse": {
      /**
       * The block height
       * Format: int64
       */
      height?: string;
      /** @description The transaction hash. */
      txhash?: string;
      /** Namespace for the Code */
      codespace?: string;
      /**
       * Format: int64
       * @description Response code.
       */
      code?: number;
      /** @description Result bytes, if any. */
      data?: string;
      /**
       * @description The output of the application's logger (raw string). May be
       * non-deterministic.
       */
      raw_log?: string;
      /** @description The output of the application's logger (typed). May be non-deterministic. */
      logs?: {
        /** Format: int64 */
        msg_index?: number;
        log?: string;
        /**
         * @description Events contains a slice of Event objects that were emitted during some
         * execution.
         */
        events?: {
          type?: string;
          attributes?: {
            key?: string;
            value?: string;
          }[];
        }[];
      }[];
      /** @description Additional information. May be non-deterministic. */
      info?: string;
      /**
       * Format: int64
       * @description Amount of gas requested for transaction.
       */
      gas_wanted?: string;
      /**
       * Format: int64
       * @description Amount of gas consumed by transaction.
       */
      gas_used?: string;
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      tx?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /**
       * @description Time of the previous block. For heights > 1, it's the weighted median of
       * the timestamps of the valid votes in the block.LastCommit. For height == 1,
       * it's genesis time.
       */
      timestamp?: string;
      /**
       * @description Events defines all the events emitted by processing a transaction. Note,
       * these events include those emitted by processing all the messages and those
       * emitted from the ante. Whereas Logs contains the events, with
       * additional metadata, emitted only by processing the messages.
       *
       * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
       */
      events?: {
        type?: string;
        attributes?: {
          key?: string;
          value?: string;
          index?: boolean;
        }[];
      }[];
    };
    /**
     * @description CompactBitArray is an implementation of a space efficient bit array.
     * This is used to ensure that the encoded data takes up a minimal amount of
     * space after proto encoding.
     * This is not thread safe, and is not intended for concurrent usage.
     */
    "cosmos.crypto.multisig.v1beta1.CompactBitArray": {
      /** Format: int64 */
      extra_bits_stored?: number;
      /** Format: byte */
      elems?: string;
    };
    /**
     * @description SignMode represents a signing mode with its own security guarantees.
     *
     * This enum should be considered a registry of all known sign modes
     * in the Cosmos ecosystem. Apps are not expected to support all known
     * sign modes. Apps that would like to support custom  sign modes are
     * encouraged to open a small PR against this file to add a new case
     * to this SignMode enum describing their sign mode so that different
     * apps have a consistent version of this enum.
     *
     *  - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
     * rejected.
     *  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
     * verified with raw bytes from Tx.
     *  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
     * human-readable textual representation on top of the binary representation
     * from SIGN_MODE_DIRECT. It is currently experimental, and should be used
     * for testing purposes only, until Textual is fully released. Please follow
     * the tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.
     *  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
     * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
     * require signers signing over other signers' `signer_info`. It also allows
     * for adding Tips in transactions.
     *
     * Since: cosmos-sdk 0.46
     *  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
     * Amino JSON and will be removed in the future.
     *  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
     * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
     *
     * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
     * but is not implemented on the SDK by default. To enable EIP-191, you need
     * to pass a custom `TxConfig` that has an implementation of
     * `SignModeHandler` for EIP-191. The SDK may decide to fully support
     * EIP-191 in the future.
     *
     * Since: cosmos-sdk 0.45.2
     * @default SIGN_MODE_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.tx.signing.v1beta1.SignMode":
      | "SIGN_MODE_UNSPECIFIED"
      | "SIGN_MODE_DIRECT"
      | "SIGN_MODE_TEXTUAL"
      | "SIGN_MODE_DIRECT_AUX"
      | "SIGN_MODE_LEGACY_AMINO_JSON"
      | "SIGN_MODE_EIP_191";
    /**
     * @description AuthInfo describes the fee and signer modes that are used to sign a
     * transaction.
     */
    "cosmos.tx.v1beta1.AuthInfo": {
      /**
       * @description signer_infos defines the signing modes for the required signers. The number
       * and order of elements must match the required signers from TxBody's
       * messages. The first element is the primary signer and the one which pays
       * the fee.
       */
      signer_infos?: components["schemas"]["cosmos.tx.v1beta1.SignerInfo"][];
      /**
       * @description Fee is the fee and gas limit for the transaction. The first signer is the
       * primary signer and the one which pays the fee. The fee can be calculated
       * based on the cost of evaluating the body and doing signature verification
       * of the signers. This can be estimated via simulation.
       */
      fee?: {
        /** amount is the amount of coins to be paid as a fee */
        amount?: {
          denom?: string;
          amount?: string;
        }[];
        /**
         * gas_limit is the maximum gas that can be used in transaction processing
         * before an out of gas error occurs
         * Format: uint64
         */
        gas_limit?: string;
        /**
         * @description if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
         * the payer must be a tx signer (and thus have signed this field in AuthInfo).
         * setting this field does *not* change the ordering of required signers for the transaction.
         */
        payer?: string;
        /**
         * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
         * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
         * not support fee grants, this will fail
         */
        granter?: string;
      };
      /**
       * @description Tip is the optional tip used for transactions fees paid in another denom.
       *
       * This field is ignored if the chain didn't enable tips, i.e. didn't add the
       * `TipDecorator` in its posthandler.
       *
       * Since: cosmos-sdk 0.46
       */
      tip?: {
        /** amount is the amount of the tip */
        amount?: {
          denom?: string;
          amount?: string;
        }[];
        /** tipper is the address of the account paying for the tip */
        tipper?: string;
      };
    };
    /**
     * @description BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
     * method.
     *
     *  - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
     *  - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
     * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
     *  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
     * for a CheckTx execution response only.
     *  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
     * returns immediately.
     * @default BROADCAST_MODE_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.tx.v1beta1.BroadcastMode":
      | "BROADCAST_MODE_UNSPECIFIED"
      | "BROADCAST_MODE_BLOCK"
      | "BROADCAST_MODE_SYNC"
      | "BROADCAST_MODE_ASYNC";
    /**
     * @description BroadcastTxRequest is the request type for the Service.BroadcastTxRequest
     * RPC method.
     */
    "cosmos.tx.v1beta1.BroadcastTxRequest": {
      /**
       * Format: byte
       * @description tx_bytes is the raw transaction.
       */
      tx_bytes?: string;
      /**
       * @description BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
       * method.
       *
       *  - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
       *  - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
       * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
       *  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
       * for a CheckTx execution response only.
       *  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
       * returns immediately.
       * @default BROADCAST_MODE_UNSPECIFIED
       * @enum {string}
       */
      mode?:
        | "BROADCAST_MODE_UNSPECIFIED"
        | "BROADCAST_MODE_BLOCK"
        | "BROADCAST_MODE_SYNC"
        | "BROADCAST_MODE_ASYNC";
    };
    /**
     * @description BroadcastTxResponse is the response type for the
     * Service.BroadcastTx method.
     */
    "cosmos.tx.v1beta1.BroadcastTxResponse": {
      /**
       * @description TxResponse defines a structure containing relevant tx data and metadata. The
       * tags are stringified and the log is JSON decoded.
       */
      tx_response?: {
        /**
         * The block height
         * Format: int64
         */
        height?: string;
        /** @description The transaction hash. */
        txhash?: string;
        /** Namespace for the Code */
        codespace?: string;
        /**
         * Format: int64
         * @description Response code.
         */
        code?: number;
        /** @description Result bytes, if any. */
        data?: string;
        /**
         * @description The output of the application's logger (raw string). May be
         * non-deterministic.
         */
        raw_log?: string;
        /** @description The output of the application's logger (typed). May be non-deterministic. */
        logs?: {
          /** Format: int64 */
          msg_index?: number;
          log?: string;
          /**
           * @description Events contains a slice of Event objects that were emitted during some
           * execution.
           */
          events?: {
            type?: string;
            attributes?: {
              key?: string;
              value?: string;
            }[];
          }[];
        }[];
        /** @description Additional information. May be non-deterministic. */
        info?: string;
        /**
         * Format: int64
         * @description Amount of gas requested for transaction.
         */
        gas_wanted?: string;
        /**
         * Format: int64
         * @description Amount of gas consumed by transaction.
         */
        gas_used?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        tx?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * @description Time of the previous block. For heights > 1, it's the weighted median of
         * the timestamps of the valid votes in the block.LastCommit. For height == 1,
         * it's genesis time.
         */
        timestamp?: string;
        /**
         * @description Events defines all the events emitted by processing a transaction. Note,
         * these events include those emitted by processing all the messages and those
         * emitted from the ante. Whereas Logs contains the events, with
         * additional metadata, emitted only by processing the messages.
         *
         * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
         */
        events?: {
          type?: string;
          attributes?: {
            key?: string;
            value?: string;
            index?: boolean;
          }[];
        }[];
      };
    };
    /**
     * @description Fee includes the amount of coins paid in fees and the maximum
     * gas to be used by the transaction. The ratio yields an effective "gasprice",
     * which must be above some miminum to be accepted into the mempool.
     */
    "cosmos.tx.v1beta1.Fee": {
      /** amount is the amount of coins to be paid as a fee */
      amount?: {
        denom?: string;
        amount?: string;
      }[];
      /**
       * gas_limit is the maximum gas that can be used in transaction processing
       * before an out of gas error occurs
       * Format: uint64
       */
      gas_limit?: string;
      /**
       * @description if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
       * the payer must be a tx signer (and thus have signed this field in AuthInfo).
       * setting this field does *not* change the ordering of required signers for the transaction.
       */
      payer?: string;
      /**
       * if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
       * to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
       * not support fee grants, this will fail
       */
      granter?: string;
    };
    /**
     * @description GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs
     * method.
     *
     * Since: cosmos-sdk 0.45.2
     */
    "cosmos.tx.v1beta1.GetBlockWithTxsResponse": {
      /** @description txs are the transactions in the block. */
      txs?: components["schemas"]["cosmos.tx.v1beta1.Tx"][];
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      block?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /**
           * @description Txs that will be applied by state @ block.Height+1.
           * NOTE: not all txs here are valid.  We're just agreeing on the order first.
           * This means that block.AppHash does not include these txs.
           */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     * including all blockchain data structures and the rules of the application's
                     * state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlockID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag?:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlockID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag?:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
      /** @description pagination defines a pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description GetTxResponse is the response type for the Service.GetTx method. */
    "cosmos.tx.v1beta1.GetTxResponse": {
      tx?: components["schemas"]["cosmos.tx.v1beta1.Tx"];
      /**
       * @description TxResponse defines a structure containing relevant tx data and metadata. The
       * tags are stringified and the log is JSON decoded.
       */
      tx_response?: {
        /**
         * The block height
         * Format: int64
         */
        height?: string;
        /** @description The transaction hash. */
        txhash?: string;
        /** Namespace for the Code */
        codespace?: string;
        /**
         * Format: int64
         * @description Response code.
         */
        code?: number;
        /** @description Result bytes, if any. */
        data?: string;
        /**
         * @description The output of the application's logger (raw string). May be
         * non-deterministic.
         */
        raw_log?: string;
        /** @description The output of the application's logger (typed). May be non-deterministic. */
        logs?: {
          /** Format: int64 */
          msg_index?: number;
          log?: string;
          /**
           * @description Events contains a slice of Event objects that were emitted during some
           * execution.
           */
          events?: {
            type?: string;
            attributes?: {
              key?: string;
              value?: string;
            }[];
          }[];
        }[];
        /** @description Additional information. May be non-deterministic. */
        info?: string;
        /**
         * Format: int64
         * @description Amount of gas requested for transaction.
         */
        gas_wanted?: string;
        /**
         * Format: int64
         * @description Amount of gas consumed by transaction.
         */
        gas_used?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        tx?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * @description Time of the previous block. For heights > 1, it's the weighted median of
         * the timestamps of the valid votes in the block.LastCommit. For height == 1,
         * it's genesis time.
         */
        timestamp?: string;
        /**
         * @description Events defines all the events emitted by processing a transaction. Note,
         * these events include those emitted by processing all the messages and those
         * emitted from the ante. Whereas Logs contains the events, with
         * additional metadata, emitted only by processing the messages.
         *
         * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
         */
        events?: {
          type?: string;
          attributes?: {
            key?: string;
            value?: string;
            index?: boolean;
          }[];
        }[];
      };
    };
    /**
     * @description GetTxsEventResponse is the response type for the Service.TxsByEvents
     * RPC method.
     */
    "cosmos.tx.v1beta1.GetTxsEventResponse": {
      /** @description txs is the list of queried transactions. */
      txs?: components["schemas"]["cosmos.tx.v1beta1.Tx"][];
      /** @description tx_responses is the list of queried TxResponses. */
      tx_responses?: {
        /**
         * The block height
         * Format: int64
         */
        height?: string;
        /** @description The transaction hash. */
        txhash?: string;
        /** Namespace for the Code */
        codespace?: string;
        /**
         * Format: int64
         * @description Response code.
         */
        code?: number;
        /** @description Result bytes, if any. */
        data?: string;
        /**
         * @description The output of the application's logger (raw string). May be
         * non-deterministic.
         */
        raw_log?: string;
        /** @description The output of the application's logger (typed). May be non-deterministic. */
        logs?: {
          /** Format: int64 */
          msg_index?: number;
          log?: string;
          /**
           * @description Events contains a slice of Event objects that were emitted during some
           * execution.
           */
          events?: {
            type?: string;
            attributes?: {
              key?: string;
              value?: string;
            }[];
          }[];
        }[];
        /** @description Additional information. May be non-deterministic. */
        info?: string;
        /**
         * Format: int64
         * @description Amount of gas requested for transaction.
         */
        gas_wanted?: string;
        /**
         * Format: int64
         * @description Amount of gas consumed by transaction.
         */
        gas_used?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        tx?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /**
         * @description Time of the previous block. For heights > 1, it's the weighted median of
         * the timestamps of the valid votes in the block.LastCommit. For height == 1,
         * it's genesis time.
         */
        timestamp?: string;
        /**
         * @description Events defines all the events emitted by processing a transaction. Note,
         * these events include those emitted by processing all the messages and those
         * emitted from the ante. Whereas Logs contains the events, with
         * additional metadata, emitted only by processing the messages.
         *
         * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
         */
        events?: {
          type?: string;
          attributes?: {
            key?: string;
            value?: string;
            index?: boolean;
          }[];
        }[];
      }[];
      /**
       * @description pagination defines a pagination for the response.
       * Deprecated post v0.46.x: use total instead.
       */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
      /**
       * total is total number of results available
       * Format: uint64
       */
      total?: string;
    };
    /** @description ModeInfo describes the signing mode of a single or nested multisig signer. */
    "cosmos.tx.v1beta1.ModeInfo": {
      /** single represents a single signer */
      single?: {
        /**
         * mode is the signing mode of the single signer
         * @description SignMode represents a signing mode with its own security guarantees.
         *
         * This enum should be considered a registry of all known sign modes
         * in the Cosmos ecosystem. Apps are not expected to support all known
         * sign modes. Apps that would like to support custom  sign modes are
         * encouraged to open a small PR against this file to add a new case
         * to this SignMode enum describing their sign mode so that different
         * apps have a consistent version of this enum.
         *
         *  - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
         * rejected.
         *  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
         * verified with raw bytes from Tx.
         *  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
         * human-readable textual representation on top of the binary representation
         * from SIGN_MODE_DIRECT. It is currently experimental, and should be used
         * for testing purposes only, until Textual is fully released. Please follow
         * the tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.
         *  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
         * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
         * require signers signing over other signers' `signer_info`. It also allows
         * for adding Tips in transactions.
         *
         * Since: cosmos-sdk 0.46
         *  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
         * Amino JSON and will be removed in the future.
         *  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
         * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
         *
         * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
         * but is not implemented on the SDK by default. To enable EIP-191, you need
         * to pass a custom `TxConfig` that has an implementation of
         * `SignModeHandler` for EIP-191. The SDK may decide to fully support
         * EIP-191 in the future.
         *
         * Since: cosmos-sdk 0.45.2
         * @default SIGN_MODE_UNSPECIFIED
         * @enum {string}
         */
        mode?:
          | "SIGN_MODE_UNSPECIFIED"
          | "SIGN_MODE_DIRECT"
          | "SIGN_MODE_TEXTUAL"
          | "SIGN_MODE_DIRECT_AUX"
          | "SIGN_MODE_LEGACY_AMINO_JSON"
          | "SIGN_MODE_EIP_191";
      };
      multi?: components["schemas"]["cosmos.tx.v1beta1.ModeInfo.Multi"];
    };
    /** Multi is the mode info for a multisig public key */
    "cosmos.tx.v1beta1.ModeInfo.Multi": {
      /**
       * bitarray specifies which keys within the multisig are signing
       * @description CompactBitArray is an implementation of a space efficient bit array.
       * This is used to ensure that the encoded data takes up a minimal amount of
       * space after proto encoding.
       * This is not thread safe, and is not intended for concurrent usage.
       */
      bitarray?: {
        /** Format: int64 */
        extra_bits_stored?: number;
        /** Format: byte */
        elems?: string;
      };
      /**
       * mode_infos is the corresponding modes of the signers of the multisig
       * which could include nested multisig public keys
       */
      mode_infos?: components["schemas"]["cosmos.tx.v1beta1.ModeInfo"][];
    };
    /**
     * Single is the mode info for a single signer. It is structured as a message
     * to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
     * future
     */
    "cosmos.tx.v1beta1.ModeInfo.Single": {
      /**
       * mode is the signing mode of the single signer
       * @description SignMode represents a signing mode with its own security guarantees.
       *
       * This enum should be considered a registry of all known sign modes
       * in the Cosmos ecosystem. Apps are not expected to support all known
       * sign modes. Apps that would like to support custom  sign modes are
       * encouraged to open a small PR against this file to add a new case
       * to this SignMode enum describing their sign mode so that different
       * apps have a consistent version of this enum.
       *
       *  - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be
       * rejected.
       *  - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is
       * verified with raw bytes from Tx.
       *  - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some
       * human-readable textual representation on top of the binary representation
       * from SIGN_MODE_DIRECT. It is currently experimental, and should be used
       * for testing purposes only, until Textual is fully released. Please follow
       * the tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.
       *  - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses
       * SignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not
       * require signers signing over other signers' `signer_info`. It also allows
       * for adding Tips in transactions.
       *
       * Since: cosmos-sdk 0.46
       *  - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses
       * Amino JSON and will be removed in the future.
       *  - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos
       * SDK. Ref: https://eips.ethereum.org/EIPS/eip-191
       *
       * Currently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,
       * but is not implemented on the SDK by default. To enable EIP-191, you need
       * to pass a custom `TxConfig` that has an implementation of
       * `SignModeHandler` for EIP-191. The SDK may decide to fully support
       * EIP-191 in the future.
       *
       * Since: cosmos-sdk 0.45.2
       * @default SIGN_MODE_UNSPECIFIED
       * @enum {string}
       */
      mode?:
        | "SIGN_MODE_UNSPECIFIED"
        | "SIGN_MODE_DIRECT"
        | "SIGN_MODE_TEXTUAL"
        | "SIGN_MODE_DIRECT_AUX"
        | "SIGN_MODE_LEGACY_AMINO_JSON"
        | "SIGN_MODE_EIP_191";
    };
    /**
     * OrderBy defines the sorting order
     * @description - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults
     * to ASC in this case.
     *  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
     *  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
     * @default ORDER_BY_UNSPECIFIED
     * @enum {string}
     */
    "cosmos.tx.v1beta1.OrderBy":
      | "ORDER_BY_UNSPECIFIED"
      | "ORDER_BY_ASC"
      | "ORDER_BY_DESC";
    /**
     * @description SignerInfo describes the public key and signing mode of a single top-level
     * signer.
     */
    "cosmos.tx.v1beta1.SignerInfo": {
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      public_key?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      mode_info?: components["schemas"]["cosmos.tx.v1beta1.ModeInfo"];
      /**
       * Format: uint64
       * @description sequence is the sequence of the account, which describes the
       * number of committed transactions signed by a given address. It is used to
       * prevent replay attacks.
       */
      sequence?: string;
    };
    /**
     * @description SimulateRequest is the request type for the Service.Simulate
     * RPC method.
     */
    "cosmos.tx.v1beta1.SimulateRequest": {
      tx?: components["schemas"]["cosmos.tx.v1beta1.Tx"];
      /**
       * Format: byte
       * @description tx_bytes is the raw transaction.
       *
       * Since: cosmos-sdk 0.43
       */
      tx_bytes?: string;
    };
    /**
     * @description SimulateResponse is the response type for the
     * Service.SimulateRPC method.
     */
    "cosmos.tx.v1beta1.SimulateResponse": {
      /** @description gas_info is the information about gas used in the simulation. */
      gas_info?: {
        /**
         * Format: uint64
         * @description GasWanted is the maximum units of work we allow this tx to perform.
         */
        gas_wanted?: string;
        /**
         * Format: uint64
         * @description GasUsed is the amount of gas actually consumed.
         */
        gas_used?: string;
      };
      /** @description result is the result of the simulation. */
      result?: {
        /**
         * Format: byte
         * @description Data is any data returned from message or handler execution. It MUST be
         * length prefixed in order to separate data from multiple message executions.
         * Deprecated. This field is still populated, but prefer msg_response instead
         * because it also contains the Msg response typeURL.
         */
        data?: string;
        /** @description Log contains the log information from message or handler execution. */
        log?: string;
        /**
         * @description Events contains a slice of Event objects that were emitted during message
         * or handler execution.
         */
        events?: {
          type?: string;
          attributes?: {
            key?: string;
            value?: string;
            index?: boolean;
          }[];
        }[];
        /**
         * @description msg_responses contains the Msg handler responses type packed in Anys.
         *
         * Since: cosmos-sdk 0.46
         */
        msg_responses?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
      };
    };
    /**
     * @description Tip is the tip used for meta-transactions.
     *
     * Since: cosmos-sdk 0.46
     */
    "cosmos.tx.v1beta1.Tip": {
      /** amount is the amount of the tip */
      amount?: {
        denom?: string;
        amount?: string;
      }[];
      /** tipper is the address of the account paying for the tip */
      tipper?: string;
    };
    /** @description Tx is the standard type used for broadcasting transactions. */
    "cosmos.tx.v1beta1.Tx": {
      /**
       * body is the processable content of the transaction
       * @description TxBody is the body of a transaction that all signers sign over.
       */
      body?: {
        /**
         * @description messages is a list of messages to be executed. The required signers of
         * those messages define the number and order of elements in AuthInfo's
         * signer_infos and Tx's signatures. Each required signer address is added to
         * the list only the first time it occurs.
         * By convention, the first required signer (usually from the first message)
         * is referred to as the primary signer and pays the fee for the whole
         * transaction.
         */
        messages?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
        /**
         * @description memo is any arbitrary note/comment to be added to the transaction.
         * WARNING: in clients, any publicly exposed text should not be called memo,
         * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
         */
        memo?: string;
        /**
         * timeout is the block height after which this transaction will not
         * be processed by the chain
         * Format: uint64
         */
        timeout_height?: string;
        /**
         * extension_options are arbitrary options that can be added by chains
         * when the default options are not sufficient. If any of these are present
         * and can't be handled, the transaction will be rejected
         */
        extension_options?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
        /**
         * extension_options are arbitrary options that can be added by chains
         * when the default options are not sufficient. If any of these are present
         * and can't be handled, they will be ignored
         */
        non_critical_extension_options?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        }[];
      };
      auth_info?: components["schemas"]["cosmos.tx.v1beta1.AuthInfo"];
      /**
       * @description signatures is a list of signatures that matches the length and order of
       * AuthInfo's signer_infos to allow connecting signature meta information like
       * public key and signing mode by position.
       */
      signatures?: string[];
    };
    /** @description TxBody is the body of a transaction that all signers sign over. */
    "cosmos.tx.v1beta1.TxBody": {
      /**
       * @description messages is a list of messages to be executed. The required signers of
       * those messages define the number and order of elements in AuthInfo's
       * signer_infos and Tx's signatures. Each required signer address is added to
       * the list only the first time it occurs.
       * By convention, the first required signer (usually from the first message)
       * is referred to as the primary signer and pays the fee for the whole
       * transaction.
       */
      messages?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /**
       * @description memo is any arbitrary note/comment to be added to the transaction.
       * WARNING: in clients, any publicly exposed text should not be called memo,
       * but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
       */
      memo?: string;
      /**
       * timeout is the block height after which this transaction will not
       * be processed by the chain
       * Format: uint64
       */
      timeout_height?: string;
      /**
       * extension_options are arbitrary options that can be added by chains
       * when the default options are not sufficient. If any of these are present
       * and can't be handled, the transaction will be rejected
       */
      extension_options?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
      /**
       * extension_options are arbitrary options that can be added by chains
       * when the default options are not sufficient. If any of these are present
       * and can't be handled, they will be ignored
       */
      non_critical_extension_options?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      }[];
    };
    /**
     * @description TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino
     * RPC method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxDecodeAminoRequest": {
      /** Format: byte */
      amino_binary?: string;
    };
    /**
     * @description TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino
     * RPC method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxDecodeAminoResponse": {
      amino_json?: string;
    };
    /**
     * @description TxDecodeRequest is the request type for the Service.TxDecode
     * RPC method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxDecodeRequest": {
      /**
       * Format: byte
       * @description tx_bytes is the raw transaction.
       */
      tx_bytes?: string;
    };
    /**
     * @description TxDecodeResponse is the response type for the
     * Service.TxDecode method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxDecodeResponse": {
      tx?: components["schemas"]["cosmos.tx.v1beta1.Tx"];
    };
    /**
     * @description TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino
     * RPC method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxEncodeAminoRequest": {
      amino_json?: string;
    };
    /**
     * @description TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino
     * RPC method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxEncodeAminoResponse": {
      /** Format: byte */
      amino_binary?: string;
    };
    /**
     * @description TxEncodeRequest is the request type for the Service.TxEncode
     * RPC method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxEncodeRequest": {
      tx?: components["schemas"]["cosmos.tx.v1beta1.Tx"];
    };
    /**
     * @description TxEncodeResponse is the response type for the
     * Service.TxEncode method.
     *
     * Since: cosmos-sdk 0.47
     */
    "cosmos.tx.v1beta1.TxEncodeResponse": {
      /**
       * Format: byte
       * @description tx_bytes is the encoded transaction bytes.
       */
      tx_bytes?: string;
    };
    /**
     * @description Event allows application developers to attach additional information to
     * ResponseFinalizeBlock and ResponseCheckTx.
     * Later, transactions may be queried using these events.
     */
    "tendermint.abci.Event": {
      type?: string;
      attributes?: {
        key?: string;
        value?: string;
        index?: boolean;
      }[];
    };
    /** @description EventAttribute is a single key-value pair, associated with an event. */
    "tendermint.abci.EventAttribute": {
      key?: string;
      value?: string;
      index?: boolean;
    };
    /** PublicKey defines the keys available for use with Validators */
    "tendermint.crypto.PublicKey": {
      /** Format: byte */
      ed25519?: string;
      /** Format: byte */
      secp256k1?: string;
    };
    "tendermint.types.Block": {
      /** @description Header defines the structure of a block header. */
      header?: {
        /**
         * basic block info
         * @description Consensus captures the consensus rules for processing a block in the blockchain,
         * including all blockchain data structures and the rules of the application's
         * state transition machine.
         */
        version?: {
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        chain_id?: string;
        /** Format: int64 */
        height?: string;
        /** Format: date-time */
        time?: string;
        /** BlockID */
        last_block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * Format: byte
         */
        last_commit_hash?: string;
        /** Format: byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * Format: byte
         */
        validators_hash?: string;
        /** Format: byte */
        next_validators_hash?: string;
        /** Format: byte */
        consensus_hash?: string;
        /** Format: byte */
        app_hash?: string;
        /** Format: byte */
        last_results_hash?: string;
        /**
         * consensus info
         * Format: byte
         */
        evidence_hash?: string;
        /** Format: byte */
        proposer_address?: string;
      };
      /** Data contains the set of transactions included in the block */
      data?: {
        /**
         * @description Txs that will be applied by state @ block.Height+1.
         * NOTE: not all txs here are valid.  We're just agreeing on the order first.
         * This means that block.AppHash does not include these txs.
         */
        txs?: string[];
      };
      evidence?: {
        evidence?: {
          /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
          duplicate_vote_evidence?: {
            /**
             * @description Vote represents a prevote or precommit vote from validators for
             * consensus.
             */
            vote_a?: {
              /**
               * @description SignedMsgType is a type of signed message in the consensus.
               *
               *  - SIGNED_MSG_TYPE_PREVOTE: Votes
               *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
               * @default SIGNED_MSG_TYPE_UNKNOWN
               * @enum {string}
               */
              type?:
                | "SIGNED_MSG_TYPE_UNKNOWN"
                | "SIGNED_MSG_TYPE_PREVOTE"
                | "SIGNED_MSG_TYPE_PRECOMMIT"
                | "SIGNED_MSG_TYPE_PROPOSAL";
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              validator_address?: string;
              /** Format: int32 */
              validator_index?: number;
              /**
               * Format: byte
               * @description Vote signature by the validator if they participated in consensus for the
               * associated block.
               */
              signature?: string;
              /**
               * Format: byte
               * @description Vote extension provided by the application. Only valid for precommit
               * messages.
               */
              extension?: string;
              /**
               * Format: byte
               * @description Vote extension signature by the validator if they participated in
               * consensus for the associated block.
               * Only valid for precommit messages.
               */
              extension_signature?: string;
            };
            /**
             * @description Vote represents a prevote or precommit vote from validators for
             * consensus.
             */
            vote_b?: {
              /**
               * @description SignedMsgType is a type of signed message in the consensus.
               *
               *  - SIGNED_MSG_TYPE_PREVOTE: Votes
               *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
               * @default SIGNED_MSG_TYPE_UNKNOWN
               * @enum {string}
               */
              type?:
                | "SIGNED_MSG_TYPE_UNKNOWN"
                | "SIGNED_MSG_TYPE_PREVOTE"
                | "SIGNED_MSG_TYPE_PRECOMMIT"
                | "SIGNED_MSG_TYPE_PROPOSAL";
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              validator_address?: string;
              /** Format: int32 */
              validator_index?: number;
              /**
               * Format: byte
               * @description Vote signature by the validator if they participated in consensus for the
               * associated block.
               */
              signature?: string;
              /**
               * Format: byte
               * @description Vote extension provided by the application. Only valid for precommit
               * messages.
               */
              extension?: string;
              /**
               * Format: byte
               * @description Vote extension signature by the validator if they participated in
               * consensus for the associated block.
               * Only valid for precommit messages.
               */
              extension_signature?: string;
            };
            /** Format: int64 */
            total_voting_power?: string;
            /** Format: int64 */
            validator_power?: string;
            /** Format: date-time */
            timestamp?: string;
          };
          /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
          light_client_attack_evidence?: {
            conflicting_block?: {
              signed_header?: {
                /** @description Header defines the structure of a block header. */
                header?: {
                  /**
                   * basic block info
                   * @description Consensus captures the consensus rules for processing a block in the blockchain,
                   * including all blockchain data structures and the rules of the application's
                   * state transition machine.
                   */
                  version?: {
                    /** Format: uint64 */
                    block?: string;
                    /** Format: uint64 */
                    app?: string;
                  };
                  chain_id?: string;
                  /** Format: int64 */
                  height?: string;
                  /** Format: date-time */
                  time?: string;
                  /** BlockID */
                  last_block_id?: {
                    /** Format: byte */
                    hash?: string;
                    /** PartsetHeader */
                    part_set_header?: {
                      /** Format: int64 */
                      total?: number;
                      /** Format: byte */
                      hash?: string;
                    };
                  };
                  /**
                   * hashes of block data
                   * Format: byte
                   */
                  last_commit_hash?: string;
                  /** Format: byte */
                  data_hash?: string;
                  /**
                   * hashes from the app output from the prev block
                   * Format: byte
                   */
                  validators_hash?: string;
                  /** Format: byte */
                  next_validators_hash?: string;
                  /** Format: byte */
                  consensus_hash?: string;
                  /** Format: byte */
                  app_hash?: string;
                  /** Format: byte */
                  last_results_hash?: string;
                  /**
                   * consensus info
                   * Format: byte
                   */
                  evidence_hash?: string;
                  /** Format: byte */
                  proposer_address?: string;
                };
                /** @description Commit contains the evidence that a block was committed by a set of validators. */
                commit?: {
                  /** Format: int64 */
                  height?: string;
                  /** Format: int32 */
                  round?: number;
                  /** BlockID */
                  block_id?: {
                    /** Format: byte */
                    hash?: string;
                    /** PartsetHeader */
                    part_set_header?: {
                      /** Format: int64 */
                      total?: number;
                      /** Format: byte */
                      hash?: string;
                    };
                  };
                  signatures?: {
                    /**
                     * BlockIdFlag indicates which BlockID the signature is for
                     * @default BLOCK_ID_FLAG_UNKNOWN
                     * @enum {string}
                     */
                    block_id_flag?:
                      | "BLOCK_ID_FLAG_UNKNOWN"
                      | "BLOCK_ID_FLAG_ABSENT"
                      | "BLOCK_ID_FLAG_COMMIT"
                      | "BLOCK_ID_FLAG_NIL";
                    /** Format: byte */
                    validator_address?: string;
                    /** Format: date-time */
                    timestamp?: string;
                    /** Format: byte */
                    signature?: string;
                  }[];
                };
              };
              validator_set?: {
                validators?: {
                  /** Format: byte */
                  address?: string;
                  /** PublicKey defines the keys available for use with Validators */
                  pub_key?: {
                    /** Format: byte */
                    ed25519?: string;
                    /** Format: byte */
                    secp256k1?: string;
                  };
                  /** Format: int64 */
                  voting_power?: string;
                  /** Format: int64 */
                  proposer_priority?: string;
                }[];
                proposer?: {
                  /** Format: byte */
                  address?: string;
                  /** PublicKey defines the keys available for use with Validators */
                  pub_key?: {
                    /** Format: byte */
                    ed25519?: string;
                    /** Format: byte */
                    secp256k1?: string;
                  };
                  /** Format: int64 */
                  voting_power?: string;
                  /** Format: int64 */
                  proposer_priority?: string;
                };
                /** Format: int64 */
                total_voting_power?: string;
              };
            };
            /** Format: int64 */
            common_height?: string;
            byzantine_validators?: {
              /** Format: byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** Format: byte */
                ed25519?: string;
                /** Format: byte */
                secp256k1?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            /** Format: int64 */
            total_voting_power?: string;
            /** Format: date-time */
            timestamp?: string;
          };
        }[];
      };
      /** @description Commit contains the evidence that a block was committed by a set of validators. */
      last_commit?: {
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        signatures?: {
          /**
           * BlockIdFlag indicates which BlockID the signature is for
           * @default BLOCK_ID_FLAG_UNKNOWN
           * @enum {string}
           */
          block_id_flag?:
            | "BLOCK_ID_FLAG_UNKNOWN"
            | "BLOCK_ID_FLAG_ABSENT"
            | "BLOCK_ID_FLAG_COMMIT"
            | "BLOCK_ID_FLAG_NIL";
          /** Format: byte */
          validator_address?: string;
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          signature?: string;
        }[];
      };
    };
    /**
     * BlockIdFlag indicates which BlockID the signature is for
     * @default BLOCK_ID_FLAG_UNKNOWN
     * @enum {string}
     */
    "tendermint.types.BlockIDFlag":
      | "BLOCK_ID_FLAG_UNKNOWN"
      | "BLOCK_ID_FLAG_ABSENT"
      | "BLOCK_ID_FLAG_COMMIT"
      | "BLOCK_ID_FLAG_NIL";
    /** @description Commit contains the evidence that a block was committed by a set of validators. */
    "tendermint.types.Commit": {
      /** Format: int64 */
      height?: string;
      /** Format: int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      signatures?: {
        /**
         * BlockIdFlag indicates which BlockID the signature is for
         * @default BLOCK_ID_FLAG_UNKNOWN
         * @enum {string}
         */
        block_id_flag?:
          | "BLOCK_ID_FLAG_UNKNOWN"
          | "BLOCK_ID_FLAG_ABSENT"
          | "BLOCK_ID_FLAG_COMMIT"
          | "BLOCK_ID_FLAG_NIL";
        /** Format: byte */
        validator_address?: string;
        /** Format: date-time */
        timestamp?: string;
        /** Format: byte */
        signature?: string;
      }[];
    };
    /** @description CommitSig is a part of the Vote included in a Commit. */
    "tendermint.types.CommitSig": {
      /**
       * BlockIdFlag indicates which BlockID the signature is for
       * @default BLOCK_ID_FLAG_UNKNOWN
       * @enum {string}
       */
      block_id_flag?:
        | "BLOCK_ID_FLAG_UNKNOWN"
        | "BLOCK_ID_FLAG_ABSENT"
        | "BLOCK_ID_FLAG_COMMIT"
        | "BLOCK_ID_FLAG_NIL";
      /** Format: byte */
      validator_address?: string;
      /** Format: date-time */
      timestamp?: string;
      /** Format: byte */
      signature?: string;
    };
    /** Data contains the set of transactions included in the block */
    "tendermint.types.Data": {
      /**
       * @description Txs that will be applied by state @ block.Height+1.
       * NOTE: not all txs here are valid.  We're just agreeing on the order first.
       * This means that block.AppHash does not include these txs.
       */
      txs?: string[];
    };
    /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
    "tendermint.types.DuplicateVoteEvidence": {
      /**
       * @description Vote represents a prevote or precommit vote from validators for
       * consensus.
       */
      vote_a?: {
        /**
         * @description SignedMsgType is a type of signed message in the consensus.
         *
         *  - SIGNED_MSG_TYPE_PREVOTE: Votes
         *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
         * @default SIGNED_MSG_TYPE_UNKNOWN
         * @enum {string}
         */
        type?:
          | "SIGNED_MSG_TYPE_UNKNOWN"
          | "SIGNED_MSG_TYPE_PREVOTE"
          | "SIGNED_MSG_TYPE_PRECOMMIT"
          | "SIGNED_MSG_TYPE_PROPOSAL";
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /** Format: date-time */
        timestamp?: string;
        /** Format: byte */
        validator_address?: string;
        /** Format: int32 */
        validator_index?: number;
        /**
         * Format: byte
         * @description Vote signature by the validator if they participated in consensus for the
         * associated block.
         */
        signature?: string;
        /**
         * Format: byte
         * @description Vote extension provided by the application. Only valid for precommit
         * messages.
         */
        extension?: string;
        /**
         * Format: byte
         * @description Vote extension signature by the validator if they participated in
         * consensus for the associated block.
         * Only valid for precommit messages.
         */
        extension_signature?: string;
      };
      /**
       * @description Vote represents a prevote or precommit vote from validators for
       * consensus.
       */
      vote_b?: {
        /**
         * @description SignedMsgType is a type of signed message in the consensus.
         *
         *  - SIGNED_MSG_TYPE_PREVOTE: Votes
         *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
         * @default SIGNED_MSG_TYPE_UNKNOWN
         * @enum {string}
         */
        type?:
          | "SIGNED_MSG_TYPE_UNKNOWN"
          | "SIGNED_MSG_TYPE_PREVOTE"
          | "SIGNED_MSG_TYPE_PRECOMMIT"
          | "SIGNED_MSG_TYPE_PROPOSAL";
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /** Format: date-time */
        timestamp?: string;
        /** Format: byte */
        validator_address?: string;
        /** Format: int32 */
        validator_index?: number;
        /**
         * Format: byte
         * @description Vote signature by the validator if they participated in consensus for the
         * associated block.
         */
        signature?: string;
        /**
         * Format: byte
         * @description Vote extension provided by the application. Only valid for precommit
         * messages.
         */
        extension?: string;
        /**
         * Format: byte
         * @description Vote extension signature by the validator if they participated in
         * consensus for the associated block.
         * Only valid for precommit messages.
         */
        extension_signature?: string;
      };
      /** Format: int64 */
      total_voting_power?: string;
      /** Format: int64 */
      validator_power?: string;
      /** Format: date-time */
      timestamp?: string;
    };
    "tendermint.types.Evidence": {
      /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
      duplicate_vote_evidence?: {
        /**
         * @description Vote represents a prevote or precommit vote from validators for
         * consensus.
         */
        vote_a?: {
          /**
           * @description SignedMsgType is a type of signed message in the consensus.
           *
           *  - SIGNED_MSG_TYPE_PREVOTE: Votes
           *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default SIGNED_MSG_TYPE_UNKNOWN
           * @enum {string}
           */
          type?:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          validator_address?: string;
          /** Format: int32 */
          validator_index?: number;
          /**
           * Format: byte
           * @description Vote signature by the validator if they participated in consensus for the
           * associated block.
           */
          signature?: string;
          /**
           * Format: byte
           * @description Vote extension provided by the application. Only valid for precommit
           * messages.
           */
          extension?: string;
          /**
           * Format: byte
           * @description Vote extension signature by the validator if they participated in
           * consensus for the associated block.
           * Only valid for precommit messages.
           */
          extension_signature?: string;
        };
        /**
         * @description Vote represents a prevote or precommit vote from validators for
         * consensus.
         */
        vote_b?: {
          /**
           * @description SignedMsgType is a type of signed message in the consensus.
           *
           *  - SIGNED_MSG_TYPE_PREVOTE: Votes
           *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
           * @default SIGNED_MSG_TYPE_UNKNOWN
           * @enum {string}
           */
          type?:
            | "SIGNED_MSG_TYPE_UNKNOWN"
            | "SIGNED_MSG_TYPE_PREVOTE"
            | "SIGNED_MSG_TYPE_PRECOMMIT"
            | "SIGNED_MSG_TYPE_PROPOSAL";
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          validator_address?: string;
          /** Format: int32 */
          validator_index?: number;
          /**
           * Format: byte
           * @description Vote signature by the validator if they participated in consensus for the
           * associated block.
           */
          signature?: string;
          /**
           * Format: byte
           * @description Vote extension provided by the application. Only valid for precommit
           * messages.
           */
          extension?: string;
          /**
           * Format: byte
           * @description Vote extension signature by the validator if they participated in
           * consensus for the associated block.
           * Only valid for precommit messages.
           */
          extension_signature?: string;
        };
        /** Format: int64 */
        total_voting_power?: string;
        /** Format: int64 */
        validator_power?: string;
        /** Format: date-time */
        timestamp?: string;
      };
      /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
      light_client_attack_evidence?: {
        conflicting_block?: {
          signed_header?: {
            /** @description Header defines the structure of a block header. */
            header?: {
              /**
               * basic block info
               * @description Consensus captures the consensus rules for processing a block in the blockchain,
               * including all blockchain data structures and the rules of the application's
               * state transition machine.
               */
              version?: {
                /** Format: uint64 */
                block?: string;
                /** Format: uint64 */
                app?: string;
              };
              chain_id?: string;
              /** Format: int64 */
              height?: string;
              /** Format: date-time */
              time?: string;
              /** BlockID */
              last_block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /**
               * hashes of block data
               * Format: byte
               */
              last_commit_hash?: string;
              /** Format: byte */
              data_hash?: string;
              /**
               * hashes from the app output from the prev block
               * Format: byte
               */
              validators_hash?: string;
              /** Format: byte */
              next_validators_hash?: string;
              /** Format: byte */
              consensus_hash?: string;
              /** Format: byte */
              app_hash?: string;
              /** Format: byte */
              last_results_hash?: string;
              /**
               * consensus info
               * Format: byte
               */
              evidence_hash?: string;
              /** Format: byte */
              proposer_address?: string;
            };
            /** @description Commit contains the evidence that a block was committed by a set of validators. */
            commit?: {
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              signatures?: {
                /**
                 * BlockIdFlag indicates which BlockID the signature is for
                 * @default BLOCK_ID_FLAG_UNKNOWN
                 * @enum {string}
                 */
                block_id_flag?:
                  | "BLOCK_ID_FLAG_UNKNOWN"
                  | "BLOCK_ID_FLAG_ABSENT"
                  | "BLOCK_ID_FLAG_COMMIT"
                  | "BLOCK_ID_FLAG_NIL";
                /** Format: byte */
                validator_address?: string;
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                signature?: string;
              }[];
            };
          };
          validator_set?: {
            validators?: {
              /** Format: byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** Format: byte */
                ed25519?: string;
                /** Format: byte */
                secp256k1?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            proposer?: {
              /** Format: byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** Format: byte */
                ed25519?: string;
                /** Format: byte */
                secp256k1?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            };
            /** Format: int64 */
            total_voting_power?: string;
          };
        };
        /** Format: int64 */
        common_height?: string;
        byzantine_validators?: {
          /** Format: byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** Format: byte */
            ed25519?: string;
            /** Format: byte */
            secp256k1?: string;
          };
          /** Format: int64 */
          voting_power?: string;
          /** Format: int64 */
          proposer_priority?: string;
        }[];
        /** Format: int64 */
        total_voting_power?: string;
        /** Format: date-time */
        timestamp?: string;
      };
    };
    "tendermint.types.EvidenceList": {
      evidence?: {
        /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
        duplicate_vote_evidence?: {
          /**
           * @description Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_a?: {
            /**
             * @description SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default SIGNED_MSG_TYPE_UNKNOWN
             * @enum {string}
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** Format: int64 */
            height?: string;
            /** Format: int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            validator_address?: string;
            /** Format: int32 */
            validator_index?: number;
            /**
             * Format: byte
             * @description Vote signature by the validator if they participated in consensus for the
             * associated block.
             */
            signature?: string;
            /**
             * Format: byte
             * @description Vote extension provided by the application. Only valid for precommit
             * messages.
             */
            extension?: string;
            /**
             * Format: byte
             * @description Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             */
            extension_signature?: string;
          };
          /**
           * @description Vote represents a prevote or precommit vote from validators for
           * consensus.
           */
          vote_b?: {
            /**
             * @description SignedMsgType is a type of signed message in the consensus.
             *
             *  - SIGNED_MSG_TYPE_PREVOTE: Votes
             *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
             * @default SIGNED_MSG_TYPE_UNKNOWN
             * @enum {string}
             */
            type?:
              | "SIGNED_MSG_TYPE_UNKNOWN"
              | "SIGNED_MSG_TYPE_PREVOTE"
              | "SIGNED_MSG_TYPE_PRECOMMIT"
              | "SIGNED_MSG_TYPE_PROPOSAL";
            /** Format: int64 */
            height?: string;
            /** Format: int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            validator_address?: string;
            /** Format: int32 */
            validator_index?: number;
            /**
             * Format: byte
             * @description Vote signature by the validator if they participated in consensus for the
             * associated block.
             */
            signature?: string;
            /**
             * Format: byte
             * @description Vote extension provided by the application. Only valid for precommit
             * messages.
             */
            extension?: string;
            /**
             * Format: byte
             * @description Vote extension signature by the validator if they participated in
             * consensus for the associated block.
             * Only valid for precommit messages.
             */
            extension_signature?: string;
          };
          /** Format: int64 */
          total_voting_power?: string;
          /** Format: int64 */
          validator_power?: string;
          /** Format: date-time */
          timestamp?: string;
        };
        /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
        light_client_attack_evidence?: {
          conflicting_block?: {
            signed_header?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
            validator_set?: {
              validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              proposer?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
            };
          };
          /** Format: int64 */
          common_height?: string;
          byzantine_validators?: {
            /** Format: byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** Format: byte */
              ed25519?: string;
              /** Format: byte */
              secp256k1?: string;
            };
            /** Format: int64 */
            voting_power?: string;
            /** Format: int64 */
            proposer_priority?: string;
          }[];
          /** Format: int64 */
          total_voting_power?: string;
          /** Format: date-time */
          timestamp?: string;
        };
      }[];
    };
    "tendermint.types.LightBlock": {
      signed_header?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlockID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag?:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
      validator_set?: {
        validators?: {
          /** Format: byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** Format: byte */
            ed25519?: string;
            /** Format: byte */
            secp256k1?: string;
          };
          /** Format: int64 */
          voting_power?: string;
          /** Format: int64 */
          proposer_priority?: string;
        }[];
        proposer?: {
          /** Format: byte */
          address?: string;
          /** PublicKey defines the keys available for use with Validators */
          pub_key?: {
            /** Format: byte */
            ed25519?: string;
            /** Format: byte */
            secp256k1?: string;
          };
          /** Format: int64 */
          voting_power?: string;
          /** Format: int64 */
          proposer_priority?: string;
        };
        /** Format: int64 */
        total_voting_power?: string;
      };
    };
    /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
    "tendermint.types.LightClientAttackEvidence": {
      conflicting_block?: {
        signed_header?: {
          /** @description Header defines the structure of a block header. */
          header?: {
            /**
             * basic block info
             * @description Consensus captures the consensus rules for processing a block in the blockchain,
             * including all blockchain data structures and the rules of the application's
             * state transition machine.
             */
            version?: {
              /** Format: uint64 */
              block?: string;
              /** Format: uint64 */
              app?: string;
            };
            chain_id?: string;
            /** Format: int64 */
            height?: string;
            /** Format: date-time */
            time?: string;
            /** BlockID */
            last_block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /**
             * hashes of block data
             * Format: byte
             */
            last_commit_hash?: string;
            /** Format: byte */
            data_hash?: string;
            /**
             * hashes from the app output from the prev block
             * Format: byte
             */
            validators_hash?: string;
            /** Format: byte */
            next_validators_hash?: string;
            /** Format: byte */
            consensus_hash?: string;
            /** Format: byte */
            app_hash?: string;
            /** Format: byte */
            last_results_hash?: string;
            /**
             * consensus info
             * Format: byte
             */
            evidence_hash?: string;
            /** Format: byte */
            proposer_address?: string;
          };
          /** @description Commit contains the evidence that a block was committed by a set of validators. */
          commit?: {
            /** Format: int64 */
            height?: string;
            /** Format: int32 */
            round?: number;
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            signatures?: {
              /**
               * BlockIdFlag indicates which BlockID the signature is for
               * @default BLOCK_ID_FLAG_UNKNOWN
               * @enum {string}
               */
              block_id_flag?:
                | "BLOCK_ID_FLAG_UNKNOWN"
                | "BLOCK_ID_FLAG_ABSENT"
                | "BLOCK_ID_FLAG_COMMIT"
                | "BLOCK_ID_FLAG_NIL";
              /** Format: byte */
              validator_address?: string;
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              signature?: string;
            }[];
          };
        };
        validator_set?: {
          validators?: {
            /** Format: byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** Format: byte */
              ed25519?: string;
              /** Format: byte */
              secp256k1?: string;
            };
            /** Format: int64 */
            voting_power?: string;
            /** Format: int64 */
            proposer_priority?: string;
          }[];
          proposer?: {
            /** Format: byte */
            address?: string;
            /** PublicKey defines the keys available for use with Validators */
            pub_key?: {
              /** Format: byte */
              ed25519?: string;
              /** Format: byte */
              secp256k1?: string;
            };
            /** Format: int64 */
            voting_power?: string;
            /** Format: int64 */
            proposer_priority?: string;
          };
          /** Format: int64 */
          total_voting_power?: string;
        };
      };
      /** Format: int64 */
      common_height?: string;
      byzantine_validators?: {
        /** Format: byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** Format: byte */
          ed25519?: string;
          /** Format: byte */
          secp256k1?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      /** Format: int64 */
      total_voting_power?: string;
      /** Format: date-time */
      timestamp?: string;
    };
    "tendermint.types.SignedHeader": {
      /** @description Header defines the structure of a block header. */
      header?: {
        /**
         * basic block info
         * @description Consensus captures the consensus rules for processing a block in the blockchain,
         * including all blockchain data structures and the rules of the application's
         * state transition machine.
         */
        version?: {
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        chain_id?: string;
        /** Format: int64 */
        height?: string;
        /** Format: date-time */
        time?: string;
        /** BlockID */
        last_block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * Format: byte
         */
        last_commit_hash?: string;
        /** Format: byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * Format: byte
         */
        validators_hash?: string;
        /** Format: byte */
        next_validators_hash?: string;
        /** Format: byte */
        consensus_hash?: string;
        /** Format: byte */
        app_hash?: string;
        /** Format: byte */
        last_results_hash?: string;
        /**
         * consensus info
         * Format: byte
         */
        evidence_hash?: string;
        /** Format: byte */
        proposer_address?: string;
      };
      /** @description Commit contains the evidence that a block was committed by a set of validators. */
      commit?: {
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        signatures?: {
          /**
           * BlockIdFlag indicates which BlockID the signature is for
           * @default BLOCK_ID_FLAG_UNKNOWN
           * @enum {string}
           */
          block_id_flag?:
            | "BLOCK_ID_FLAG_UNKNOWN"
            | "BLOCK_ID_FLAG_ABSENT"
            | "BLOCK_ID_FLAG_COMMIT"
            | "BLOCK_ID_FLAG_NIL";
          /** Format: byte */
          validator_address?: string;
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          signature?: string;
        }[];
      };
    };
    /**
     * @description SignedMsgType is a type of signed message in the consensus.
     *
     *  - SIGNED_MSG_TYPE_PREVOTE: Votes
     *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
     * @default SIGNED_MSG_TYPE_UNKNOWN
     * @enum {string}
     */
    "tendermint.types.SignedMsgType":
      | "SIGNED_MSG_TYPE_UNKNOWN"
      | "SIGNED_MSG_TYPE_PREVOTE"
      | "SIGNED_MSG_TYPE_PRECOMMIT"
      | "SIGNED_MSG_TYPE_PROPOSAL";
    "tendermint.types.Validator": {
      /** Format: byte */
      address?: string;
      /** PublicKey defines the keys available for use with Validators */
      pub_key?: {
        /** Format: byte */
        ed25519?: string;
        /** Format: byte */
        secp256k1?: string;
      };
      /** Format: int64 */
      voting_power?: string;
      /** Format: int64 */
      proposer_priority?: string;
    };
    "tendermint.types.ValidatorSet": {
      validators?: {
        /** Format: byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** Format: byte */
          ed25519?: string;
          /** Format: byte */
          secp256k1?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      proposer?: {
        /** Format: byte */
        address?: string;
        /** PublicKey defines the keys available for use with Validators */
        pub_key?: {
          /** Format: byte */
          ed25519?: string;
          /** Format: byte */
          secp256k1?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      };
      /** Format: int64 */
      total_voting_power?: string;
    };
    /**
     * @description Vote represents a prevote or precommit vote from validators for
     * consensus.
     */
    "tendermint.types.Vote": {
      /**
       * @description SignedMsgType is a type of signed message in the consensus.
       *
       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
       * @default SIGNED_MSG_TYPE_UNKNOWN
       * @enum {string}
       */
      type?:
        | "SIGNED_MSG_TYPE_UNKNOWN"
        | "SIGNED_MSG_TYPE_PREVOTE"
        | "SIGNED_MSG_TYPE_PRECOMMIT"
        | "SIGNED_MSG_TYPE_PROPOSAL";
      /** Format: int64 */
      height?: string;
      /** Format: int32 */
      round?: number;
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      /** Format: date-time */
      timestamp?: string;
      /** Format: byte */
      validator_address?: string;
      /** Format: int32 */
      validator_index?: number;
      /**
       * Format: byte
       * @description Vote signature by the validator if they participated in consensus for the
       * associated block.
       */
      signature?: string;
      /**
       * Format: byte
       * @description Vote extension provided by the application. Only valid for precommit
       * messages.
       */
      extension?: string;
      /**
       * Format: byte
       * @description Vote extension signature by the validator if they participated in
       * consensus for the associated block.
       * Only valid for precommit messages.
       */
      extension_signature?: string;
    };
    /**
     * @description ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.
     *
     * Note: This type is a duplicate of the ResponseQuery proto type defined in
     * Tendermint.
     */
    "cosmos.base.tendermint.v1beta1.ABCIQueryResponse": {
      /** Format: int64 */
      code?: number;
      log?: string;
      info?: string;
      /** Format: int64 */
      index?: string;
      /** Format: byte */
      key?: string;
      /** Format: byte */
      value?: string;
      /**
       * @description ProofOps is Merkle proof defined by the list of ProofOps.
       *
       * Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
       */
      proof_ops?: {
        ops?: {
          type?: string;
          /** Format: byte */
          key?: string;
          /** Format: byte */
          data?: string;
        }[];
      };
      /** Format: int64 */
      height?: string;
      codespace?: string;
    };
    /**
     * @description Block is tendermint type Block, with the Header proposer address
     * field converted to bech32 string.
     */
    "cosmos.base.tendermint.v1beta1.Block": {
      /** @description Header defines the structure of a Tendermint block header. */
      header?: {
        /**
         * basic block info
         * @description Consensus captures the consensus rules for processing a block in the blockchain,
         * including all blockchain data structures and the rules of the application's
         * state transition machine.
         */
        version?: {
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        chain_id?: string;
        /** Format: int64 */
        height?: string;
        /** Format: date-time */
        time?: string;
        /** BlockID */
        last_block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        /**
         * hashes of block data
         * Format: byte
         */
        last_commit_hash?: string;
        /** Format: byte */
        data_hash?: string;
        /**
         * hashes from the app output from the prev block
         * Format: byte
         */
        validators_hash?: string;
        /** Format: byte */
        next_validators_hash?: string;
        /** Format: byte */
        consensus_hash?: string;
        /** Format: byte */
        app_hash?: string;
        /** Format: byte */
        last_results_hash?: string;
        /**
         * consensus info
         * Format: byte
         */
        evidence_hash?: string;
        /**
         * @description proposer_address is the original block proposer address, formatted as a Bech32 string.
         * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
         * for better UX.
         */
        proposer_address?: string;
      };
      /** Data contains the set of transactions included in the block */
      data?: {
        /**
         * @description Txs that will be applied by state @ block.Height+1.
         * NOTE: not all txs here are valid.  We're just agreeing on the order first.
         * This means that block.AppHash does not include these txs.
         */
        txs?: string[];
      };
      evidence?: {
        evidence?: {
          /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
          duplicate_vote_evidence?: {
            /**
             * @description Vote represents a prevote or precommit vote from validators for
             * consensus.
             */
            vote_a?: {
              /**
               * @description SignedMsgType is a type of signed message in the consensus.
               *
               *  - SIGNED_MSG_TYPE_PREVOTE: Votes
               *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
               * @default SIGNED_MSG_TYPE_UNKNOWN
               * @enum {string}
               */
              type?:
                | "SIGNED_MSG_TYPE_UNKNOWN"
                | "SIGNED_MSG_TYPE_PREVOTE"
                | "SIGNED_MSG_TYPE_PRECOMMIT"
                | "SIGNED_MSG_TYPE_PROPOSAL";
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              validator_address?: string;
              /** Format: int32 */
              validator_index?: number;
              /**
               * Format: byte
               * @description Vote signature by the validator if they participated in consensus for the
               * associated block.
               */
              signature?: string;
              /**
               * Format: byte
               * @description Vote extension provided by the application. Only valid for precommit
               * messages.
               */
              extension?: string;
              /**
               * Format: byte
               * @description Vote extension signature by the validator if they participated in
               * consensus for the associated block.
               * Only valid for precommit messages.
               */
              extension_signature?: string;
            };
            /**
             * @description Vote represents a prevote or precommit vote from validators for
             * consensus.
             */
            vote_b?: {
              /**
               * @description SignedMsgType is a type of signed message in the consensus.
               *
               *  - SIGNED_MSG_TYPE_PREVOTE: Votes
               *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
               * @default SIGNED_MSG_TYPE_UNKNOWN
               * @enum {string}
               */
              type?:
                | "SIGNED_MSG_TYPE_UNKNOWN"
                | "SIGNED_MSG_TYPE_PREVOTE"
                | "SIGNED_MSG_TYPE_PRECOMMIT"
                | "SIGNED_MSG_TYPE_PROPOSAL";
              /** Format: int64 */
              height?: string;
              /** Format: int32 */
              round?: number;
              /** BlockID */
              block_id?: {
                /** Format: byte */
                hash?: string;
                /** PartsetHeader */
                part_set_header?: {
                  /** Format: int64 */
                  total?: number;
                  /** Format: byte */
                  hash?: string;
                };
              };
              /** Format: date-time */
              timestamp?: string;
              /** Format: byte */
              validator_address?: string;
              /** Format: int32 */
              validator_index?: number;
              /**
               * Format: byte
               * @description Vote signature by the validator if they participated in consensus for the
               * associated block.
               */
              signature?: string;
              /**
               * Format: byte
               * @description Vote extension provided by the application. Only valid for precommit
               * messages.
               */
              extension?: string;
              /**
               * Format: byte
               * @description Vote extension signature by the validator if they participated in
               * consensus for the associated block.
               * Only valid for precommit messages.
               */
              extension_signature?: string;
            };
            /** Format: int64 */
            total_voting_power?: string;
            /** Format: int64 */
            validator_power?: string;
            /** Format: date-time */
            timestamp?: string;
          };
          /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
          light_client_attack_evidence?: {
            conflicting_block?: {
              signed_header?: {
                /** @description Header defines the structure of a block header. */
                header?: {
                  /**
                   * basic block info
                   * @description Consensus captures the consensus rules for processing a block in the blockchain,
                   * including all blockchain data structures and the rules of the application's
                   * state transition machine.
                   */
                  version?: {
                    /** Format: uint64 */
                    block?: string;
                    /** Format: uint64 */
                    app?: string;
                  };
                  chain_id?: string;
                  /** Format: int64 */
                  height?: string;
                  /** Format: date-time */
                  time?: string;
                  /** BlockID */
                  last_block_id?: {
                    /** Format: byte */
                    hash?: string;
                    /** PartsetHeader */
                    part_set_header?: {
                      /** Format: int64 */
                      total?: number;
                      /** Format: byte */
                      hash?: string;
                    };
                  };
                  /**
                   * hashes of block data
                   * Format: byte
                   */
                  last_commit_hash?: string;
                  /** Format: byte */
                  data_hash?: string;
                  /**
                   * hashes from the app output from the prev block
                   * Format: byte
                   */
                  validators_hash?: string;
                  /** Format: byte */
                  next_validators_hash?: string;
                  /** Format: byte */
                  consensus_hash?: string;
                  /** Format: byte */
                  app_hash?: string;
                  /** Format: byte */
                  last_results_hash?: string;
                  /**
                   * consensus info
                   * Format: byte
                   */
                  evidence_hash?: string;
                  /** Format: byte */
                  proposer_address?: string;
                };
                /** @description Commit contains the evidence that a block was committed by a set of validators. */
                commit?: {
                  /** Format: int64 */
                  height?: string;
                  /** Format: int32 */
                  round?: number;
                  /** BlockID */
                  block_id?: {
                    /** Format: byte */
                    hash?: string;
                    /** PartsetHeader */
                    part_set_header?: {
                      /** Format: int64 */
                      total?: number;
                      /** Format: byte */
                      hash?: string;
                    };
                  };
                  signatures?: {
                    /**
                     * BlockIdFlag indicates which BlockID the signature is for
                     * @default BLOCK_ID_FLAG_UNKNOWN
                     * @enum {string}
                     */
                    block_id_flag?:
                      | "BLOCK_ID_FLAG_UNKNOWN"
                      | "BLOCK_ID_FLAG_ABSENT"
                      | "BLOCK_ID_FLAG_COMMIT"
                      | "BLOCK_ID_FLAG_NIL";
                    /** Format: byte */
                    validator_address?: string;
                    /** Format: date-time */
                    timestamp?: string;
                    /** Format: byte */
                    signature?: string;
                  }[];
                };
              };
              validator_set?: {
                validators?: {
                  /** Format: byte */
                  address?: string;
                  /** PublicKey defines the keys available for use with Validators */
                  pub_key?: {
                    /** Format: byte */
                    ed25519?: string;
                    /** Format: byte */
                    secp256k1?: string;
                  };
                  /** Format: int64 */
                  voting_power?: string;
                  /** Format: int64 */
                  proposer_priority?: string;
                }[];
                proposer?: {
                  /** Format: byte */
                  address?: string;
                  /** PublicKey defines the keys available for use with Validators */
                  pub_key?: {
                    /** Format: byte */
                    ed25519?: string;
                    /** Format: byte */
                    secp256k1?: string;
                  };
                  /** Format: int64 */
                  voting_power?: string;
                  /** Format: int64 */
                  proposer_priority?: string;
                };
                /** Format: int64 */
                total_voting_power?: string;
              };
            };
            /** Format: int64 */
            common_height?: string;
            byzantine_validators?: {
              /** Format: byte */
              address?: string;
              /** PublicKey defines the keys available for use with Validators */
              pub_key?: {
                /** Format: byte */
                ed25519?: string;
                /** Format: byte */
                secp256k1?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            /** Format: int64 */
            total_voting_power?: string;
            /** Format: date-time */
            timestamp?: string;
          };
        }[];
      };
      /** @description Commit contains the evidence that a block was committed by a set of validators. */
      last_commit?: {
        /** Format: int64 */
        height?: string;
        /** Format: int32 */
        round?: number;
        /** BlockID */
        block_id?: {
          /** Format: byte */
          hash?: string;
          /** PartsetHeader */
          part_set_header?: {
            /** Format: int64 */
            total?: number;
            /** Format: byte */
            hash?: string;
          };
        };
        signatures?: {
          /**
           * BlockIdFlag indicates which BlockID the signature is for
           * @default BLOCK_ID_FLAG_UNKNOWN
           * @enum {string}
           */
          block_id_flag?:
            | "BLOCK_ID_FLAG_UNKNOWN"
            | "BLOCK_ID_FLAG_ABSENT"
            | "BLOCK_ID_FLAG_COMMIT"
            | "BLOCK_ID_FLAG_NIL";
          /** Format: byte */
          validator_address?: string;
          /** Format: date-time */
          timestamp?: string;
          /** Format: byte */
          signature?: string;
        }[];
      };
    };
    /** @description GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method. */
    "cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse": {
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      /** Deprecated: please use `sdk_block` instead */
      block?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /**
           * @description Txs that will be applied by state @ block.Height+1.
           * NOTE: not all txs here are valid.  We're just agreeing on the order first.
           * This means that block.AppHash does not include these txs.
           */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     * including all blockchain data structures and the rules of the application's
                     * state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlockID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag?:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlockID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag?:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
      /**
       * Since: cosmos-sdk 0.47
       * @description Block is tendermint type Block, with the Header proposer address
       * field converted to bech32 string.
       */
      sdk_block?: {
        /** @description Header defines the structure of a Tendermint block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /**
           * @description proposer_address is the original block proposer address, formatted as a Bech32 string.
           * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
           * for better UX.
           */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /**
           * @description Txs that will be applied by state @ block.Height+1.
           * NOTE: not all txs here are valid.  We're just agreeing on the order first.
           * This means that block.AppHash does not include these txs.
           */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     * including all blockchain data structures and the rules of the application's
                     * state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlockID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag?:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlockID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag?:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
    };
    /** @description GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method. */
    "cosmos.base.tendermint.v1beta1.GetLatestBlockResponse": {
      /** BlockID */
      block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      /** Deprecated: please use `sdk_block` instead */
      block?: {
        /** @description Header defines the structure of a block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /** Format: byte */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /**
           * @description Txs that will be applied by state @ block.Height+1.
           * NOTE: not all txs here are valid.  We're just agreeing on the order first.
           * This means that block.AppHash does not include these txs.
           */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     * including all blockchain data structures and the rules of the application's
                     * state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlockID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag?:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlockID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag?:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
      /**
       * Since: cosmos-sdk 0.47
       * @description Block is tendermint type Block, with the Header proposer address
       * field converted to bech32 string.
       */
      sdk_block?: {
        /** @description Header defines the structure of a Tendermint block header. */
        header?: {
          /**
           * basic block info
           * @description Consensus captures the consensus rules for processing a block in the blockchain,
           * including all blockchain data structures and the rules of the application's
           * state transition machine.
           */
          version?: {
            /** Format: uint64 */
            block?: string;
            /** Format: uint64 */
            app?: string;
          };
          chain_id?: string;
          /** Format: int64 */
          height?: string;
          /** Format: date-time */
          time?: string;
          /** BlockID */
          last_block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          /**
           * hashes of block data
           * Format: byte
           */
          last_commit_hash?: string;
          /** Format: byte */
          data_hash?: string;
          /**
           * hashes from the app output from the prev block
           * Format: byte
           */
          validators_hash?: string;
          /** Format: byte */
          next_validators_hash?: string;
          /** Format: byte */
          consensus_hash?: string;
          /** Format: byte */
          app_hash?: string;
          /** Format: byte */
          last_results_hash?: string;
          /**
           * consensus info
           * Format: byte
           */
          evidence_hash?: string;
          /**
           * @description proposer_address is the original block proposer address, formatted as a Bech32 string.
           * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
           * for better UX.
           */
          proposer_address?: string;
        };
        /** Data contains the set of transactions included in the block */
        data?: {
          /**
           * @description Txs that will be applied by state @ block.Height+1.
           * NOTE: not all txs here are valid.  We're just agreeing on the order first.
           * This means that block.AppHash does not include these txs.
           */
          txs?: string[];
        };
        evidence?: {
          evidence?: {
            /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
            duplicate_vote_evidence?: {
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_a?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /**
               * @description Vote represents a prevote or precommit vote from validators for
               * consensus.
               */
              vote_b?: {
                /**
                 * @description SignedMsgType is a type of signed message in the consensus.
                 *
                 *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                 *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                 * @default SIGNED_MSG_TYPE_UNKNOWN
                 * @enum {string}
                 */
                type?:
                  | "SIGNED_MSG_TYPE_UNKNOWN"
                  | "SIGNED_MSG_TYPE_PREVOTE"
                  | "SIGNED_MSG_TYPE_PRECOMMIT"
                  | "SIGNED_MSG_TYPE_PROPOSAL";
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /** Format: date-time */
                timestamp?: string;
                /** Format: byte */
                validator_address?: string;
                /** Format: int32 */
                validator_index?: number;
                /**
                 * Format: byte
                 * @description Vote signature by the validator if they participated in consensus for the
                 * associated block.
                 */
                signature?: string;
                /**
                 * Format: byte
                 * @description Vote extension provided by the application. Only valid for precommit
                 * messages.
                 */
                extension?: string;
                /**
                 * Format: byte
                 * @description Vote extension signature by the validator if they participated in
                 * consensus for the associated block.
                 * Only valid for precommit messages.
                 */
                extension_signature?: string;
              };
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: int64 */
              validator_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
            /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
            light_client_attack_evidence?: {
              conflicting_block?: {
                signed_header?: {
                  /** @description Header defines the structure of a block header. */
                  header?: {
                    /**
                     * basic block info
                     * @description Consensus captures the consensus rules for processing a block in the blockchain,
                     * including all blockchain data structures and the rules of the application's
                     * state transition machine.
                     */
                    version?: {
                      /** Format: uint64 */
                      block?: string;
                      /** Format: uint64 */
                      app?: string;
                    };
                    chain_id?: string;
                    /** Format: int64 */
                    height?: string;
                    /** Format: date-time */
                    time?: string;
                    /** BlockID */
                    last_block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    /**
                     * hashes of block data
                     * Format: byte
                     */
                    last_commit_hash?: string;
                    /** Format: byte */
                    data_hash?: string;
                    /**
                     * hashes from the app output from the prev block
                     * Format: byte
                     */
                    validators_hash?: string;
                    /** Format: byte */
                    next_validators_hash?: string;
                    /** Format: byte */
                    consensus_hash?: string;
                    /** Format: byte */
                    app_hash?: string;
                    /** Format: byte */
                    last_results_hash?: string;
                    /**
                     * consensus info
                     * Format: byte
                     */
                    evidence_hash?: string;
                    /** Format: byte */
                    proposer_address?: string;
                  };
                  /** @description Commit contains the evidence that a block was committed by a set of validators. */
                  commit?: {
                    /** Format: int64 */
                    height?: string;
                    /** Format: int32 */
                    round?: number;
                    /** BlockID */
                    block_id?: {
                      /** Format: byte */
                      hash?: string;
                      /** PartsetHeader */
                      part_set_header?: {
                        /** Format: int64 */
                        total?: number;
                        /** Format: byte */
                        hash?: string;
                      };
                    };
                    signatures?: {
                      /**
                       * BlockIdFlag indicates which BlockID the signature is for
                       * @default BLOCK_ID_FLAG_UNKNOWN
                       * @enum {string}
                       */
                      block_id_flag?:
                        | "BLOCK_ID_FLAG_UNKNOWN"
                        | "BLOCK_ID_FLAG_ABSENT"
                        | "BLOCK_ID_FLAG_COMMIT"
                        | "BLOCK_ID_FLAG_NIL";
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      signature?: string;
                    }[];
                  };
                };
                validator_set?: {
                  validators?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  }[];
                  proposer?: {
                    /** Format: byte */
                    address?: string;
                    /** PublicKey defines the keys available for use with Validators */
                    pub_key?: {
                      /** Format: byte */
                      ed25519?: string;
                      /** Format: byte */
                      secp256k1?: string;
                    };
                    /** Format: int64 */
                    voting_power?: string;
                    /** Format: int64 */
                    proposer_priority?: string;
                  };
                  /** Format: int64 */
                  total_voting_power?: string;
                };
              };
              /** Format: int64 */
              common_height?: string;
              byzantine_validators?: {
                /** Format: byte */
                address?: string;
                /** PublicKey defines the keys available for use with Validators */
                pub_key?: {
                  /** Format: byte */
                  ed25519?: string;
                  /** Format: byte */
                  secp256k1?: string;
                };
                /** Format: int64 */
                voting_power?: string;
                /** Format: int64 */
                proposer_priority?: string;
              }[];
              /** Format: int64 */
              total_voting_power?: string;
              /** Format: date-time */
              timestamp?: string;
            };
          }[];
        };
        /** @description Commit contains the evidence that a block was committed by a set of validators. */
        last_commit?: {
          /** Format: int64 */
          height?: string;
          /** Format: int32 */
          round?: number;
          /** BlockID */
          block_id?: {
            /** Format: byte */
            hash?: string;
            /** PartsetHeader */
            part_set_header?: {
              /** Format: int64 */
              total?: number;
              /** Format: byte */
              hash?: string;
            };
          };
          signatures?: {
            /**
             * BlockIdFlag indicates which BlockID the signature is for
             * @default BLOCK_ID_FLAG_UNKNOWN
             * @enum {string}
             */
            block_id_flag?:
              | "BLOCK_ID_FLAG_UNKNOWN"
              | "BLOCK_ID_FLAG_ABSENT"
              | "BLOCK_ID_FLAG_COMMIT"
              | "BLOCK_ID_FLAG_NIL";
            /** Format: byte */
            validator_address?: string;
            /** Format: date-time */
            timestamp?: string;
            /** Format: byte */
            signature?: string;
          }[];
        };
      };
    };
    /** @description GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
    "cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse": {
      /** Format: int64 */
      block_height?: string;
      validators?: {
        address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        pub_key?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method. */
    "cosmos.base.tendermint.v1beta1.GetNodeInfoResponse": {
      default_node_info?: {
        protocol_version?: {
          /** Format: uint64 */
          p2p?: string;
          /** Format: uint64 */
          block?: string;
          /** Format: uint64 */
          app?: string;
        };
        default_node_id?: string;
        listen_addr?: string;
        network?: string;
        version?: string;
        /** Format: byte */
        channels?: string;
        moniker?: string;
        other?: {
          tx_index?: string;
          rpc_address?: string;
        };
      };
      /** @description VersionInfo is the type for the GetNodeInfoResponse message. */
      application_version?: {
        name?: string;
        app_name?: string;
        version?: string;
        git_commit?: string;
        build_tags?: string;
        go_version?: string;
        build_deps?: {
          /** module path */
          path?: string;
          /** module version */
          version?: string;
          /** checksum */
          sum?: string;
        }[];
        /** Since: cosmos-sdk 0.43 */
        cosmos_sdk_version?: string;
      };
    };
    /** @description GetSyncingResponse is the response type for the Query/GetSyncing RPC method. */
    "cosmos.base.tendermint.v1beta1.GetSyncingResponse": {
      syncing?: boolean;
    };
    /** @description GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
    "cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse": {
      /** Format: int64 */
      block_height?: string;
      validators?: {
        address?: string;
        /**
         * @description `Any` contains an arbitrary serialized protocol buffer message along with a
         * URL that describes the type of the serialized message.
         *
         * Protobuf library provides support to pack/unpack Any values in the form
         * of utility functions or additional generated methods of the Any type.
         *
         * Example 1: Pack and unpack a message in C++.
         *
         *     Foo foo = ...;
         *     Any any;
         *     any.PackFrom(foo);
         *     ...
         *     if (any.UnpackTo(&foo)) {
         *       ...
         *     }
         *
         * Example 2: Pack and unpack a message in Java.
         *
         *     Foo foo = ...;
         *     Any any = Any.pack(foo);
         *     ...
         *     if (any.is(Foo.class)) {
         *       foo = any.unpack(Foo.class);
         *     }
         *
         * Example 3: Pack and unpack a message in Python.
         *
         *     foo = Foo(...)
         *     any = Any()
         *     any.Pack(foo)
         *     ...
         *     if any.Is(Foo.DESCRIPTOR):
         *       any.Unpack(foo)
         *       ...
         *
         * Example 4: Pack and unpack a message in Go
         *
         *      foo := &pb.Foo{...}
         *      any, err := anypb.New(foo)
         *      if err != nil {
         *        ...
         *      }
         *      ...
         *      foo := &pb.Foo{}
         *      if err := any.UnmarshalTo(foo); err != nil {
         *        ...
         *      }
         *
         * The pack methods provided by protobuf library will by default use
         * 'type.googleapis.com/full.type.name' as the type URL and the unpack
         * methods only use the fully qualified type name after the last '/'
         * in the type URL, for example "foo.bar.com/x/y.z" will yield type
         * name "y.z".
         *
         *
         * JSON
         *
         * The JSON representation of an `Any` value uses the regular
         * representation of the deserialized, embedded message, with an
         * additional field `@type` which contains the type URL. Example:
         *
         *     package google.profile;
         *     message Person {
         *       string first_name = 1;
         *       string last_name = 2;
         *     }
         *
         *     {
         *       "@type": "type.googleapis.com/google.profile.Person",
         *       "firstName": <string>,
         *       "lastName": <string>
         *     }
         *
         * If the embedded message type is well-known and has a custom JSON
         * representation, that representation will be embedded adding a field
         * `value` which holds the custom JSON in addition to the `@type`
         * field. Example (for message [google.protobuf.Duration][]):
         *
         *     {
         *       "@type": "type.googleapis.com/google.protobuf.Duration",
         *       "value": "1.212s"
         *     }
         */
        pub_key?: {
          /**
           * @description A URL/resource name that uniquely identifies the type of the serialized
           * protocol buffer message. This string must contain at least
           * one "/" character. The last segment of the URL's path must represent
           * the fully qualified name of the type (as in
           * `path/google.protobuf.Duration`). The name should be in a canonical form
           * (e.g., leading "." is not accepted).
           *
           * In practice, teams usually precompile into the binary all types that they
           * expect it to use in the context of Any. However, for URLs which use the
           * scheme `http`, `https`, or no scheme, one can optionally set up a type
           * server that maps type URLs to message definitions as follows:
           *
           * * If no scheme is provided, `https` is assumed.
           * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
           *   value in binary format, or produce an error.
           * * Applications are allowed to cache lookup results based on the
           *   URL, or have them precompiled into a binary to avoid any
           *   lookup. Therefore, binary compatibility needs to be preserved
           *   on changes to types. (Use versioned type names to manage
           *   breaking changes.)
           *
           * Note: this functionality is not currently available in the official
           * protobuf release, and it is not used for type URLs beginning with
           * type.googleapis.com.
           *
           * Schemes other than `http`, `https` (or the empty scheme) might be
           * used with implementation specific semantics.
           */
          type_url?: string;
          /**
           * Format: byte
           * @description Must be a valid serialized protocol buffer of the above specified type.
           */
          value?: string;
        };
        /** Format: int64 */
        voting_power?: string;
        /** Format: int64 */
        proposer_priority?: string;
      }[];
      /** @description pagination defines an pagination for the response. */
      pagination?: {
        /**
         * Format: byte
         * @description next_key is the key to be passed to PageRequest.key to
         * query the next page most efficiently. It will be empty if
         * there are no more results.
         */
        next_key?: string;
        /**
         * total is total number of results available if PageRequest.count_total
         * was set, its value is undefined otherwise
         * Format: uint64
         */
        total?: string;
      };
    };
    /** @description Header defines the structure of a Tendermint block header. */
    "cosmos.base.tendermint.v1beta1.Header": {
      /**
       * basic block info
       * @description Consensus captures the consensus rules for processing a block in the blockchain,
       * including all blockchain data structures and the rules of the application's
       * state transition machine.
       */
      version?: {
        /** Format: uint64 */
        block?: string;
        /** Format: uint64 */
        app?: string;
      };
      chain_id?: string;
      /** Format: int64 */
      height?: string;
      /** Format: date-time */
      time?: string;
      /** BlockID */
      last_block_id?: {
        /** Format: byte */
        hash?: string;
        /** PartsetHeader */
        part_set_header?: {
          /** Format: int64 */
          total?: number;
          /** Format: byte */
          hash?: string;
        };
      };
      /**
       * hashes of block data
       * Format: byte
       */
      last_commit_hash?: string;
      /** Format: byte */
      data_hash?: string;
      /**
       * hashes from the app output from the prev block
       * Format: byte
       */
      validators_hash?: string;
      /** Format: byte */
      next_validators_hash?: string;
      /** Format: byte */
      consensus_hash?: string;
      /** Format: byte */
      app_hash?: string;
      /** Format: byte */
      last_results_hash?: string;
      /**
       * consensus info
       * Format: byte
       */
      evidence_hash?: string;
      /**
       * @description proposer_address is the original block proposer address, formatted as a Bech32 string.
       * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
       * for better UX.
       */
      proposer_address?: string;
    };
    /** Module is the type for VersionInfo */
    "cosmos.base.tendermint.v1beta1.Module": {
      /** module path */
      path?: string;
      /** module version */
      version?: string;
      /** checksum */
      sum?: string;
    };
    /**
     * @description ProofOp defines an operation used for calculating Merkle root. The data could
     * be arbitrary format, providing necessary data for example neighbouring node
     * hash.
     *
     * Note: This type is a duplicate of the ProofOp proto type defined in Tendermint.
     */
    "cosmos.base.tendermint.v1beta1.ProofOp": {
      type?: string;
      /** Format: byte */
      key?: string;
      /** Format: byte */
      data?: string;
    };
    /**
     * @description ProofOps is Merkle proof defined by the list of ProofOps.
     *
     * Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
     */
    "cosmos.base.tendermint.v1beta1.ProofOps": {
      ops?: {
        type?: string;
        /** Format: byte */
        key?: string;
        /** Format: byte */
        data?: string;
      }[];
    };
    /** @description Validator is the type for the validator-set. */
    "cosmos.base.tendermint.v1beta1.Validator": {
      address?: string;
      /**
       * @description `Any` contains an arbitrary serialized protocol buffer message along with a
       * URL that describes the type of the serialized message.
       *
       * Protobuf library provides support to pack/unpack Any values in the form
       * of utility functions or additional generated methods of the Any type.
       *
       * Example 1: Pack and unpack a message in C++.
       *
       *     Foo foo = ...;
       *     Any any;
       *     any.PackFrom(foo);
       *     ...
       *     if (any.UnpackTo(&foo)) {
       *       ...
       *     }
       *
       * Example 2: Pack and unpack a message in Java.
       *
       *     Foo foo = ...;
       *     Any any = Any.pack(foo);
       *     ...
       *     if (any.is(Foo.class)) {
       *       foo = any.unpack(Foo.class);
       *     }
       *
       * Example 3: Pack and unpack a message in Python.
       *
       *     foo = Foo(...)
       *     any = Any()
       *     any.Pack(foo)
       *     ...
       *     if any.Is(Foo.DESCRIPTOR):
       *       any.Unpack(foo)
       *       ...
       *
       * Example 4: Pack and unpack a message in Go
       *
       *      foo := &pb.Foo{...}
       *      any, err := anypb.New(foo)
       *      if err != nil {
       *        ...
       *      }
       *      ...
       *      foo := &pb.Foo{}
       *      if err := any.UnmarshalTo(foo); err != nil {
       *        ...
       *      }
       *
       * The pack methods provided by protobuf library will by default use
       * 'type.googleapis.com/full.type.name' as the type URL and the unpack
       * methods only use the fully qualified type name after the last '/'
       * in the type URL, for example "foo.bar.com/x/y.z" will yield type
       * name "y.z".
       *
       *
       * JSON
       *
       * The JSON representation of an `Any` value uses the regular
       * representation of the deserialized, embedded message, with an
       * additional field `@type` which contains the type URL. Example:
       *
       *     package google.profile;
       *     message Person {
       *       string first_name = 1;
       *       string last_name = 2;
       *     }
       *
       *     {
       *       "@type": "type.googleapis.com/google.profile.Person",
       *       "firstName": <string>,
       *       "lastName": <string>
       *     }
       *
       * If the embedded message type is well-known and has a custom JSON
       * representation, that representation will be embedded adding a field
       * `value` which holds the custom JSON in addition to the `@type`
       * field. Example (for message [google.protobuf.Duration][]):
       *
       *     {
       *       "@type": "type.googleapis.com/google.protobuf.Duration",
       *       "value": "1.212s"
       *     }
       */
      pub_key?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        type_url?: string;
        /**
         * Format: byte
         * @description Must be a valid serialized protocol buffer of the above specified type.
         */
        value?: string;
      };
      /** Format: int64 */
      voting_power?: string;
      /** Format: int64 */
      proposer_priority?: string;
    };
    /** @description VersionInfo is the type for the GetNodeInfoResponse message. */
    "cosmos.base.tendermint.v1beta1.VersionInfo": {
      name?: string;
      app_name?: string;
      version?: string;
      git_commit?: string;
      build_tags?: string;
      go_version?: string;
      build_deps?: {
        /** module path */
        path?: string;
        /** module version */
        version?: string;
        /** checksum */
        sum?: string;
      }[];
      /** Since: cosmos-sdk 0.43 */
      cosmos_sdk_version?: string;
    };
    "tendermint.p2p.DefaultNodeInfo": {
      protocol_version?: {
        /** Format: uint64 */
        p2p?: string;
        /** Format: uint64 */
        block?: string;
        /** Format: uint64 */
        app?: string;
      };
      default_node_id?: string;
      listen_addr?: string;
      network?: string;
      version?: string;
      /** Format: byte */
      channels?: string;
      moniker?: string;
      other?: {
        tx_index?: string;
        rpc_address?: string;
      };
    };
    "tendermint.p2p.DefaultNodeInfoOther": {
      tx_index?: string;
      rpc_address?: string;
    };
    "tendermint.p2p.ProtocolVersion": {
      /** Format: uint64 */
      p2p?: string;
      /** Format: uint64 */
      block?: string;
      /** Format: uint64 */
      app?: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {
  /** ClaimsRecords returns all claims records */
  ClaimsRecords: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** claims defines all claims records */
            claims?: {
              /** address of claiming user in either bech32 or hex format */
              address?: string;
              /** initial_claimable_amount for the user */
              initial_claimable_amount?: string;
              /** actions_completed is a slice that describes which actions were completed */
              actions_completed?: boolean[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ClaimsRecord returns the claims record for a given address */
  ClaimsRecord: {
    parameters: {
      path: {
        /** @description address defines the user to query claims record for */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** initial_claimable_amount of the user */
            initial_claimable_amount?: string;
            /** claims of the user */
            claims?: {
              /**
               * action enum
               * @description Action defines the list of available actions to claim the airdrop tokens.
               *
               *  - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.
               *  - ACTION_VOTE: ACTION_VOTE defines a proposal vote.
               *  - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.
               *  - ACTION_EVM: ACTION_EVM defines an EVM transaction.
               *  - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.
               * @default ACTION_UNSPECIFIED
               * @enum {string}
               */
              action?:
                | "ACTION_UNSPECIFIED"
                | "ACTION_VOTE"
                | "ACTION_DELEGATE"
                | "ACTION_EVM"
                | "ACTION_IBC_TRANSFER";
              /** completed is true if the action has been completed */
              completed?: boolean;
              /** claimable_amount of tokens for the action. Zero if completed */
              claimable_amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params returns the claims module parameters */
  ClaimsParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /** enable_claims is the parameter to enable the claiming process */
              enable_claims?: boolean;
              /**
               * airdrop_start_time defines the timestamp of the airdrop start
               * Format: date-time
               */
              airdrop_start_time?: string;
              /** duration_until_decay of claimable tokens begin */
              duration_until_decay?: string;
              /** duration_of_decay for token claim decay period */
              duration_of_decay?: string;
              /** claims_denom is the denomination of the claimable coin */
              claims_denom?: string;
              /**
               * @description authorized_channels is the list of authorized channel identifiers that can perform address
               * attestations via IBC.
               */
              authorized_channels?: string[];
              /** evm_channels is the list of channel identifiers from EVM compatible chains */
              evm_channels?: string[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TotalUnclaimed queries the total unclaimed tokens from the airdrop */
  TotalUnclaimed: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** coins defines the unclaimed coins */
            coins?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** CurrentEpoch provide current epoch of specified identifier */
  CurrentEpoch: {
    parameters: {
      query?: {
        /** @description identifier of the current epoch. */
        identifier?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * current_epoch is the number of the current epoch
             * Format: int64
             */
            current_epoch?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** EpochInfos provide running epochInfos */
  EpochInfos: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** epochs is a slice of all EpochInfos */
            epochs?: {
              /** identifier of the epoch */
              identifier?: string;
              /**
               * start_time of the epoch
               * Format: date-time
               */
              start_time?: string;
              /** duration of the epoch */
              duration?: string;
              /**
               * current_epoch is the integer identifier of the epoch
               * Format: int64
               */
              current_epoch?: string;
              /**
               * current_epoch_start_time defines the timestamp of the start of the epoch
               * Format: date-time
               */
              current_epoch_start_time?: string;
              /** epoch_counting_started reflects if the counting for the epoch has started */
              epoch_counting_started?: boolean;
              /**
               * current_epoch_start_height of the epoch
               * Format: int64
               */
              current_epoch_start_height?: string;
            }[];
            /** @description pagination defines an optional pagination for the request. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params retrieves the erc20 module params */
  ERC20Params: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** params are the erc20 module parameters */
            params?: {
              /** @description enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens. */
              enable_erc20?: boolean;
              /**
               * @description enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos
               * Coin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address.
               */
              enable_evm_hook?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TokenPairs retrieves registered token pairs */
  TokenPairs: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** token_pairs is a slice of registered token pairs for the erc20 module */
            token_pairs?: {
              /** erc20_address is the hex address of ERC20 contract token */
              erc20_address?: string;
              /** denom defines the cosmos base denomination to be mapped to */
              denom?: string;
              /** enabled defines the token mapping enable status */
              enabled?: boolean;
              /**
               * contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)
               * @description Owner enumerates the ownership of a ERC20 contract.
               *
               *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
               *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
               *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
               * @default OWNER_UNSPECIFIED
               * @enum {string}
               */
              contract_owner?:
                | "OWNER_UNSPECIFIED"
                | "OWNER_MODULE"
                | "OWNER_EXTERNAL";
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TokenPair retrieves a registered token pair */
  TokenPair: {
    parameters: {
      path: {
        /**
         * @description token identifier can be either the hex contract address of the ERC20 or the
         * Cosmos base denomination
         */
        token: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * token_pairs returns the info about a registered token pair for the erc20 module
             * @description TokenPair defines an instance that records a pairing consisting of a native
             *  Cosmos Coin and an ERC20 token address.
             */
            token_pair?: {
              /** erc20_address is the hex address of ERC20 contract token */
              erc20_address?: string;
              /** denom defines the cosmos base denomination to be mapped to */
              denom?: string;
              /** enabled defines the token mapping enable status */
              enabled?: boolean;
              /**
               * contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)
               * @description Owner enumerates the ownership of a ERC20 contract.
               *
               *  - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.
               *  - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.
               *  - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.
               * @default OWNER_UNSPECIFIED
               * @enum {string}
               */
              contract_owner?:
                | "OWNER_UNSPECIFIED"
                | "OWNER_MODULE"
                | "OWNER_EXTERNAL";
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * AllocationMeters retrieves active allocation meters for a given
   * denomination
   */
  AllocationMeters: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** allocation_meters is a slice of all allocations */
            allocation_meters?: {
              denom?: string;
              amount?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** AllocationMeter retrieves a active gas meter */
  AllocationMeter: {
    parameters: {
      path: {
        /** @description denom is the coin denom to query an allocation meter for. */
        denom: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * allocation_meter defines the allocation of the queried denom
             * @description DecCoin defines a token with a denomination and a decimal amount.
             *
             * NOTE: The amount field is an Dec which implements the custom method
             * signatures required by gogoproto.
             */
            allocation_meter?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GasMeters retrieves active gas meters for a given contract */
  GasMeters: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description contract is the hex contract address of a incentivized smart contract */
        contract: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** gas_meters is a slice of the gas meters for an incentivized smart contract */
            gas_meters?: {
              /** contract is the hex address of the incentivized smart contract */
              contract?: string;
              /** participant address that interacts with the incentive */
              participant?: string;
              /**
               * cumulative_gas spent during the epoch
               * Format: uint64
               */
              cumulative_gas?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GasMeter retrieves a active gas meter */
  GasMeter: {
    parameters: {
      path: {
        /** @description contract is the hex contract address of a contract */
        contract: string;
        /** @description participant is the hex address of a user */
        participant: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * gas_meter is a gas meter for one participant on an incentivized smart contract
             * Format: uint64
             */
            gas_meter?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Incentives retrieves registered incentives */
  Incentives: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** incentives is a slice of all incentives */
            incentives?: {
              /** contract address of the smart contract to be incentivized */
              contract?: string;
              /** allocations is a slice of denoms and percentages of rewards to be allocated */
              allocations?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * epochs defines the number of remaining epochs for the incentive
               * Format: int64
               */
              epochs?: number;
              /**
               * start_time of the incentive distribution
               * Format: date-time
               */
              start_time?: string;
              /**
               * total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch
               * Format: uint64
               */
              total_gas?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Incentive retrieves a registered incentive */
  Incentive: {
    parameters: {
      path: {
        /** @description contract is the hex contract address of a incentivized smart contract */
        contract: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Incentive defines an instance that organizes distribution conditions for a
             * given smart contract
             */
            incentive?: {
              /** contract address of the smart contract to be incentivized */
              contract?: string;
              /** allocations is a slice of denoms and percentages of rewards to be allocated */
              allocations?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * epochs defines the number of remaining epochs for the incentive
               * Format: int64
               */
              epochs?: number;
              /**
               * start_time of the incentive distribution
               * Format: date-time
               */
              start_time?: string;
              /**
               * total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch
               * Format: uint64
               */
              total_gas?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params retrieves the incentives module params */
  IncentivesParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** params are the incentives module parameters */
            params?: {
              /** enable_incentives is the parameter to enable incentives */
              enable_incentives?: boolean;
              /** allocation_limit is the maximum percentage an incentive can allocate per denomination */
              allocation_limit?: string;
              /** incentives_epoch_identifier for the epochs module hooks */
              incentives_epoch_identifier?: string;
              /** reward_scaler is the scaling factor for capping rewards */
              reward_scaler?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * CirculatingSupply retrieves the total number of tokens that are in
   * circulation (i.e. excluding unvested tokens).
   */
  CirculatingSupply: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * circulating_supply is the total amount of coins in circulation
             * @description DecCoin defines a token with a denomination and a decimal amount.
             *
             * NOTE: The amount field is an Dec which implements the custom method
             * signatures required by gogoproto.
             */
            circulating_supply?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** EpochMintProvision retrieves current minting epoch provision value. */
  EpochMintProvision: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description epoch_mint_provision is the current minting per epoch provision value. */
            epoch_mint_provision?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** InflationRate retrieves the inflation rate of the current period. */
  InflationRate: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** inflation_rate by which the total supply increases within one period */
            inflation_rate?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params retrieves the total set of minting parameters. */
  InflationParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /** mint_denom specifies the type of coin to mint */
              mint_denom?: string;
              /** exponential_calculation takes in the variables to calculate exponential inflation */
              exponential_calculation?: {
                /** a defines the initial value */
                a?: string;
                /** r defines the reduction factor */
                r?: string;
                /** c defines the parameter for long term inflation */
                c?: string;
                /** bonding_target */
                bonding_target?: string;
                /** max_variance */
                max_variance?: string;
              };
              /** inflation_distribution of the minted denom */
              inflation_distribution?: {
                /**
                 * staking_rewards defines the proportion of the minted minted_denom that is
                 * to be allocated as staking rewards
                 */
                staking_rewards?: string;
                /**
                 * usage_incentives defines the proportion of the minted minted_denom that is
                 * to be allocated to the incentives module address
                 */
                usage_incentives?: string;
                /**
                 * community_pool defines the proportion of the minted minted_denom that is to
                 * be allocated to the community pool
                 */
                community_pool?: string;
              };
              /** enable_inflation is the parameter that enables inflation and halts increasing the skipped_epochs */
              enable_inflation?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Period retrieves current period. */
  Period: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Format: uint64
             * @description period is the current minting per epoch provision value.
             */
            period?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** SkippedEpochs retrieves the total number of skipped epochs. */
  SkippedEpochs: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Format: uint64
             * @description skipped_epochs is the number of epochs that the inflation module has been disabled.
             */
            skipped_epochs?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Balances retrieves the unvested, vested and locked tokens for a vesting account */
  Balances: {
    parameters: {
      path: {
        /** @description address of the clawback vesting account */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** locked defines the current amount of locked tokens */
            locked?: {
              denom?: string;
              amount?: string;
            }[];
            /** unvested defines the current amount of unvested tokens */
            unvested?: {
              denom?: string;
              amount?: string;
            }[];
            /** vested defines the current amount of vested tokens */
            vested?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params retrieves the total set of recovery parameters. */
  RecoveryParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Params holds parameters for the recovery module
             * @description params defines the parameters of the module.
             */
            params?: {
              /** enable_recovery IBC middleware */
              enable_recovery?: boolean;
              /** packet_timeout_duration is the duration added to timeout timestamp for balances recovered via IBC packets */
              packet_timeout_duration?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params retrieves the revenue module params */
  RevenueParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** params is the returned revenue parameter */
            params?: {
              /** enable_revenue defines a parameter to enable the revenue module */
              enable_revenue?: boolean;
              /**
               * developer_shares defines the proportion of the transaction fees to be
               * distributed to the registered contract owner
               */
              developer_shares?: string;
              /**
               * addr_derivation_cost_create defines the cost of address derivation for
               * verifying the contract deployer at fee registration
               * Format: uint64
               */
              addr_derivation_cost_create?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Revenues retrieves all registered revenues */
  Revenues: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** revenues is a slice of all stored Reveneue */
            revenues?: {
              /** contract_address is the hex address of a registered contract */
              contract_address?: string;
              /**
               * deployer_address is the bech32 address of message sender. It must be the same as the origin EOA
               * sending the transaction which deploys the contract
               */
              deployer_address?: string;
              /**
               * withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to
               * deployer_address
               */
              withdrawer_address?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Revenue retrieves a registered revenue for a given contract address */
  Revenue: {
    parameters: {
      path: {
        /** @description contract_address of a registered contract in hex format */
        contract_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Revenue defines an instance that organizes fee distribution conditions for
             * the owner of a given smart contract
             */
            revenue?: {
              /** contract_address is the hex address of a registered contract */
              contract_address?: string;
              /**
               * deployer_address is the bech32 address of message sender. It must be the same as the origin EOA
               * sending the transaction which deploys the contract
               */
              deployer_address?: string;
              /**
               * withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to
               * deployer_address
               */
              withdrawer_address?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DeployerRevenues retrieves all revenues that a given deployer has
   * registered
   */
  DeployerRevenues: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description deployer_address in bech32 format */
        deployer_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** contract_addresses is the slice of registered contract addresses for a deployer */
            contract_addresses?: string[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * WithdrawerRevenues retrieves all revenues with a given withdrawer
   * address
   */
  WithdrawerRevenues: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description withdrawer_address in bech32 format */
        withdrawer_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** contract_addresses is the slice of registered contract addresses for a withdrawer */
            contract_addresses?: string[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Account queries an Ethereum account. */
  Account: {
    parameters: {
      path: {
        /** @description address is the ethereum hex address to query the account for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description balance is the balance of the EVM denomination. */
            balance?: string;
            /** @description code_hash is the hex-formatted code bytes from the EOA. */
            code_hash?: string;
            /**
             * Format: uint64
             * @description nonce is the account's sequence number.
             */
            nonce?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * Balance queries the balance of a the EVM denomination for a single
   * EthAccount.
   */
  Balance: {
    parameters: {
      path: {
        /** @description address is the ethereum hex address to query the balance for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description balance is the balance of the EVM denomination. */
            balance?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * BaseFee queries the base fee of the parent block of the current block,
   * it's similar to feemarket module's method, but also checks london hardfork status.
   */
  BaseFee: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** base_fee is the EIP1559 base fee */
            base_fee?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Code queries the balance of all coins for a single account. */
  Code: {
    parameters: {
      path: {
        /** @description address is the ethereum hex address to query the code for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Format: byte
             * @description code represents the code bytes from an ethereum address.
             */
            code?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** CosmosAccount queries an Ethereum account's Cosmos Address. */
  CosmosAccount: {
    parameters: {
      path: {
        /** @description address is the ethereum hex address to query the account for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description cosmos_address is the cosmos address of the account. */
            cosmos_address?: string;
            /**
             * Format: uint64
             * @description sequence is the account's sequence number.
             */
            sequence?: string;
            /**
             * account_number is the account number
             * Format: uint64
             */
            account_number?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** EstimateGas implements the `eth_estimateGas` rpc api */
  EstimateGas: {
    parameters: {
      query?: {
        /** @description args uses the same json format as the json rpc api. */
        args?: string;
        /** @description gas_cap defines the default gas cap to be used. */
        gas_cap?: string;
        /** @description proposer_address of the requested block in hex format. */
        proposer_address?: string;
        /** @description chain_id is the eip155 chain id parsed from the requested block header. */
        chain_id?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * gas returns the estimated gas
             * Format: uint64
             */
            gas?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** EthCall implements the `eth_call` rpc api */
  EthCall: {
    parameters: {
      query?: {
        /** @description args uses the same json format as the json rpc api. */
        args?: string;
        /** @description gas_cap defines the default gas cap to be used. */
        gas_cap?: string;
        /** @description proposer_address of the requested block in hex format. */
        proposer_address?: string;
        /** @description chain_id is the eip155 chain id parsed from the requested block header. */
        chain_id?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * hash of the ethereum transaction in hex format. This hash differs from the
             * Tendermint sha256 hash of the transaction bytes. See
             * https://github.com/tendermint/tendermint/issues/6539 for reference
             */
            hash?: string;
            /**
             * @description logs contains the transaction hash and the proto-compatible ethereum
             * logs.
             */
            logs?: {
              /** address of the contract that generated the event */
              address?: string;
              /** @description topics is a list of topics provided by the contract. */
              topics?: string[];
              /**
               * data which is supplied by the contract, usually ABI-encoded
               * Format: byte
               */
              data?: string;
              /**
               * block_number of the block in which the transaction was included
               * Format: uint64
               */
              block_number?: string;
              /** tx_hash is the transaction hash */
              tx_hash?: string;
              /**
               * tx_index of the transaction in the block
               * Format: uint64
               */
              tx_index?: string;
              /** block_hash of the block in which the transaction was included */
              block_hash?: string;
              /**
               * index of the log in the block
               * Format: uint64
               */
              index?: string;
              /**
               * @description removed is true if this log was reverted due to a chain
               * reorganisation. You must pay attention to this field if you receive logs
               * through a filter query.
               */
              removed?: boolean;
            }[];
            /**
             * ret is the returned data from evm function (result or data supplied with revert
             * opcode)
             * Format: byte
             */
            ret?: string;
            /** vm_error is the error returned by vm execution */
            vm_error?: string;
            /**
             * gas_used specifies how much gas was consumed by the transaction
             * Format: uint64
             */
            gas_used?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries the parameters of x/evm module. */
  EvmParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Params defines the EVM module parameters
             * @description params define the evm module parameters.
             */
            params?: {
              /**
               * @description evm_denom represents the token denomination used to run the EVM state
               * transitions.
               */
              evm_denom?: string;
              /** enable_create toggles state transitions that use the vm.Create function */
              enable_create?: boolean;
              /** enable_call toggles state transitions that use the vm.Call function */
              enable_call?: boolean;
              /** extra_eips defines the additional EIPs for the vm.Config */
              extra_eips?: string[];
              /**
               * chain_config defines the EVM chain configuration parameters
               * @description ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values
               * instead of *big.Int.
               */
              chain_config?: {
                /** homestead_block switch (nil no fork, 0 = already homestead) */
                homestead_block?: string;
                /** dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork) */
                dao_fork_block?: string;
                /** dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork */
                dao_fork_support?: boolean;
                /**
                 * eip150_block: EIP150 implements the Gas price changes
                 * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)
                 */
                eip150_block?: string;
                /** eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed) */
                eip150_hash?: string;
                /** eip155_block: EIP155Block HF block */
                eip155_block?: string;
                /** eip158_block: EIP158 HF block */
                eip158_block?: string;
                /** byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium) */
                byzantium_block?: string;
                /** constantinople_block: Constantinople switch block (nil no fork, 0 = already activated) */
                constantinople_block?: string;
                /** petersburg_block: Petersburg switch block (nil same as Constantinople) */
                petersburg_block?: string;
                /** istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul) */
                istanbul_block?: string;
                /** muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
                muir_glacier_block?: string;
                /** berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin) */
                berlin_block?: string;
                /** london_block: London switch block (nil = no fork, 0 = already on london) */
                london_block?: string;
                /** arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
                arrow_glacier_block?: string;
                /** gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated) */
                gray_glacier_block?: string;
                /** merge_netsplit_block: Virtual fork after The Merge to use as a network splitter */
                merge_netsplit_block?: string;
                /** shanghai_block switch block (nil = no fork, 0 = already on shanghai) */
                shanghai_block?: string;
                /** cancun_block switch block (nil = no fork, 0 = already on cancun) */
                cancun_block?: string;
              };
              /**
               * @description allow_unprotected_txs defines if replay-protected (i.e non EIP155
               * signed) transactions can be executed on the state machine.
               */
              allow_unprotected_txs?: boolean;
              /**
               * active_precompiles defines the slice of hex addresses of the precompiled
               * contracts that are active
               */
              active_precompiles?: string[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Storage queries the balance of all coins for a single account. */
  Storage: {
    parameters: {
      path: {
        /** @description address is the ethereum hex address to query the storage state for. */
        address: string;
        /** @description key defines the key of the storage state */
        key: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description value defines the storage state value hash associated with the given key. */
            value?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TraceBlock implements the `debug_traceBlockByNumber` and `debug_traceBlockByHash` rpc api */
  TraceBlock: {
    parameters: {
      query?: {
        /** @description tracer is a custom javascript tracer. */
        "trace_config.tracer"?: string;
        /**
         * @description timeout overrides the default timeout of 5 seconds for JavaScript-based tracing
         * calls.
         */
        "trace_config.timeout"?: string;
        /** @description reexec defines the number of blocks the tracer is willing to go back. */
        "trace_config.reexec"?: string;
        /** @description disable_stack switches stack capture. */
        "trace_config.disable_stack"?: boolean;
        /** @description disable_storage switches storage capture. */
        "trace_config.disable_storage"?: boolean;
        /** @description debug can be used to print output during capture end. */
        "trace_config.debug"?: boolean;
        /** @description limit defines the maximum length of output, but zero means unlimited. */
        "trace_config.limit"?: number;
        /** @description homestead_block switch (nil no fork, 0 = already homestead). */
        "trace_config.overrides.homestead_block"?: string;
        /** @description dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork). */
        "trace_config.overrides.dao_fork_block"?: string;
        /** @description dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork. */
        "trace_config.overrides.dao_fork_support"?: boolean;
        /**
         * @description eip150_block: EIP150 implements the Gas price changes
         * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).
         */
        "trace_config.overrides.eip150_block"?: string;
        /** @description eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed). */
        "trace_config.overrides.eip150_hash"?: string;
        /** @description eip155_block: EIP155Block HF block. */
        "trace_config.overrides.eip155_block"?: string;
        /** @description eip158_block: EIP158 HF block. */
        "trace_config.overrides.eip158_block"?: string;
        /** @description byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium). */
        "trace_config.overrides.byzantium_block"?: string;
        /** @description constantinople_block: Constantinople switch block (nil no fork, 0 = already activated). */
        "trace_config.overrides.constantinople_block"?: string;
        /** @description petersburg_block: Petersburg switch block (nil same as Constantinople). */
        "trace_config.overrides.petersburg_block"?: string;
        /** @description istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul). */
        "trace_config.overrides.istanbul_block"?: string;
        /** @description muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
        "trace_config.overrides.muir_glacier_block"?: string;
        /** @description berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin). */
        "trace_config.overrides.berlin_block"?: string;
        /** @description london_block: London switch block (nil = no fork, 0 = already on london). */
        "trace_config.overrides.london_block"?: string;
        /** @description arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
        "trace_config.overrides.arrow_glacier_block"?: string;
        /** @description gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated). */
        "trace_config.overrides.gray_glacier_block"?: string;
        /** @description merge_netsplit_block: Virtual fork after The Merge to use as a network splitter. */
        "trace_config.overrides.merge_netsplit_block"?: string;
        /** @description shanghai_block switch block (nil = no fork, 0 = already on shanghai). */
        "trace_config.overrides.shanghai_block"?: string;
        /** @description cancun_block switch block (nil = no fork, 0 = already on cancun). */
        "trace_config.overrides.cancun_block"?: string;
        /** @description enable_memory switches memory capture. */
        "trace_config.enable_memory"?: boolean;
        /** @description enable_return_data switches the capture of return data. */
        "trace_config.enable_return_data"?: boolean;
        /** @description tracer_json_config configures the tracer using a JSON string. */
        "trace_config.tracer_json_config"?: string;
        /** @description block_number of the traced block. */
        block_number?: string;
        /** @description block_hash (hex) of the traced block. */
        block_hash?: string;
        /** @description block_time of the traced block. */
        block_time?: string;
        /** @description proposer_address is the address of the requested block. */
        proposer_address?: string;
        /** @description chain_id is the eip155 chain id parsed from the requested block header. */
        chain_id?: string;
        /** @description block_max_gas of the traced block. */
        block_max_gas?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * data is the response serialized in bytes
             * Format: byte
             */
            data?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TraceTx implements the `debug_traceTransaction` rpc api */
  TraceTx: {
    parameters: {
      query?: {
        /**
         * @description A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         *   value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         *   URL, or have them precompiled into a binary to avoid any
         *   lookup. Therefore, binary compatibility needs to be preserved
         *   on changes to types. (Use versioned type names to manage
         *   breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        "msg.data.type_url"?: string;
        /** @description Must be a valid serialized protocol buffer of the above specified type. */
        "msg.data.value"?: string;
        /** @description size is the encoded storage size of the transaction (DEPRECATED). */
        "msg.size"?: number;
        /** @description hash of the transaction in hex format. */
        "msg.hash"?: string;
        /**
         * @description from is the ethereum signer address in hex format. This address value is checked
         * against the address derived from the signature (V, R, S) using the
         * secp256k1 elliptic curve.
         */
        "msg.from"?: string;
        /** @description tracer is a custom javascript tracer. */
        "trace_config.tracer"?: string;
        /**
         * @description timeout overrides the default timeout of 5 seconds for JavaScript-based tracing
         * calls.
         */
        "trace_config.timeout"?: string;
        /** @description reexec defines the number of blocks the tracer is willing to go back. */
        "trace_config.reexec"?: string;
        /** @description disable_stack switches stack capture. */
        "trace_config.disable_stack"?: boolean;
        /** @description disable_storage switches storage capture. */
        "trace_config.disable_storage"?: boolean;
        /** @description debug can be used to print output during capture end. */
        "trace_config.debug"?: boolean;
        /** @description limit defines the maximum length of output, but zero means unlimited. */
        "trace_config.limit"?: number;
        /** @description homestead_block switch (nil no fork, 0 = already homestead). */
        "trace_config.overrides.homestead_block"?: string;
        /** @description dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork). */
        "trace_config.overrides.dao_fork_block"?: string;
        /** @description dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork. */
        "trace_config.overrides.dao_fork_support"?: boolean;
        /**
         * @description eip150_block: EIP150 implements the Gas price changes
         * (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).
         */
        "trace_config.overrides.eip150_block"?: string;
        /** @description eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed). */
        "trace_config.overrides.eip150_hash"?: string;
        /** @description eip155_block: EIP155Block HF block. */
        "trace_config.overrides.eip155_block"?: string;
        /** @description eip158_block: EIP158 HF block. */
        "trace_config.overrides.eip158_block"?: string;
        /** @description byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium). */
        "trace_config.overrides.byzantium_block"?: string;
        /** @description constantinople_block: Constantinople switch block (nil no fork, 0 = already activated). */
        "trace_config.overrides.constantinople_block"?: string;
        /** @description petersburg_block: Petersburg switch block (nil same as Constantinople). */
        "trace_config.overrides.petersburg_block"?: string;
        /** @description istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul). */
        "trace_config.overrides.istanbul_block"?: string;
        /** @description muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
        "trace_config.overrides.muir_glacier_block"?: string;
        /** @description berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin). */
        "trace_config.overrides.berlin_block"?: string;
        /** @description london_block: London switch block (nil = no fork, 0 = already on london). */
        "trace_config.overrides.london_block"?: string;
        /** @description arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
        "trace_config.overrides.arrow_glacier_block"?: string;
        /** @description gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated). */
        "trace_config.overrides.gray_glacier_block"?: string;
        /** @description merge_netsplit_block: Virtual fork after The Merge to use as a network splitter. */
        "trace_config.overrides.merge_netsplit_block"?: string;
        /** @description shanghai_block switch block (nil = no fork, 0 = already on shanghai). */
        "trace_config.overrides.shanghai_block"?: string;
        /** @description cancun_block switch block (nil = no fork, 0 = already on cancun). */
        "trace_config.overrides.cancun_block"?: string;
        /** @description enable_memory switches memory capture. */
        "trace_config.enable_memory"?: boolean;
        /** @description enable_return_data switches the capture of return data. */
        "trace_config.enable_return_data"?: boolean;
        /** @description tracer_json_config configures the tracer using a JSON string. */
        "trace_config.tracer_json_config"?: string;
        /** @description block_number of requested transaction. */
        block_number?: string;
        /** @description block_hash of requested transaction. */
        block_hash?: string;
        /** @description block_time of requested transaction. */
        block_time?: string;
        /** @description proposer_address is the proposer of the requested block. */
        proposer_address?: string;
        /** @description chain_id is the the eip155 chain id parsed from the requested block header. */
        chain_id?: string;
        /** @description block_max_gas of the block of the requested transaction. */
        block_max_gas?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * data is the response serialized in bytes
             * Format: byte
             */
            data?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ValidatorAccount queries an Ethereum account's from a validator consensus
   * Address.
   */
  ValidatorAccount: {
    parameters: {
      path: {
        /** @description cons_address is the validator cons address to query the account for. */
        cons_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description account_address is the cosmos address of the account in bech32 format. */
            account_address?: string;
            /**
             * Format: uint64
             * @description sequence is the account's sequence number.
             */
            sequence?: string;
            /**
             * account_number is the account number
             * Format: uint64
             */
            account_number?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** BaseFee queries the base fee of the parent block of the current block. */
  FeeMarketBaseFee: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** base_fee is the EIP1559 base fee */
            base_fee?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** BlockGas queries the gas used at a given block height */
  BlockGas: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * gas is the returned block gas
             * Format: int64
             */
            gas?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries the parameters of x/feemarket module. */
  FeeMarketParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Params defines the EVM module parameters
             * @description params define the evm module parameters.
             */
            params?: {
              /** no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
              no_base_fee?: boolean;
              /**
               * Format: int64
               * @description base_fee_change_denominator bounds the amount the base fee can change
               * between blocks.
               */
              base_fee_change_denominator?: number;
              /**
               * Format: int64
               * @description elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may
               * have.
               */
              elasticity_multiplier?: number;
              /**
               * Format: int64
               * @description enable_height defines at which block height the base fee calculation is enabled.
               */
              enable_height?: string;
              /** @description base_fee for EIP-1559 blocks. */
              base_fee?: string;
              /** min_gas_price defines the minimum gas price value for cosmos and eth transactions */
              min_gas_price?: string;
              /**
               * min_gas_multiplier bounds the minimum gas used to be charged
               * to senders based on gas limit
               */
              min_gas_multiplier?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** EscrowAddress returns the escrow address for a particular port and channel id. */
  EscrowAddress: {
    parameters: {
      path: {
        /** @description unique channel identifier */
        channel_id: string;
        /** @description unique port identifier */
        port_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** the escrow account address */
            escrow_address?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DenomHash queries a denomination hash information. */
  DenomHash: {
    parameters: {
      path: {
        /** @description The denomination trace ([port_id]/[channel_id])+/[denom] */
        trace: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description hash (in hex format) of the denomination trace information. */
            hash?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DenomTraces queries all denomination traces. */
  DenomTraces: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description denom_traces returns all denominations trace information. */
            denom_traces?: {
              /**
               * @description path defines the chain of port/channel identifiers used for tracing the
               * source of the fungible token.
               */
              path?: string;
              /** @description base denomination of the relayed fungible token. */
              base_denom?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DenomTrace queries a denomination trace information. */
  DenomTrace: {
    parameters: {
      path: {
        /** @description hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information. */
        hash: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description DenomTrace contains the base denomination for ICS20 fungible tokens and the
             * source tracing information path.
             */
            denom_trace?: {
              /**
               * @description path defines the chain of port/channel identifiers used for tracing the
               * source of the fungible token.
               */
              path?: string;
              /** @description base denomination of the relayed fungible token. */
              base_denom?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom. */
  TotalEscrowForDenom: {
    parameters: {
      path: {
        denom: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            amount?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries all parameters of the ibc-transfer module. */
  TransferParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /**
               * @description send_enabled enables or disables all cross-chain token transfers from this
               * chain.
               */
              send_enabled?: boolean;
              /**
               * @description receive_enabled enables or disables all cross-chain token transfers to this
               * chain.
               */
              receive_enabled?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ClientStates queries all the IBC light clients of a chain. */
  ClientStates: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description list of stored ClientStates of the chain. */
            client_states?: {
              /** client identifier */
              client_id?: string;
              /**
               * client state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              client_state?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ClientState queries an IBC light client. */
  ClientState: {
    parameters: {
      path: {
        /** @description client state unique identifier */
        client_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * client state associated with the request identifier
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            client_state?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Status queries the status of an IBC client. */
  ClientStatus: {
    parameters: {
      path: {
        /** @description client unique identifier */
        client_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            status?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ConsensusStates queries all the consensus state associated with a given
   * client.
   */
  ConsensusStates: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description client identifier */
        client_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** consensus states associated with the identifier */
            consensus_states?: {
              /**
               * consensus state height
               * @description Normally the RevisionHeight is incremented at each height while keeping
               * RevisionNumber the same. However some consensus algorithms may choose to
               * reset the height in certain conditions e.g. hard forks, state-machine
               * breaking changes In these cases, the RevisionNumber is incremented so that
               * height continues to be monitonically increasing even as the RevisionHeight
               * gets reset
               */
              height?: {
                /**
                 * the revision that the client is currently on
                 * Format: uint64
                 */
                revision_number?: string;
                /**
                 * the height within the given revision
                 * Format: uint64
                 */
                revision_height?: string;
              };
              /**
               * consensus state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              consensus_state?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ConsensusStateHeights queries the height of every consensus states associated with a given client. */
  ConsensusStateHeights: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description client identifier */
        client_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** consensus state heights */
            consensus_state_heights?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ConsensusState queries a consensus state associated with a client state at
   * a given height.
   */
  ConsensusState: {
    parameters: {
      query?: {
        /**
         * @description latest_height overrrides the height field and queries the latest stored
         * ConsensusState.
         */
        latest_height?: boolean;
      };
      path: {
        /** @description client identifier */
        client_id: string;
        /** @description consensus state revision number */
        revision_number: string;
        /** @description consensus state revision height */
        revision_height: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * consensus state associated with the client identifier at the given height
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_state?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * Height is a monotonically increasing data type
             * that can be compared against another Height for the purposes of updating and
             * freezing clients
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ClientParams queries all parameters of the ibc client submodule. */
  ClientParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /**
               * @description allowed_clients defines the list of allowed client state types which can be created
               * and interacted with. If a client type is removed from the allowed clients list, usage
               * of this client will be disabled until it is added again to the list.
               */
              allowed_clients?: string[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** UpgradedClientState queries an Upgraded IBC light client. */
  UpgradedClientState: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * client state associated with the request identifier
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            upgraded_client_state?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** UpgradedConsensusState queries an Upgraded IBC consensus state. */
  UpgradedConsensusState: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Consensus state associated with the request identifier
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            upgraded_consensus_state?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ClientConnections queries the connection paths associated with a client
   * state.
   */
  ClientConnections: {
    parameters: {
      path: {
        /** @description client identifier associated with a connection */
        client_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description slice of all the connection paths associated with a client. */
            connection_paths?: string[];
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was generated
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Connections queries all the IBC connections of a chain. */
  Connections: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description list of stored connections of the chain. */
            connections?: {
              /** @description connection identifier. */
              id?: string;
              /** @description client associated with this connection. */
              client_id?: string;
              /**
               * IBC version which can be utilised to determine encodings or protocols for
               * channels or packets utilising this connection
               */
              versions?: {
                /** unique version identifier */
                identifier?: string;
                /** list of features compatible with the specified identifier */
                features?: string[];
              }[];
              /**
               * @description current state of the connection end.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state?:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN";
              /** @description counterparty chain associated with this connection. */
              counterparty?: {
                /**
                 * @description identifies the client on the counterparty chain associated with a given
                 * connection.
                 */
                client_id?: string;
                /**
                 * @description identifies the connection end on the counterparty chain associated with a
                 * given connection.
                 */
                connection_id?: string;
                /**
                 * MerklePrefix is merkle path prefixed to the key.
                 * The constructed key from the Path and the key will be append(Path.KeyPath,
                 * append(Path.KeyPrefix, key...))
                 * @description commitment merkle prefix of the counterparty chain.
                 */
                prefix?: {
                  /** Format: byte */
                  key_prefix?: string;
                };
              };
              /**
               * Format: uint64
               * @description delay period associated with this connection.
               */
              delay_period?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Connection queries an IBC connection end. */
  Connection: {
    parameters: {
      path: {
        /** @description connection unique identifier */
        connection_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * connection associated with the request identifier
             * @description ConnectionEnd defines a stateful object on a chain connected to another
             * separate one.
             * NOTE: there must only be 2 defined ConnectionEnds to establish
             * a connection between two chains.
             */
            connection?: {
              /** @description client associated with this connection. */
              client_id?: string;
              /**
               * @description IBC version which can be utilised to determine encodings or protocols for
               * channels or packets utilising this connection.
               */
              versions?: {
                /** unique version identifier */
                identifier?: string;
                /** list of features compatible with the specified identifier */
                features?: string[];
              }[];
              /**
               * @description current state of the connection end.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state?:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN";
              /** @description counterparty chain associated with this connection. */
              counterparty?: {
                /**
                 * @description identifies the client on the counterparty chain associated with a given
                 * connection.
                 */
                client_id?: string;
                /**
                 * @description identifies the connection end on the counterparty chain associated with a
                 * given connection.
                 */
                connection_id?: string;
                /**
                 * MerklePrefix is merkle path prefixed to the key.
                 * The constructed key from the Path and the key will be append(Path.KeyPath,
                 * append(Path.KeyPrefix, key...))
                 * @description commitment merkle prefix of the counterparty chain.
                 */
                prefix?: {
                  /** Format: byte */
                  key_prefix?: string;
                };
              };
              /**
               * Format: uint64
               * @description delay period that must pass before a consensus state can be used for
               * packet-verification NOTE: delay period logic is only implemented by some
               * clients.
               */
              delay_period?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ConnectionClientState queries the client state associated with the
   * connection.
   */
  ConnectionClientState: {
    parameters: {
      path: {
        /** @description connection identifier */
        connection_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * client state associated with the channel
             * @description IdentifiedClientState defines a client state with an additional client
             * identifier field.
             */
            identified_client_state?: {
              /** client identifier */
              client_id?: string;
              /**
               * client state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              client_state?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ConnectionConsensusState queries the consensus state associated with the
   * connection.
   */
  ConnectionConsensusState: {
    parameters: {
      path: {
        /** @description connection identifier */
        connection_id: string;
        revision_number: string;
        revision_height: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * consensus state associated with the channel
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_state?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /** client ID associated with the consensus state */
            client_id?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ConnectionParams queries all parameters of the ibc connection submodule. */
  ConnectionParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /**
               * Format: uint64
               * @description maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the
               * largest amount of time that the chain might reasonably take to produce the next block under normal operating
               * conditions. A safe choice is 3-5x the expected time per block.
               */
              max_expected_time_per_block?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Channels queries all the IBC channels of a chain. */
  Channels: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description list of stored channels of the chain. */
            channels?: {
              /**
               * current state of the channel end
               * @description State defines if a channel is in one of the following states:
               * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
               *
               *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
               *  - STATE_INIT: A channel has just started the opening handshake.
               *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
               *  - STATE_OPEN: A channel has completed the handshake. Open channels are
               * ready to send and receive packets.
               *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
               * packets.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state?:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN"
                | "STATE_CLOSED";
              /**
               * whether the channel is ordered or unordered
               * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
               *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
               * which they were sent.
               *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
               * @default ORDER_NONE_UNSPECIFIED
               * @enum {string}
               */
              ordering?:
                | "ORDER_NONE_UNSPECIFIED"
                | "ORDER_UNORDERED"
                | "ORDER_ORDERED";
              /** counterparty channel end */
              counterparty?: {
                /** @description port on the counterparty chain which owns the other end of the channel. */
                port_id?: string;
                /** channel end on the counterparty chain */
                channel_id?: string;
              };
              /**
               * list of connection identifiers, in order, along which packets sent on
               * this channel will travel
               */
              connection_hops?: string[];
              /** opaque channel version, which is agreed upon during the handshake */
              version?: string;
              /** port identifier */
              port_id?: string;
              /** channel identifier */
              channel_id?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Channel queries an IBC Channel. */
  Channel: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * channel associated with the request identifiers
             * @description Channel defines pipeline for exactly-once packet delivery between specific
             * modules on separate blockchains, which has at least one end capable of
             * sending packets and one end capable of receiving packets.
             */
            channel?: {
              /**
               * current state of the channel end
               * @description State defines if a channel is in one of the following states:
               * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
               *
               *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
               *  - STATE_INIT: A channel has just started the opening handshake.
               *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
               *  - STATE_OPEN: A channel has completed the handshake. Open channels are
               * ready to send and receive packets.
               *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
               * packets.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state?:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN"
                | "STATE_CLOSED";
              /**
               * whether the channel is ordered or unordered
               * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
               *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
               * which they were sent.
               *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
               * @default ORDER_NONE_UNSPECIFIED
               * @enum {string}
               */
              ordering?:
                | "ORDER_NONE_UNSPECIFIED"
                | "ORDER_UNORDERED"
                | "ORDER_ORDERED";
              /** counterparty channel end */
              counterparty?: {
                /** @description port on the counterparty chain which owns the other end of the channel. */
                port_id?: string;
                /** channel end on the counterparty chain */
                channel_id?: string;
              };
              /**
               * list of connection identifiers, in order, along which packets sent on
               * this channel will travel
               */
              connection_hops?: string[];
              /** opaque channel version, which is agreed upon during the handshake */
              version?: string;
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ChannelClientState queries for the client state for the channel associated
   * with the provided channel identifiers.
   */
  ChannelClientState: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * client state associated with the channel
             * @description IdentifiedClientState defines a client state with an additional client
             * identifier field.
             */
            identified_client_state?: {
              /** client identifier */
              client_id?: string;
              /**
               * client state
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              client_state?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ChannelConsensusState queries for the consensus state for the channel
   * associated with the provided channel identifiers.
   */
  ChannelConsensusState: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description revision number of the consensus state */
        revision_number: string;
        /** @description revision height of the consensus state */
        revision_height: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * consensus state associated with the channel
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            consensus_state?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
            /** client ID associated with the consensus state */
            client_id?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** NextSequenceReceive returns the next receive sequence for a given channel. */
  NextSequenceReceive: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * next sequence receive number
             * Format: uint64
             */
            next_sequence_receive?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** NextSequenceSend returns the next send sequence for a given channel. */
  NextSequenceSend: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * next sequence send number
             * Format: uint64
             */
            next_sequence_send?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * PacketAcknowledgements returns all the packet acknowledgements associated
   * with a channel.
   */
  PacketAcknowledgements: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /** @description list of packet sequences. */
        packet_commitment_sequences?: string[];
      };
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            acknowledgements?: {
              /** @description channel port identifier. */
              port_id?: string;
              /** @description channel unique identifier. */
              channel_id?: string;
              /**
               * Format: uint64
               * @description packet sequence.
               */
              sequence?: string;
              /**
               * Format: byte
               * @description embedded data that represents packet state.
               */
              data?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** PacketAcknowledgement queries a stored packet acknowledgement hash. */
  PacketAcknowledgement: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description packet sequence */
        sequence: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * packet associated with the request fields
             * Format: byte
             */
            acknowledgement?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * PacketCommitments returns all the packet commitments hashes associated
   * with a channel.
   */
  PacketCommitments: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            commitments?: {
              /** @description channel port identifier. */
              port_id?: string;
              /** @description channel unique identifier. */
              channel_id?: string;
              /**
               * Format: uint64
               * @description packet sequence.
               */
              sequence?: string;
              /**
               * Format: byte
               * @description embedded data that represents packet state.
               */
              data?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * UnreceivedAcks returns all the unreceived IBC acknowledgements associated
   * with a channel and sequences.
   */
  UnreceivedAcks: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description list of acknowledgement sequences */
        packet_ack_sequences: string[];
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** list of unreceived acknowledgement sequences */
            sequences?: string[];
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * UnreceivedPackets returns all the unreceived IBC packets associated with a
   * channel and sequences.
   */
  UnreceivedPackets: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description list of packet sequences */
        packet_commitment_sequences: string[];
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** list of unreceived packet sequences */
            sequences?: string[];
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** PacketCommitment queries a stored packet commitment hash. */
  PacketCommitment: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description packet sequence */
        sequence: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * packet associated with the request fields
             * Format: byte
             */
            commitment?: string;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * PacketReceipt queries if a given packet sequence has been received on the
   * queried chain
   */
  PacketReceipt: {
    parameters: {
      path: {
        /** @description channel unique identifier */
        channel_id: string;
        /** @description port unique identifier */
        port_id: string;
        /** @description packet sequence */
        sequence: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** success flag for if receipt exists */
            received?: boolean;
            /**
             * merkle proof of existence
             * Format: byte
             */
            proof?: string;
            /**
             * height at which the proof was retrieved
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            proof_height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ConnectionChannels queries all the channels associated with a connection
   * end.
   */
  ConnectionChannels: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description connection unique identifier */
        connection: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description list of channels associated with a connection. */
            channels?: {
              /**
               * current state of the channel end
               * @description State defines if a channel is in one of the following states:
               * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
               *
               *  - STATE_UNINITIALIZED_UNSPECIFIED: Default State
               *  - STATE_INIT: A channel has just started the opening handshake.
               *  - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.
               *  - STATE_OPEN: A channel has completed the handshake. Open channels are
               * ready to send and receive packets.
               *  - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive
               * packets.
               * @default STATE_UNINITIALIZED_UNSPECIFIED
               * @enum {string}
               */
              state?:
                | "STATE_UNINITIALIZED_UNSPECIFIED"
                | "STATE_INIT"
                | "STATE_TRYOPEN"
                | "STATE_OPEN"
                | "STATE_CLOSED";
              /**
               * whether the channel is ordered or unordered
               * @description - ORDER_NONE_UNSPECIFIED: zero-value for channel ordering
               *  - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in
               * which they were sent.
               *  - ORDER_ORDERED: packets are delivered exactly in the order which they were sent
               * @default ORDER_NONE_UNSPECIFIED
               * @enum {string}
               */
              ordering?:
                | "ORDER_NONE_UNSPECIFIED"
                | "ORDER_UNORDERED"
                | "ORDER_ORDERED";
              /** counterparty channel end */
              counterparty?: {
                /** @description port on the counterparty chain which owns the other end of the channel. */
                port_id?: string;
                /** channel end on the counterparty chain */
                channel_id?: string;
              };
              /**
               * list of connection identifiers, in order, along which packets sent on
               * this channel will travel
               */
              connection_hops?: string[];
              /** opaque channel version, which is agreed upon during the handshake */
              version?: string;
              /** port identifier */
              port_id?: string;
              /** channel identifier */
              channel_id?: string;
            }[];
            /**
             * pagination response
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
            /**
             * query block height
             * @description Normally the RevisionHeight is incremented at each height while keeping
             * RevisionNumber the same. However some consensus algorithms may choose to
             * reset the height in certain conditions e.g. hard forks, state-machine
             * breaking changes In these cases, the RevisionNumber is incremented so that
             * height continues to be monitonically increasing even as the RevisionHeight
             * gets reset
             */
            height?: {
              /**
               * the revision that the client is currently on
               * Format: uint64
               */
              revision_number?: string;
              /**
               * the height within the given revision
               * Format: uint64
               */
              revision_height?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * AccountInfo queries account info which is common to all account types.
   * @description Since: cosmos-sdk 0.47
   */
  AccountInfo: {
    parameters: {
      path: {
        /** @description address is the account address string. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description info is the account info which is represented by BaseAccount. */
            info?: {
              address?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              pub_key?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** Format: uint64 */
              account_number?: string;
              /** Format: uint64 */
              sequence?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * Accounts returns all the existing accounts.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   *
   * Since: cosmos-sdk 0.43
   */
  Accounts: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** accounts are the existing accounts */
            accounts?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Account returns account details based on address. */
  AuthAccount: {
    parameters: {
      path: {
        /** @description address defines the address to query for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            account?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * AccountAddressByID returns account address based on account number.
   * @description Since: cosmos-sdk 0.46.2
   */
  AccountAddressByID: {
    parameters: {
      query?: {
        /**
         * @description account_id is the account number of the address to be queried.
         *
         * Since: cosmos-sdk 0.47
         */
        account_id?: string;
      };
      path: {
        /**
         * @description Deprecated, use account_id instead
         *
         * id is the account number of the address to be queried. This field
         * should have been an uint64 (like all account numbers), and will be
         * updated to uint64 in a future version of the auth query.
         */
        id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            account_address?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * Bech32Prefix queries bech32Prefix
   * @description Since: cosmos-sdk 0.46
   */
  Bech32Prefix: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            bech32_prefix?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * AddressBytesToString converts Account Address bytes to string
   * @description Since: cosmos-sdk 0.46
   */
  AddressBytesToString: {
    parameters: {
      path: {
        address_bytes: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            address_string?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * AddressStringToBytes converts Address string to bytes
   * @description Since: cosmos-sdk 0.46
   */
  AddressStringToBytes: {
    parameters: {
      path: {
        address_string: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** Format: byte */
            address_bytes?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ModuleAccounts returns all the existing module accounts.
   * @description Since: cosmos-sdk 0.46
   */
  ModuleAccounts: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            accounts?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ModuleAccountByName returns the module account info by module name */
  ModuleAccountByName: {
    parameters: {
      path: {
        name: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            account?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries all parameters. */
  AuthParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              /** Format: uint64 */
              max_memo_characters?: string;
              /** Format: uint64 */
              tx_sig_limit?: string;
              /** Format: uint64 */
              tx_size_cost_per_byte?: string;
              /** Format: uint64 */
              sig_verify_cost_ed25519?: string;
              /** Format: uint64 */
              sig_verify_cost_secp256k1?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Returns list of `Authorization`, granted to the grantee by the granter. */
  Grants: {
    parameters: {
      query?: {
        granter?: string;
        grantee?: string;
        /** @description Optional, msg_type_url, when set, will query only grants matching given msg type. */
        msg_type_url?: string;
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description authorizations is a list of grants granted for grantee by granter. */
            grants?: {
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              authorization?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * time when the grant will expire and will be pruned. If null, then the grant
               * doesn't have a time expiration (other conditions  in `authorization`
               * may apply to invalidate the grant)
               * Format: date-time
               */
              expiration?: string;
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * GranteeGrants returns a list of `GrantAuthorization` by grantee.
   * @description Since: cosmos-sdk 0.46
   */
  GranteeGrants: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        grantee: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description grants is a list of grants granted to the grantee. */
            grants?: {
              granter?: string;
              grantee?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              authorization?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** Format: date-time */
              expiration?: string;
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * GranterGrants returns list of `GrantAuthorization`, granted by granter.
   * @description Since: cosmos-sdk 0.46
   */
  GranterGrants: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        granter: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description grants is a list of grants granted by the granter. */
            grants?: {
              granter?: string;
              grantee?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              authorization?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** Format: date-time */
              expiration?: string;
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * AllBalances queries the balance of all coins for a single account.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  AllBalances: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /**
         * @description resolve_denom is the flag to resolve the denom into a human-readable form from the metadata.
         *
         * Since: cosmos-sdk 0.50
         */
        resolve_denom?: boolean;
      };
      path: {
        /** @description address is the address to query balances for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description balances is the balances of all the coins. */
            balances?: {
              denom?: string;
              amount?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Balance queries the balance of a single coin for a single account. */
  BankBalance: {
    parameters: {
      query?: {
        /** @description denom is the coin denom to query balances for. */
        denom?: string;
      };
      path: {
        /** @description address is the address to query balances for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            balance?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DenomOwners queries for all account addresses that own a particular token
   * denomination.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   *
   * Since: cosmos-sdk 0.46
   */
  DenomOwners: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description denom defines the coin denomination to query all account holders for. */
        denom: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            denom_owners?: {
              /** @description address defines the address that owns a particular denomination. */
              address?: string;
              /**
               * @description Coin defines a token with a denomination and an amount.
               *
               * NOTE: The amount field is an Int which implements the custom method
               * signatures required by gogoproto.
               */
              balance?: {
                denom?: string;
                amount?: string;
              };
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DenomsMetadata queries the client metadata for all registered coin
   * denominations.
   */
  DenomsMetadata: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description metadata provides the client information for all the registered tokens. */
            metadatas?: {
              description?: string;
              /** denom_units represents the list of DenomUnit's for a given coin */
              denom_units?: {
                /** @description denom represents the string name of the given denom unit (e.g uatom). */
                denom?: string;
                /**
                 * Format: int64
                 * @description exponent represents power of 10 exponent that one must
                 * raise the base_denom to in order to equal the given DenomUnit's denom
                 * 1 denom = 10^exponent base_denom
                 * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
                 * exponent = 6, thus: 1 atom = 10^6 uatom).
                 */
                exponent?: number;
                /** aliases is a list of string aliases for the given denom */
                aliases?: string[];
              }[];
              /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
              base?: string;
              /**
               * @description display indicates the suggested denom that should be
               * displayed in clients.
               */
              display?: string;
              /**
               * name defines the name of the token (eg: Cosmos Atom)
               * @description Since: cosmos-sdk 0.43
               */
              name?: string;
              /**
               * @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
               * be the same as the display.
               *
               * Since: cosmos-sdk 0.43
               */
              symbol?: string;
              /**
               * @description URI to a document (on or off-chain) that contains additional information. Optional.
               *
               * Since: cosmos-sdk 0.46
               */
              uri?: string;
              /**
               * @description URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
               * the document didn't change. Optional.
               *
               * Since: cosmos-sdk 0.46
               */
              uri_hash?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DenomsMetadata queries the client metadata of a given coin denomination. */
  DenomMetadata: {
    parameters: {
      path: {
        /** @description denom is the coin denom to query the metadata for. */
        denom: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Metadata represents a struct that describes
             * a basic token.
             */
            metadata?: {
              description?: string;
              /** denom_units represents the list of DenomUnit's for a given coin */
              denom_units?: {
                /** @description denom represents the string name of the given denom unit (e.g uatom). */
                denom?: string;
                /**
                 * Format: int64
                 * @description exponent represents power of 10 exponent that one must
                 * raise the base_denom to in order to equal the given DenomUnit's denom
                 * 1 denom = 10^exponent base_denom
                 * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
                 * exponent = 6, thus: 1 atom = 10^6 uatom).
                 */
                exponent?: number;
                /** aliases is a list of string aliases for the given denom */
                aliases?: string[];
              }[];
              /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
              base?: string;
              /**
               * @description display indicates the suggested denom that should be
               * displayed in clients.
               */
              display?: string;
              /**
               * name defines the name of the token (eg: Cosmos Atom)
               * @description Since: cosmos-sdk 0.43
               */
              name?: string;
              /**
               * @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
               * be the same as the display.
               *
               * Since: cosmos-sdk 0.43
               */
              symbol?: string;
              /**
               * @description URI to a document (on or off-chain) that contains additional information. Optional.
               *
               * Since: cosmos-sdk 0.46
               */
              uri?: string;
              /**
               * @description URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
               * the document didn't change. Optional.
               *
               * Since: cosmos-sdk 0.46
               */
              uri_hash?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DenomsMetadata queries the client metadata of a given coin denomination. */
  DenomMetadataByQueryString: {
    parameters: {
      query?: {
        /** @description denom is the coin denom to query the metadata for. */
        denom?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Metadata represents a struct that describes
             * a basic token.
             */
            metadata?: {
              description?: string;
              /** denom_units represents the list of DenomUnit's for a given coin */
              denom_units?: {
                /** @description denom represents the string name of the given denom unit (e.g uatom). */
                denom?: string;
                /**
                 * Format: int64
                 * @description exponent represents power of 10 exponent that one must
                 * raise the base_denom to in order to equal the given DenomUnit's denom
                 * 1 denom = 10^exponent base_denom
                 * (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
                 * exponent = 6, thus: 1 atom = 10^6 uatom).
                 */
                exponent?: number;
                /** aliases is a list of string aliases for the given denom */
                aliases?: string[];
              }[];
              /** @description base represents the base denom (should be the DenomUnit with exponent = 0). */
              base?: string;
              /**
               * @description display indicates the suggested denom that should be
               * displayed in clients.
               */
              display?: string;
              /**
               * name defines the name of the token (eg: Cosmos Atom)
               * @description Since: cosmos-sdk 0.43
               */
              name?: string;
              /**
               * @description symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
               * be the same as the display.
               *
               * Since: cosmos-sdk 0.43
               */
              symbol?: string;
              /**
               * @description URI to a document (on or off-chain) that contains additional information. Optional.
               *
               * Since: cosmos-sdk 0.46
               */
              uri?: string;
              /**
               * @description URIHash is a sha256 hash of a document pointed by URI. It's used to verify that
               * the document didn't change. Optional.
               *
               * Since: cosmos-sdk 0.46
               */
              uri_hash?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries the parameters of x/bank module. */
  BankParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params provides the parameters of the bank module. */
            params?: {
              /**
               * @description Deprecated: Use of SendEnabled in params is deprecated.
               * For genesis, use the newly added send_enabled field in the genesis object.
               * Storage, lookup, and manipulation of this information is now in the keeper.
               *
               * As of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.
               */
              send_enabled?: {
                denom?: string;
                enabled?: boolean;
              }[];
              default_send_enabled?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * SendEnabled queries for SendEnabled entries.
   * @description This query only returns denominations that have specific SendEnabled settings.
   * Any denomination that does not have a specific setting will use the default
   * params.default_send_enabled, and will not be returned by this query.
   *
   * Since: cosmos-sdk 0.47
   */
  SendEnabled: {
    parameters: {
      query?: {
        /** @description denoms is the specific denoms you want look up. Leave empty to get all entries. */
        denoms?: string[];
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            send_enabled?: {
              denom?: string;
              enabled?: boolean;
            }[];
            /**
             * @description pagination defines the pagination in the response. This field is only
             * populated if the denoms field in the request is empty.
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * SpendableBalances queries the spendable balance of all coins for a single
   * account.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   *
   * Since: cosmos-sdk 0.46
   */
  SpendableBalances: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description address is the address to query spendable balances for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description balances is the spendable balances of all the coins. */
            balances?: {
              denom?: string;
              amount?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * SpendableBalanceByDenom queries the spendable balance of a single denom for
   * a single account.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   *
   * Since: cosmos-sdk 0.47
   */
  SpendableBalanceByDenom: {
    parameters: {
      query?: {
        /** @description denom is the coin denom to query balances for. */
        denom?: string;
      };
      path: {
        /** @description address is the address to query balances for. */
        address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            balance?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * TotalSupply queries the total supply of all coins.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  TotalSupply: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** supply is the supply of the coins */
            supply?: {
              denom?: string;
              amount?: string;
            }[];
            /**
             * @description pagination defines the pagination in the response.
             *
             * Since: cosmos-sdk 0.43
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * SupplyOf queries the supply of a single coin.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  SupplyOf: {
    parameters: {
      query?: {
        /** @description denom is the coin denom to query balances for. */
        denom?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Coin defines a token with a denomination and an amount.
             *
             * NOTE: The amount field is an Int which implements the custom method
             * signatures required by gogoproto.
             */
            amount?: {
              denom?: string;
              amount?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** CommunityPool queries the community pool coins. */
  CommunityPool: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description pool defines community pool's coins. */
            pool?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DelegationTotalRewards queries the total rewards accrued by each
   * validator.
   */
  DelegationTotalRewards: {
    parameters: {
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description rewards defines all the rewards accrued by a delegator. */
            rewards?: {
              validator_address?: string;
              reward?: {
                denom?: string;
                amount?: string;
              }[];
            }[];
            /** @description total defines the sum of all the rewards. */
            total?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DelegationRewards queries the total rewards accrued by a delegation. */
  DelegationRewards: {
    parameters: {
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description rewards defines the rewards accrued by a delegation. */
            rewards?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DelegatorValidators queries the validators of a delegator. */
  DistDelegatorValidators: {
    parameters: {
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description validators defines the validators a delegator is delegating for. */
            validators?: string[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** DelegatorWithdrawAddress queries withdraw address of a delegator. */
  DelegatorWithdrawAddress: {
    parameters: {
      path: {
        /** @description delegator_address defines the delegator address to query for. */
        delegator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description withdraw_address defines the delegator address to query for. */
            withdraw_address?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries params of the distribution module. */
  DistributionParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params defines the parameters of the module. */
            params?: {
              community_tax?: string;
              /**
               * @description Deprecated: The base_proposer_reward field is deprecated and is no longer used
               * in the x/distribution module's reward mechanism.
               */
              base_proposer_reward?: string;
              /**
               * @description Deprecated: The bonus_proposer_reward field is deprecated and is no longer used
               * in the x/distribution module's reward mechanism.
               */
              bonus_proposer_reward?: string;
              withdraw_addr_enabled?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator */
  ValidatorDistributionInfo: {
    parameters: {
      path: {
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description operator_address defines the validator operator address. */
            operator_address?: string;
            /** @description self_bond_rewards defines the self delegations rewards. */
            self_bond_rewards?: {
              denom?: string;
              amount?: string;
            }[];
            /** @description commission defines the commission the validator received. */
            commission?: {
              denom?: string;
              amount?: string;
            }[];
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ValidatorCommission queries accumulated commission for a validator. */
  ValidatorCommission: {
    parameters: {
      path: {
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description commission defines the commission the validator received. */
            commission?: {
              commission?: {
                denom?: string;
                amount?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ValidatorOutstandingRewards queries rewards of a validator address. */
  ValidatorOutstandingRewards: {
    parameters: {
      path: {
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
             * for a validator inexpensive to track, allows simple sanity checks.
             */
            rewards?: {
              rewards?: {
                denom?: string;
                amount?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** ValidatorSlashes queries slash events of a validator. */
  ValidatorSlashes: {
    parameters: {
      query?: {
        /** @description starting_height defines the optional starting height to query the slashes. */
        starting_height?: string;
        /** @description starting_height defines the optional ending height to query the slashes. */
        ending_height?: string;
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description validator_address defines the validator address to query for. */
        validator_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description slashes defines the slashes the validator received. */
            slashes?: {
              /** Format: uint64 */
              validator_period?: string;
              fraction?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Allowance returns granted allwance to the grantee by the granter. */
  Allowance: {
    parameters: {
      path: {
        /** @description granter is the address of the user granting an allowance of their funds. */
        granter: string;
        /** @description grantee is the address of the user being granted an allowance of another user's funds. */
        grantee: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Grant is stored in the KVStore to record a grant with full context
             * @description allowance is a allowance granted for grantee by granter.
             */
            allowance?: {
              /** @description granter is the address of the user granting an allowance of their funds. */
              granter?: string;
              /** @description grantee is the address of the user being granted an allowance of another user's funds. */
              grantee?: string;
              /** @description allowance can be any of basic, periodic, allowed fee allowance. */
              allowance?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Allowances returns all the grants for the given grantee address. */
  Allowances: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        grantee: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description allowances are allowance's granted for grantee by granter. */
            allowances?: {
              /** @description granter is the address of the user granting an allowance of their funds. */
              granter?: string;
              /** @description grantee is the address of the user being granted an allowance of another user's funds. */
              grantee?: string;
              /** @description allowance can be any of basic, periodic, allowed fee allowance. */
              allowance?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * AllowancesByGranter returns all the grants given by an address
   * @description Since: cosmos-sdk 0.46
   */
  AllowancesByGranter: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        granter: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description allowances that have been issued by the granter. */
            allowances?: {
              /** @description granter is the address of the user granting an allowance of their funds. */
              granter?: string;
              /** @description grantee is the address of the user being granted an allowance of another user's funds. */
              grantee?: string;
              /** @description allowance can be any of basic, periodic, allowed fee allowance. */
              allowance?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** AllEvidence queries all evidence. */
  AllEvidence: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description evidence returns all evidences. */
            evidence?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Evidence queries evidence based on evidence hash. */
  Evidence: {
    parameters: {
      query?: {
        /**
         * @description evidence_hash defines the hash of the requested evidence.
         * Deprecated: Use hash, a HEX encoded string, instead.
         */
        evidence_hash?: string;
      };
      path: {
        /**
         * @description hash defines the evidence hash of the requested evidence.
         *
         * Since: cosmos-sdk 0.47
         */
        hash: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description `Any` contains an arbitrary serialized protocol buffer message along with a
             * URL that describes the type of the serialized message.
             *
             * Protobuf library provides support to pack/unpack Any values in the form
             * of utility functions or additional generated methods of the Any type.
             *
             * Example 1: Pack and unpack a message in C++.
             *
             *     Foo foo = ...;
             *     Any any;
             *     any.PackFrom(foo);
             *     ...
             *     if (any.UnpackTo(&foo)) {
             *       ...
             *     }
             *
             * Example 2: Pack and unpack a message in Java.
             *
             *     Foo foo = ...;
             *     Any any = Any.pack(foo);
             *     ...
             *     if (any.is(Foo.class)) {
             *       foo = any.unpack(Foo.class);
             *     }
             *
             * Example 3: Pack and unpack a message in Python.
             *
             *     foo = Foo(...)
             *     any = Any()
             *     any.Pack(foo)
             *     ...
             *     if any.Is(Foo.DESCRIPTOR):
             *       any.Unpack(foo)
             *       ...
             *
             * Example 4: Pack and unpack a message in Go
             *
             *      foo := &pb.Foo{...}
             *      any, err := anypb.New(foo)
             *      if err != nil {
             *        ...
             *      }
             *      ...
             *      foo := &pb.Foo{}
             *      if err := any.UnmarshalTo(foo); err != nil {
             *        ...
             *      }
             *
             * The pack methods provided by protobuf library will by default use
             * 'type.googleapis.com/full.type.name' as the type URL and the unpack
             * methods only use the fully qualified type name after the last '/'
             * in the type URL, for example "foo.bar.com/x/y.z" will yield type
             * name "y.z".
             *
             *
             * JSON
             *
             * The JSON representation of an `Any` value uses the regular
             * representation of the deserialized, embedded message, with an
             * additional field `@type` which contains the type URL. Example:
             *
             *     package google.profile;
             *     message Person {
             *       string first_name = 1;
             *       string last_name = 2;
             *     }
             *
             *     {
             *       "@type": "type.googleapis.com/google.profile.Person",
             *       "firstName": <string>,
             *       "lastName": <string>
             *     }
             *
             * If the embedded message type is well-known and has a custom JSON
             * representation, that representation will be embedded adding a field
             * `value` which holds the custom JSON in addition to the `@type`
             * field. Example (for message [google.protobuf.Duration][]):
             *
             *     {
             *       "@type": "type.googleapis.com/google.protobuf.Duration",
             *       "value": "1.212s"
             *     }
             */
            evidence?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries all parameters of the gov module. */
  GovParams: {
    parameters: {
      path: {
        /**
         * @description params_type defines which parameters to query for, can be one of "voting",
         * "tallying" or "deposit".
         */
        params_type: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description voting_params defines the parameters related to voting. */
            voting_params?: {
              /** @description Duration of the voting period. */
              voting_period?: string;
            };
            /** @description deposit_params defines the parameters related to deposit. */
            deposit_params?: {
              /** @description Minimum deposit for a proposal to enter voting period. */
              min_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
               * months.
               */
              max_deposit_period?: string;
            };
            /** @description tally_params defines the parameters related to tally. */
            tally_params?: {
              /**
               * Format: byte
               * @description Minimum percentage of total stake needed to vote for a result to be
               * considered valid.
               */
              quorum?: string;
              /**
               * Format: byte
               * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.
               */
              threshold?: string;
              /**
               * Format: byte
               * @description Minimum value of Veto votes to Total votes ratio for proposal to be
               * vetoed. Default value: 1/3.
               */
              veto_threshold?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Proposals queries all proposals based on given status. */
  Proposals: {
    parameters: {
      query?: {
        /**
         * @description proposal_status defines the status of the proposals.
         *
         *  - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.
         *  - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
         * period.
         *  - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
         * period.
         *  - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
         * passed.
         *  - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
         * been rejected.
         *  - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
         * failed.
         */
        proposal_status?:
          | "PROPOSAL_STATUS_UNSPECIFIED"
          | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
          | "PROPOSAL_STATUS_VOTING_PERIOD"
          | "PROPOSAL_STATUS_PASSED"
          | "PROPOSAL_STATUS_REJECTED"
          | "PROPOSAL_STATUS_FAILED";
        /** @description voter defines the voter address for the proposals. */
        voter?: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor?: string;
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description proposals defines all the requested governance proposals. */
            proposals?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              content?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * @description status defines the proposal status.
               * @default PROPOSAL_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status?:
                | "PROPOSAL_STATUS_UNSPECIFIED"
                | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
                | "PROPOSAL_STATUS_VOTING_PERIOD"
                | "PROPOSAL_STATUS_PASSED"
                | "PROPOSAL_STATUS_REJECTED"
                | "PROPOSAL_STATUS_FAILED";
              /**
               * @description final_tally_result is the final tally result of the proposal. When
               * querying a proposal via gRPC, this field is not populated until the
               * proposal's voting period has ended.
               */
              final_tally_result?: {
                /** @description yes is the number of yes votes on a proposal. */
                yes?: string;
                /** @description abstain is the number of abstain votes on a proposal. */
                abstain?: string;
                /** @description no is the number of no votes on a proposal. */
                no?: string;
                /** @description no_with_veto is the number of no with veto votes on a proposal. */
                no_with_veto?: string;
              };
              /**
               * Format: date-time
               * @description submit_time is the time of proposal submission.
               */
              submit_time?: string;
              /**
               * Format: date-time
               * @description deposit_end_time is the end time for deposition.
               */
              deposit_end_time?: string;
              /** @description total_deposit is the total deposit on the proposal. */
              total_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * Format: date-time
               * @description voting_start_time is the starting time to vote on a proposal.
               */
              voting_start_time?: string;
              /**
               * Format: date-time
               * @description voting_end_time is the end time of voting on a proposal.
               */
              voting_end_time?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Proposal queries proposal details based on ProposalID. */
  Proposal: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description Proposal defines the core field members of a governance proposal. */
            proposal?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              content?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * @description status defines the proposal status.
               * @default PROPOSAL_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status?:
                | "PROPOSAL_STATUS_UNSPECIFIED"
                | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
                | "PROPOSAL_STATUS_VOTING_PERIOD"
                | "PROPOSAL_STATUS_PASSED"
                | "PROPOSAL_STATUS_REJECTED"
                | "PROPOSAL_STATUS_FAILED";
              /**
               * @description final_tally_result is the final tally result of the proposal. When
               * querying a proposal via gRPC, this field is not populated until the
               * proposal's voting period has ended.
               */
              final_tally_result?: {
                /** @description yes is the number of yes votes on a proposal. */
                yes?: string;
                /** @description abstain is the number of abstain votes on a proposal. */
                abstain?: string;
                /** @description no is the number of no votes on a proposal. */
                no?: string;
                /** @description no_with_veto is the number of no with veto votes on a proposal. */
                no_with_veto?: string;
              };
              /**
               * Format: date-time
               * @description submit_time is the time of proposal submission.
               */
              submit_time?: string;
              /**
               * Format: date-time
               * @description deposit_end_time is the end time for deposition.
               */
              deposit_end_time?: string;
              /** @description total_deposit is the total deposit on the proposal. */
              total_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * Format: date-time
               * @description voting_start_time is the starting time to vote on a proposal.
               */
              voting_start_time?: string;
              /**
               * Format: date-time
               * @description voting_end_time is the end time of voting on a proposal.
               */
              voting_end_time?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Deposits queries all deposits of a single proposal. */
  Deposits: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description deposits defines the requested deposits. */
            deposits?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /** @description depositor defines the deposit addresses from the proposals. */
              depositor?: string;
              /** @description amount to be deposited by depositor. */
              amount?: {
                denom?: string;
                amount?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Deposit queries single deposit information based on proposalID, depositor address. */
  Deposit: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Deposit defines an amount deposited by an account address to an active
             * proposal.
             */
            deposit?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /** @description depositor defines the deposit addresses from the proposals. */
              depositor?: string;
              /** @description amount to be deposited by depositor. */
              amount?: {
                denom?: string;
                amount?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TallyResult queries the tally of a proposal vote. */
  TallyResult: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description tally defines the requested tally. */
            tally?: {
              /** @description yes is the number of yes votes on a proposal. */
              yes?: string;
              /** @description abstain is the number of abstain votes on a proposal. */
              abstain?: string;
              /** @description no is the number of no votes on a proposal. */
              no?: string;
              /** @description no_with_veto is the number of no with veto votes on a proposal. */
              no_with_veto?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Votes queries votes of a given proposal. */
  Votes: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description votes defines the queried votes. */
            votes?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /** @description voter is the voter address of the proposal. */
              voter?: string;
              /**
               * @description Deprecated: Prefer to use `options` instead. This field is set in queries
               * if and only if `len(options) == 1` and that option has weight 1. In all
               * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
               * @default VOTE_OPTION_UNSPECIFIED
               * @enum {string}
               */
              option?:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /**
               * @description options is the weighted vote options.
               *
               * Since: cosmos-sdk 0.43
               */
              options?: {
                /**
                 * @description option defines the valid vote options, it must not contain duplicate vote options.
                 * @default VOTE_OPTION_UNSPECIFIED
                 * @enum {string}
                 */
                option?:
                  | "VOTE_OPTION_UNSPECIFIED"
                  | "VOTE_OPTION_YES"
                  | "VOTE_OPTION_ABSTAIN"
                  | "VOTE_OPTION_NO"
                  | "VOTE_OPTION_NO_WITH_VETO";
                /** @description weight is the vote weight associated with the vote option. */
                weight?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * Vote queries voted information based on proposalID, voterAddr.
   * Due to how we handle state, this query would error for proposals that has already been finished.
   */
  Vote: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
        /** @description voter defines the voter address for the proposals. */
        voter: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Vote defines a vote on a governance proposal.
             * A Vote consists of a proposal ID, the voter, and the vote option.
             */
            vote?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /** @description voter is the voter address of the proposal. */
              voter?: string;
              /**
               * @description Deprecated: Prefer to use `options` instead. This field is set in queries
               * if and only if `len(options) == 1` and that option has weight 1. In all
               * other cases, this field will default to VOTE_OPTION_UNSPECIFIED.
               * @default VOTE_OPTION_UNSPECIFIED
               * @enum {string}
               */
              option?:
                | "VOTE_OPTION_UNSPECIFIED"
                | "VOTE_OPTION_YES"
                | "VOTE_OPTION_ABSTAIN"
                | "VOTE_OPTION_NO"
                | "VOTE_OPTION_NO_WITH_VETO";
              /**
               * @description options is the weighted vote options.
               *
               * Since: cosmos-sdk 0.43
               */
              options?: {
                /**
                 * @description option defines the valid vote options, it must not contain duplicate vote options.
                 * @default VOTE_OPTION_UNSPECIFIED
                 * @enum {string}
                 */
                option?:
                  | "VOTE_OPTION_UNSPECIFIED"
                  | "VOTE_OPTION_YES"
                  | "VOTE_OPTION_ABSTAIN"
                  | "VOTE_OPTION_NO"
                  | "VOTE_OPTION_NO_WITH_VETO";
                /** @description weight is the vote weight associated with the vote option. */
                weight?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Constitution queries the chain's constitution. */
  Constitution: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            constitution?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries all parameters of the gov module. */
  GovV1Params: {
    parameters: {
      path: {
        /**
         * @description params_type defines which parameters to query for, can be one of "voting",
         * "tallying" or "deposit".
         */
        params_type: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Deprecated: Prefer to use `params` instead.
             * voting_params defines the parameters related to voting.
             */
            voting_params?: {
              /** @description Duration of the voting period. */
              voting_period?: string;
            };
            /**
             * @description Deprecated: Prefer to use `params` instead.
             * deposit_params defines the parameters related to deposit.
             */
            deposit_params?: {
              /** @description Minimum deposit for a proposal to enter voting period. */
              min_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
               * months.
               */
              max_deposit_period?: string;
            };
            /**
             * @description Deprecated: Prefer to use `params` instead.
             * tally_params defines the parameters related to tally.
             */
            tally_params?: {
              /**
               * @description Minimum percentage of total stake needed to vote for a result to be
               * considered valid.
               */
              quorum?: string;
              /** @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
              threshold?: string;
              /**
               * @description Minimum value of Veto votes to Total votes ratio for proposal to be
               * vetoed. Default value: 1/3.
               */
              veto_threshold?: string;
            };
            /**
             * @description params defines all the paramaters of x/gov module.
             *
             * Since: cosmos-sdk 0.47
             */
            params?: {
              /** @description Minimum deposit for a proposal to enter voting period. */
              min_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * @description Maximum period for Atom holders to deposit on a proposal. Initial value: 2
               * months.
               */
              max_deposit_period?: string;
              /** @description Duration of the voting period. */
              voting_period?: string;
              /**
               * @description Minimum percentage of total stake needed to vote for a result to be
               *  considered valid.
               */
              quorum?: string;
              /** @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
              threshold?: string;
              /**
               * @description Minimum value of Veto votes to Total votes ratio for proposal to be
               *  vetoed. Default value: 1/3.
               */
              veto_threshold?: string;
              /** @description The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
              min_initial_deposit_ratio?: string;
              /**
               * @description The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.
               *
               * Since: cosmos-sdk 0.50
               */
              proposal_cancel_ratio?: string;
              /**
               * @description The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.
               * If empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.
               *
               * Since: cosmos-sdk 0.50
               */
              proposal_cancel_dest?: string;
              /**
               * @description Duration of the voting period of an expedited proposal.
               *
               * Since: cosmos-sdk 0.50
               */
              expedited_voting_period?: string;
              /**
               * @description Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.
               *
               * Since: cosmos-sdk 0.50
               */
              expedited_threshold?: string;
              /** @description Minimum expedited deposit for a proposal to enter voting period. */
              expedited_min_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /** burn deposits if a proposal does not meet quorum */
              burn_vote_quorum?: boolean;
              /** burn deposits if the proposal does not enter voting period */
              burn_proposal_deposit_prevote?: boolean;
              /** burn deposits if quorum with vote type no_veto is met */
              burn_vote_veto?: boolean;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Proposal queries proposal details based on ProposalID. */
  GovV1Proposal: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description Proposal defines the core field members of a governance proposal. */
            proposal?: {
              /**
               * Format: uint64
               * @description id defines the unique id of the proposal.
               */
              id?: string;
              /** @description messages are the arbitrary messages to be executed if the proposal passes. */
              messages?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              }[];
              /**
               * @description status defines the proposal status.
               * @default PROPOSAL_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status?:
                | "PROPOSAL_STATUS_UNSPECIFIED"
                | "PROPOSAL_STATUS_DEPOSIT_PERIOD"
                | "PROPOSAL_STATUS_VOTING_PERIOD"
                | "PROPOSAL_STATUS_PASSED"
                | "PROPOSAL_STATUS_REJECTED"
                | "PROPOSAL_STATUS_FAILED";
              /**
               * @description final_tally_result is the final tally result of the proposal. When
               * querying a proposal via gRPC, this field is not populated until the
               * proposal's voting period has ended.
               */
              final_tally_result?: {
                /** @description yes_count is the number of yes votes on a proposal. */
                yes_count?: string;
                /** @description abstain_count is the number of abstain votes on a proposal. */
                abstain_count?: string;
                /** @description no_count is the number of no votes on a proposal. */
                no_count?: string;
                /** @description no_with_veto_count is the number of no with veto votes on a proposal. */
                no_with_veto_count?: string;
              };
              /**
               * Format: date-time
               * @description submit_time is the time of proposal submission.
               */
              submit_time?: string;
              /**
               * Format: date-time
               * @description deposit_end_time is the end time for deposition.
               */
              deposit_end_time?: string;
              /** @description total_deposit is the total deposit on the proposal. */
              total_deposit?: {
                denom?: string;
                amount?: string;
              }[];
              /**
               * Format: date-time
               * @description voting_start_time is the starting time to vote on a proposal.
               */
              voting_start_time?: string;
              /**
               * Format: date-time
               * @description voting_end_time is the end time of voting on a proposal.
               */
              voting_end_time?: string;
              /**
               * metadata is any arbitrary metadata attached to the proposal.
               * the recommended format of the metadata is to be found here:
               * https://docs.cosmos.network/v0.47/modules/gov#proposal-3
               */
              metadata?: string;
              /**
               * title is the title of the proposal
               * @description Since: cosmos-sdk 0.47
               */
              title?: string;
              /**
               * summary is a short summary of the proposal
               * @description Since: cosmos-sdk 0.47
               */
              summary?: string;
              /**
               * proposer is the address of the proposal sumbitter
               * @description Since: cosmos-sdk 0.47
               */
              proposer?: string;
              /**
               * expedited defines if the proposal is expedited
               * @description Since: cosmos-sdk 0.50
               */
              expedited?: boolean;
              /**
               * failed_reason defines the reason why the proposal failed
               * @description Since: cosmos-sdk 0.50
               */
              failed_reason?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Deposit queries single deposit information based on proposalID, depositAddr. */
  GovV1Deposit: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
        /** @description depositor defines the deposit addresses from the proposals. */
        depositor: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Deposit defines an amount deposited by an account address to an active
             * proposal.
             */
            deposit?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /** @description depositor defines the deposit addresses from the proposals. */
              depositor?: string;
              /** @description amount to be deposited by depositor. */
              amount?: {
                denom?: string;
                amount?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** TallyResult queries the tally of a proposal vote. */
  GovV1TallyResult: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description tally defines the requested tally. */
            tally?: {
              /** @description yes_count is the number of yes votes on a proposal. */
              yes_count?: string;
              /** @description abstain_count is the number of abstain votes on a proposal. */
              abstain_count?: string;
              /** @description no_count is the number of no votes on a proposal. */
              no_count?: string;
              /** @description no_with_veto_count is the number of no with veto votes on a proposal. */
              no_with_veto_count?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Votes queries votes of a given proposal. */
  GovV1Votes: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description votes defines the queried votes. */
            votes?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /** @description voter is the voter address of the proposal. */
              voter?: string;
              /** @description options is the weighted vote options. */
              options?: {
                /**
                 * @description option defines the valid vote options, it must not contain duplicate vote options.
                 * @default VOTE_OPTION_UNSPECIFIED
                 * @enum {string}
                 */
                option?:
                  | "VOTE_OPTION_UNSPECIFIED"
                  | "VOTE_OPTION_YES"
                  | "VOTE_OPTION_ABSTAIN"
                  | "VOTE_OPTION_NO"
                  | "VOTE_OPTION_NO_WITH_VETO";
                /** @description weight is the vote weight associated with the vote option. */
                weight?: string;
              }[];
              /**
               * metadata is any arbitrary metadata attached to the vote.
               * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
               */
              metadata?: string;
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Vote queries voted information based on proposalID, voterAddr. */
  GovV1Vote: {
    parameters: {
      path: {
        /** @description proposal_id defines the unique id of the proposal. */
        proposal_id: string;
        /** @description voter defines the voter address for the proposals. */
        voter: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Vote defines a vote on a governance proposal.
             * A Vote consists of a proposal ID, the voter, and the vote option.
             */
            vote?: {
              /**
               * Format: uint64
               * @description proposal_id defines the unique id of the proposal.
               */
              proposal_id?: string;
              /** @description voter is the voter address of the proposal. */
              voter?: string;
              /** @description options is the weighted vote options. */
              options?: {
                /**
                 * @description option defines the valid vote options, it must not contain duplicate vote options.
                 * @default VOTE_OPTION_UNSPECIFIED
                 * @enum {string}
                 */
                option?:
                  | "VOTE_OPTION_UNSPECIFIED"
                  | "VOTE_OPTION_YES"
                  | "VOTE_OPTION_ABSTAIN"
                  | "VOTE_OPTION_NO"
                  | "VOTE_OPTION_NO_WITH_VETO";
                /** @description weight is the vote weight associated with the vote option. */
                weight?: string;
              }[];
              /**
               * metadata is any arbitrary metadata attached to the vote.
               * the recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5
               */
              metadata?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Params queries the parameters of slashing module */
  SlashingParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description Params represents the parameters used for by the slashing module. */
            params?: {
              /** Format: int64 */
              signed_blocks_window?: string;
              /** Format: byte */
              min_signed_per_window?: string;
              downtime_jail_duration?: string;
              /** Format: byte */
              slash_fraction_double_sign?: string;
              /** Format: byte */
              slash_fraction_downtime?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** SigningInfos queries signing info of all validators */
  SigningInfos: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** info is the signing info of all validators */
            info?: {
              address?: string;
              /**
               * Height at which validator was first a candidate OR was un-jailed
               * Format: int64
               */
              start_height?: string;
              /**
               * Format: int64
               * @description Index which is incremented every time a validator is bonded in a block and
               * _may_ have signed a pre-commit or not. This in conjunction with the
               * signed_blocks_window param determines the index in the missed block bitmap.
               */
              index_offset?: string;
              /**
               * Format: date-time
               * @description Timestamp until which the validator is jailed due to liveness downtime.
               */
              jailed_until?: string;
              /**
               * @description Whether or not a validator has been tombstoned (killed out of validator
               * set). It is set once the validator commits an equivocation or for any other
               * configured misbehavior.
               */
              tombstoned?: boolean;
              /**
               * Format: int64
               * @description A counter of missed (unsigned) blocks. It is used to avoid unnecessary
               * reads in the missed block bitmap.
               */
              missed_blocks_counter?: string;
            }[];
            /**
             * @description PageResponse is to be embedded in gRPC response messages where the
             * corresponding request message has used PageRequest.
             *
             *  message SomeResponse {
             *          repeated Bar results = 1;
             *          PageResponse page = 2;
             *  }
             */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** SigningInfo queries the signing info of given cons address */
  SigningInfo: {
    parameters: {
      path: {
        /** @description cons_address is the address to query signing info of */
        cons_address: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * val_signing_info is the signing info of requested val cons address
             * @description ValidatorSigningInfo defines a validator's signing info for monitoring their
             * liveness activity.
             */
            val_signing_info?: {
              address?: string;
              /**
               * Height at which validator was first a candidate OR was un-jailed
               * Format: int64
               */
              start_height?: string;
              /**
               * Format: int64
               * @description Index which is incremented every time a validator is bonded in a block and
               * _may_ have signed a pre-commit or not. This in conjunction with the
               * signed_blocks_window param determines the index in the missed block bitmap.
               */
              index_offset?: string;
              /**
               * Format: date-time
               * @description Timestamp until which the validator is jailed due to liveness downtime.
               */
              jailed_until?: string;
              /**
               * @description Whether or not a validator has been tombstoned (killed out of validator
               * set). It is set once the validator commits an equivocation or for any other
               * configured misbehavior.
               */
              tombstoned?: boolean;
              /**
               * Format: int64
               * @description A counter of missed (unsigned) blocks. It is used to avoid unnecessary
               * reads in the missed block bitmap.
               */
              missed_blocks_counter?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              type_url?: string;
              /** Format: byte */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DelegatorDelegations queries all delegations of a given delegator address.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  DelegatorDelegations: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description delegation_responses defines all the delegations' info of a delegator. */
            delegation_responses?: {
              /**
               * @description Delegation represents the bond with tokens held by an account. It is
               * owned by one delegator, and is associated with the voting power of one
               * validator.
               */
              delegation?: {
                /** @description delegator_address is the encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_address is the encoded address of the validator. */
                validator_address?: string;
                /** @description shares define the delegation shares received. */
                shares?: string;
              };
              /**
               * @description Coin defines a token with a denomination and an amount.
               *
               * NOTE: The amount field is an Int which implements the custom method
               * signatures required by gogoproto.
               */
              balance?: {
                denom?: string;
                amount?: string;
              };
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * Redelegations queries redelegations of given address.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  Redelegations: {
    parameters: {
      query?: {
        /** @description src_validator_addr defines the validator address to redelegate from. */
        src_validator_addr?: string;
        /** @description dst_validator_addr defines the validator address to redelegate to. */
        dst_validator_addr?: string;
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            redelegation_responses?: {
              /**
               * @description Redelegation contains the list of a particular delegator's redelegating bonds
               * from a particular source validator to a particular destination validator.
               */
              redelegation?: {
                /** @description delegator_address is the bech32-encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_src_address is the validator redelegation source operator address. */
                validator_src_address?: string;
                /** @description validator_dst_address is the validator redelegation destination operator address. */
                validator_dst_address?: string;
                /** @description entries are the redelegation entries. */
                entries?: {
                  /**
                   * Format: int64
                   * @description creation_height  defines the height which the redelegation took place.
                   */
                  creation_height?: string;
                  /**
                   * Format: date-time
                   * @description completion_time defines the unix time for redelegation completion.
                   */
                  completion_time?: string;
                  /** @description initial_balance defines the initial balance when redelegation started. */
                  initial_balance?: string;
                  /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
                  shares_dst?: string;
                  /**
                   * Incrementing id that uniquely identifies this entry
                   * Format: uint64
                   */
                  unbonding_id?: string;
                  /**
                   * Strictly positive if this entry's unbonding has been stopped by external modules
                   * Format: int64
                   */
                  unbonding_on_hold_ref_count?: string;
                }[];
              };
              entries?: {
                /** @description RedelegationEntry defines a redelegation object with relevant metadata. */
                redelegation_entry?: {
                  /**
                   * Format: int64
                   * @description creation_height  defines the height which the redelegation took place.
                   */
                  creation_height?: string;
                  /**
                   * Format: date-time
                   * @description completion_time defines the unix time for redelegation completion.
                   */
                  completion_time?: string;
                  /** @description initial_balance defines the initial balance when redelegation started. */
                  initial_balance?: string;
                  /** @description shares_dst is the amount of destination-validator shares created by redelegation. */
                  shares_dst?: string;
                  /**
                   * Incrementing id that uniquely identifies this entry
                   * Format: uint64
                   */
                  unbonding_id?: string;
                  /**
                   * Strictly positive if this entry's unbonding has been stopped by external modules
                   * Format: int64
                   */
                  unbonding_on_hold_ref_count?: string;
                };
                balance?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DelegatorUnbondingDelegations queries all unbonding delegations of a given
   * delegator address.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  DelegatorUnbondingDelegations: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            unbonding_responses?: {
              /** @description delegator_address is the encoded address of the delegator. */
              delegator_address?: string;
              /** @description validator_address is the encoded address of the validator. */
              validator_address?: string;
              /** @description entries are the unbonding delegation entries. */
              entries?: {
                /**
                 * Format: int64
                 * @description creation_height is the height which the unbonding took place.
                 */
                creation_height?: string;
                /**
                 * Format: date-time
                 * @description completion_time is the unix time for unbonding completion.
                 */
                completion_time?: string;
                /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
                initial_balance?: string;
                /** @description balance defines the tokens to receive at completion. */
                balance?: string;
                /**
                 * Incrementing id that uniquely identifies this entry
                 * Format: uint64
                 */
                unbonding_id?: string;
                /**
                 * Strictly positive if this entry's unbonding has been stopped by external modules
                 * Format: int64
                 */
                unbonding_on_hold_ref_count?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DelegatorValidators queries all validators info for given delegator
   * address.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  DelegatorValidators: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description validators defines the validators' info of a delegator. */
            validators?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              consensus_pubkey?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** @description jailed defined whether the validator has been jailed from bonded status or not. */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status?:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /**
               * @description min_self_delegation is the validator's self declared minimum self delegation.
               *
               * Since: cosmos-sdk 0.46
               */
              min_self_delegation?: string;
              /**
               * strictly positive if this validator's unbonding has been stopped by external modules
               * Format: int64
               */
              unbonding_on_hold_ref_count?: string;
              /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
              unbonding_ids?: string[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * DelegatorValidator queries validator info for given delegator validator
   * pair.
   */
  DelegatorValidator: {
    parameters: {
      path: {
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Validator defines a validator, together with the total amount of the
             * Validator's bond shares and their exchange rate to coins. Slashing results in
             * a decrease in the exchange rate, allowing correct calculation of future
             * undelegations without iterating over delegators. When coins are delegated to
             * this validator, the validator is credited with a delegation whose number of
             * bond shares is based on the amount of coins delegated divided by the current
             * exchange rate. Voting power can be calculated as total bonded shares
             * multiplied by exchange rate.
             */
            validator?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              consensus_pubkey?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** @description jailed defined whether the validator has been jailed from bonded status or not. */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status?:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /**
               * @description min_self_delegation is the validator's self declared minimum self delegation.
               *
               * Since: cosmos-sdk 0.46
               */
              min_self_delegation?: string;
              /**
               * strictly positive if this validator's unbonding has been stopped by external modules
               * Format: int64
               */
              unbonding_on_hold_ref_count?: string;
              /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
              unbonding_ids?: string[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** HistoricalInfo queries the historical info for given height. */
  HistoricalInfo: {
    parameters: {
      path: {
        /** @description height defines at which height to query the historical info. */
        height: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description hist defines the historical info at the given height. */
            hist?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** prev block info */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              valset?: {
                /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
                operator_address?: string;
                /**
                 * @description `Any` contains an arbitrary serialized protocol buffer message along with a
                 * URL that describes the type of the serialized message.
                 *
                 * Protobuf library provides support to pack/unpack Any values in the form
                 * of utility functions or additional generated methods of the Any type.
                 *
                 * Example 1: Pack and unpack a message in C++.
                 *
                 *     Foo foo = ...;
                 *     Any any;
                 *     any.PackFrom(foo);
                 *     ...
                 *     if (any.UnpackTo(&foo)) {
                 *       ...
                 *     }
                 *
                 * Example 2: Pack and unpack a message in Java.
                 *
                 *     Foo foo = ...;
                 *     Any any = Any.pack(foo);
                 *     ...
                 *     if (any.is(Foo.class)) {
                 *       foo = any.unpack(Foo.class);
                 *     }
                 *
                 * Example 3: Pack and unpack a message in Python.
                 *
                 *     foo = Foo(...)
                 *     any = Any()
                 *     any.Pack(foo)
                 *     ...
                 *     if any.Is(Foo.DESCRIPTOR):
                 *       any.Unpack(foo)
                 *       ...
                 *
                 * Example 4: Pack and unpack a message in Go
                 *
                 *      foo := &pb.Foo{...}
                 *      any, err := anypb.New(foo)
                 *      if err != nil {
                 *        ...
                 *      }
                 *      ...
                 *      foo := &pb.Foo{}
                 *      if err := any.UnmarshalTo(foo); err != nil {
                 *        ...
                 *      }
                 *
                 * The pack methods provided by protobuf library will by default use
                 * 'type.googleapis.com/full.type.name' as the type URL and the unpack
                 * methods only use the fully qualified type name after the last '/'
                 * in the type URL, for example "foo.bar.com/x/y.z" will yield type
                 * name "y.z".
                 *
                 *
                 * JSON
                 *
                 * The JSON representation of an `Any` value uses the regular
                 * representation of the deserialized, embedded message, with an
                 * additional field `@type` which contains the type URL. Example:
                 *
                 *     package google.profile;
                 *     message Person {
                 *       string first_name = 1;
                 *       string last_name = 2;
                 *     }
                 *
                 *     {
                 *       "@type": "type.googleapis.com/google.profile.Person",
                 *       "firstName": <string>,
                 *       "lastName": <string>
                 *     }
                 *
                 * If the embedded message type is well-known and has a custom JSON
                 * representation, that representation will be embedded adding a field
                 * `value` which holds the custom JSON in addition to the `@type`
                 * field. Example (for message [google.protobuf.Duration][]):
                 *
                 *     {
                 *       "@type": "type.googleapis.com/google.protobuf.Duration",
                 *       "value": "1.212s"
                 *     }
                 */
                consensus_pubkey?: {
                  /**
                   * @description A URL/resource name that uniquely identifies the type of the serialized
                   * protocol buffer message. This string must contain at least
                   * one "/" character. The last segment of the URL's path must represent
                   * the fully qualified name of the type (as in
                   * `path/google.protobuf.Duration`). The name should be in a canonical form
                   * (e.g., leading "." is not accepted).
                   *
                   * In practice, teams usually precompile into the binary all types that they
                   * expect it to use in the context of Any. However, for URLs which use the
                   * scheme `http`, `https`, or no scheme, one can optionally set up a type
                   * server that maps type URLs to message definitions as follows:
                   *
                   * * If no scheme is provided, `https` is assumed.
                   * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                   *   value in binary format, or produce an error.
                   * * Applications are allowed to cache lookup results based on the
                   *   URL, or have them precompiled into a binary to avoid any
                   *   lookup. Therefore, binary compatibility needs to be preserved
                   *   on changes to types. (Use versioned type names to manage
                   *   breaking changes.)
                   *
                   * Note: this functionality is not currently available in the official
                   * protobuf release, and it is not used for type URLs beginning with
                   * type.googleapis.com.
                   *
                   * Schemes other than `http`, `https` (or the empty scheme) might be
                   * used with implementation specific semantics.
                   */
                  type_url?: string;
                  /**
                   * Format: byte
                   * @description Must be a valid serialized protocol buffer of the above specified type.
                   */
                  value?: string;
                };
                /** @description jailed defined whether the validator has been jailed from bonded status or not. */
                jailed?: boolean;
                /**
                 * @description status is the validator status (bonded/unbonding/unbonded).
                 * @default BOND_STATUS_UNSPECIFIED
                 * @enum {string}
                 */
                status?:
                  | "BOND_STATUS_UNSPECIFIED"
                  | "BOND_STATUS_UNBONDED"
                  | "BOND_STATUS_UNBONDING"
                  | "BOND_STATUS_BONDED";
                /** @description tokens define the delegated tokens (incl. self-delegation). */
                tokens?: string;
                /** @description delegator_shares defines total shares issued to a validator's delegators. */
                delegator_shares?: string;
                /** @description description defines the description terms for the validator. */
                description?: {
                  /** @description moniker defines a human-readable name for the validator. */
                  moniker?: string;
                  /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                  identity?: string;
                  /** @description website defines an optional website link. */
                  website?: string;
                  /** @description security_contact defines an optional email for security contact. */
                  security_contact?: string;
                  /** @description details define other optional details. */
                  details?: string;
                };
                /**
                 * Format: int64
                 * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
                 */
                unbonding_height?: string;
                /**
                 * Format: date-time
                 * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
                 */
                unbonding_time?: string;
                /** @description commission defines the commission parameters. */
                commission?: {
                  /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                  commission_rates?: {
                    /** @description rate is the commission rate charged to delegators, as a fraction. */
                    rate?: string;
                    /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                    max_rate?: string;
                    /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                    max_change_rate?: string;
                  };
                  /**
                   * Format: date-time
                   * @description update_time is the last time the commission rate was changed.
                   */
                  update_time?: string;
                };
                /**
                 * @description min_self_delegation is the validator's self declared minimum self delegation.
                 *
                 * Since: cosmos-sdk 0.46
                 */
                min_self_delegation?: string;
                /**
                 * strictly positive if this validator's unbonding has been stopped by external modules
                 * Format: int64
                 */
                unbonding_on_hold_ref_count?: string;
                /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
                unbonding_ids?: string[];
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Parameters queries the staking parameters. */
  StakingParams: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description params holds all the parameters of this module. */
            params?: {
              /** @description unbonding_time is the time duration of unbonding. */
              unbonding_time?: string;
              /**
               * Format: int64
               * @description max_validators is the maximum number of validators.
               */
              max_validators?: number;
              /**
               * Format: int64
               * @description max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
               */
              max_entries?: number;
              /**
               * Format: int64
               * @description historical_entries is the number of historical entries to persist.
               */
              historical_entries?: number;
              /** @description bond_denom defines the bondable coin denomination. */
              bond_denom?: string;
              /** min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators */
              min_commission_rate?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Pool queries the pool info. */
  Pool: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description pool defines the pool info. */
            pool?: {
              not_bonded_tokens?: string;
              bonded_tokens?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * Validators queries all validators that match the given status.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  Validators: {
    parameters: {
      query?: {
        /** @description status enables to query for validators matching a given status. */
        status?: string;
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description validators contains all the queried validators. */
            validators?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              consensus_pubkey?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** @description jailed defined whether the validator has been jailed from bonded status or not. */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status?:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /**
               * @description min_self_delegation is the validator's self declared minimum self delegation.
               *
               * Since: cosmos-sdk 0.46
               */
              min_self_delegation?: string;
              /**
               * strictly positive if this validator's unbonding has been stopped by external modules
               * Format: int64
               */
              unbonding_on_hold_ref_count?: string;
              /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
              unbonding_ids?: string[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Validator queries validator info for given validator address. */
  Validator: {
    parameters: {
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description Validator defines a validator, together with the total amount of the
             * Validator's bond shares and their exchange rate to coins. Slashing results in
             * a decrease in the exchange rate, allowing correct calculation of future
             * undelegations without iterating over delegators. When coins are delegated to
             * this validator, the validator is credited with a delegation whose number of
             * bond shares is based on the amount of coins delegated divided by the current
             * exchange rate. Voting power can be calculated as total bonded shares
             * multiplied by exchange rate.
             */
            validator?: {
              /** @description operator_address defines the address of the validator's operator; bech encoded in JSON. */
              operator_address?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              consensus_pubkey?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** @description jailed defined whether the validator has been jailed from bonded status or not. */
              jailed?: boolean;
              /**
               * @description status is the validator status (bonded/unbonding/unbonded).
               * @default BOND_STATUS_UNSPECIFIED
               * @enum {string}
               */
              status?:
                | "BOND_STATUS_UNSPECIFIED"
                | "BOND_STATUS_UNBONDED"
                | "BOND_STATUS_UNBONDING"
                | "BOND_STATUS_BONDED";
              /** @description tokens define the delegated tokens (incl. self-delegation). */
              tokens?: string;
              /** @description delegator_shares defines total shares issued to a validator's delegators. */
              delegator_shares?: string;
              /** @description description defines the description terms for the validator. */
              description?: {
                /** @description moniker defines a human-readable name for the validator. */
                moniker?: string;
                /** @description identity defines an optional identity signature (ex. UPort or Keybase). */
                identity?: string;
                /** @description website defines an optional website link. */
                website?: string;
                /** @description security_contact defines an optional email for security contact. */
                security_contact?: string;
                /** @description details define other optional details. */
                details?: string;
              };
              /**
               * Format: int64
               * @description unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.
               */
              unbonding_height?: string;
              /**
               * Format: date-time
               * @description unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.
               */
              unbonding_time?: string;
              /** @description commission defines the commission parameters. */
              commission?: {
                /** @description commission_rates defines the initial commission rates to be used for creating a validator. */
                commission_rates?: {
                  /** @description rate is the commission rate charged to delegators, as a fraction. */
                  rate?: string;
                  /** @description max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                  max_rate?: string;
                  /** @description max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                  max_change_rate?: string;
                };
                /**
                 * Format: date-time
                 * @description update_time is the last time the commission rate was changed.
                 */
                update_time?: string;
              };
              /**
               * @description min_self_delegation is the validator's self declared minimum self delegation.
               *
               * Since: cosmos-sdk 0.46
               */
              min_self_delegation?: string;
              /**
               * strictly positive if this validator's unbonding has been stopped by external modules
               * Format: int64
               */
              unbonding_on_hold_ref_count?: string;
              /** list of unbonding ids, each uniquely identifing an unbonding of this validator */
              unbonding_ids?: string[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ValidatorDelegations queries delegate info for given validator.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  ValidatorDelegations: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            delegation_responses?: {
              /**
               * @description Delegation represents the bond with tokens held by an account. It is
               * owned by one delegator, and is associated with the voting power of one
               * validator.
               */
              delegation?: {
                /** @description delegator_address is the encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_address is the encoded address of the validator. */
                validator_address?: string;
                /** @description shares define the delegation shares received. */
                shares?: string;
              };
              /**
               * @description Coin defines a token with a denomination and an amount.
               *
               * NOTE: The amount field is an Int which implements the custom method
               * signatures required by gogoproto.
               */
              balance?: {
                denom?: string;
                amount?: string;
              };
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Delegation queries delegate info for given validator delegator pair. */
  Delegation: {
    parameters: {
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description DelegationResponse is equivalent to Delegation except that it contains a
             * balance in addition to shares which is more suitable for client responses.
             */
            delegation_response?: {
              /**
               * @description Delegation represents the bond with tokens held by an account. It is
               * owned by one delegator, and is associated with the voting power of one
               * validator.
               */
              delegation?: {
                /** @description delegator_address is the encoded address of the delegator. */
                delegator_address?: string;
                /** @description validator_address is the encoded address of the validator. */
                validator_address?: string;
                /** @description shares define the delegation shares received. */
                shares?: string;
              };
              /**
               * @description Coin defines a token with a denomination and an amount.
               *
               * NOTE: The amount field is an Int which implements the custom method
               * signatures required by gogoproto.
               */
              balance?: {
                denom?: string;
                amount?: string;
              };
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * UnbondingDelegation queries unbonding info for given validator delegator
   * pair.
   */
  UnbondingDelegation: {
    parameters: {
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
        /** @description delegator_addr defines the delegator address to query for. */
        delegator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description UnbondingDelegation stores all of a single delegator's unbonding bonds
             * for a single validator in an time-ordered list.
             */
            unbond?: {
              /** @description delegator_address is the encoded address of the delegator. */
              delegator_address?: string;
              /** @description validator_address is the encoded address of the validator. */
              validator_address?: string;
              /** @description entries are the unbonding delegation entries. */
              entries?: {
                /**
                 * Format: int64
                 * @description creation_height is the height which the unbonding took place.
                 */
                creation_height?: string;
                /**
                 * Format: date-time
                 * @description completion_time is the unix time for unbonding completion.
                 */
                completion_time?: string;
                /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
                initial_balance?: string;
                /** @description balance defines the tokens to receive at completion. */
                balance?: string;
                /**
                 * Incrementing id that uniquely identifies this entry
                 * Format: uint64
                 */
                unbonding_id?: string;
                /**
                 * Strictly positive if this entry's unbonding has been stopped by external modules
                 * Format: int64
                 */
                unbonding_on_hold_ref_count?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ValidatorUnbondingDelegations queries unbonding delegations of a validator.
   * @description When called from another module, this query might consume a high amount of
   * gas if the pagination field is incorrectly set.
   */
  ValidatorUnbondingDelegations: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description validator_addr defines the validator address to query for. */
        validator_addr: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            unbonding_responses?: {
              /** @description delegator_address is the encoded address of the delegator. */
              delegator_address?: string;
              /** @description validator_address is the encoded address of the validator. */
              validator_address?: string;
              /** @description entries are the unbonding delegation entries. */
              entries?: {
                /**
                 * Format: int64
                 * @description creation_height is the height which the unbonding took place.
                 */
                creation_height?: string;
                /**
                 * Format: date-time
                 * @description completion_time is the unix time for unbonding completion.
                 */
                completion_time?: string;
                /** @description initial_balance defines the tokens initially scheduled to receive at completion. */
                initial_balance?: string;
                /** @description balance defines the tokens to receive at completion. */
                balance?: string;
                /**
                 * Incrementing id that uniquely identifies this entry
                 * Format: uint64
                 */
                unbonding_id?: string;
                /**
                 * Strictly positive if this entry's unbonding has been stopped by external modules
                 * Format: int64
                 */
                unbonding_on_hold_ref_count?: string;
              }[];
            }[];
            /** @description pagination defines the pagination in the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * TxDecode decodes the transaction.
   * @description Since: cosmos-sdk 0.47
   */
  TxDecode: {
    requestBody: {
      content: {
        "*/*": {
          /**
           * Format: byte
           * @description tx_bytes is the raw transaction.
           */
          tx_bytes?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": components["schemas"]["cosmos.tx.v1beta1.TxDecodeResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.
   * @description Since: cosmos-sdk 0.47
   */
  TxDecodeAmino: {
    requestBody: {
      content: {
        "*/*": {
          /** Format: byte */
          amino_binary?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            amino_json?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * TxEncode encodes the transaction.
   * @description Since: cosmos-sdk 0.47
   */
  TxEncode: {
    requestBody: {
      content: {
        "*/*": components["schemas"]["cosmos.tx.v1beta1.TxEncodeRequest"];
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * Format: byte
             * @description tx_bytes is the encoded transaction bytes.
             */
            tx_bytes?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.
   * @description Since: cosmos-sdk 0.47
   */
  TxEncodeAmino: {
    requestBody: {
      content: {
        "*/*": {
          amino_json?: string;
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** Format: byte */
            amino_binary?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** Simulate simulates executing a transaction for estimating gas usage. */
  Simulate: {
    requestBody: {
      content: {
        "*/*": components["schemas"]["cosmos.tx.v1beta1.SimulateRequest"];
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** @description gas_info is the information about gas used in the simulation. */
            gas_info?: {
              /**
               * Format: uint64
               * @description GasWanted is the maximum units of work we allow this tx to perform.
               */
              gas_wanted?: string;
              /**
               * Format: uint64
               * @description GasUsed is the amount of gas actually consumed.
               */
              gas_used?: string;
            };
            /** @description result is the result of the simulation. */
            result?: {
              /**
               * Format: byte
               * @description Data is any data returned from message or handler execution. It MUST be
               * length prefixed in order to separate data from multiple message executions.
               * Deprecated. This field is still populated, but prefer msg_response instead
               * because it also contains the Msg response typeURL.
               */
              data?: string;
              /** @description Log contains the log information from message or handler execution. */
              log?: string;
              /**
               * @description Events contains a slice of Event objects that were emitted during message
               * or handler execution.
               */
              events?: {
                type?: string;
                attributes?: {
                  key?: string;
                  value?: string;
                  index?: boolean;
                }[];
              }[];
              /**
               * @description msg_responses contains the Msg handler responses type packed in Anys.
               *
               * Since: cosmos-sdk 0.46
               */
              msg_responses?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetTxsEvent fetches txs by event. */
  GetTxsEvent: {
    parameters: {
      query?: {
        /**
         * @description events is the list of transaction event type.
         * Deprecated post v0.47.x: use query instead, which should contain a valid
         * events query.
         */
        events?: string[];
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
        /**
         * @description  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults
         * to ASC in this case.
         *  - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
         *  - ORDER_BY_DESC: ORDER_BY_DESC defines descending order
         */
        order_by?: "ORDER_BY_UNSPECIFIED" | "ORDER_BY_ASC" | "ORDER_BY_DESC";
        /**
         * @description page is the page number to query, starts at 1. If not provided, will
         * default to first page.
         */
        page?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        limit?: string;
        /**
         * @description query defines the transaction event query that is proxied to Tendermint's
         * TxSearch RPC method. The query must be valid.
         *
         * Since cosmos-sdk 0.50
         */
        query?: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": components["schemas"]["cosmos.tx.v1beta1.GetTxsEventResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** BroadcastTx broadcast transaction. */
  BroadcastTx: {
    requestBody: {
      content: {
        "*/*": {
          /**
           * Format: byte
           * @description tx_bytes is the raw transaction.
           */
          tx_bytes?: string;
          /**
           * @description BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC
           * method.
           *
           *  - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering
           *  - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,
           * BROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.
           *  - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits
           * for a CheckTx execution response only.
           *  - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client
           * returns immediately.
           * @default BROADCAST_MODE_UNSPECIFIED
           * @enum {string}
           */
          mode?:
            | "BROADCAST_MODE_UNSPECIFIED"
            | "BROADCAST_MODE_BLOCK"
            | "BROADCAST_MODE_SYNC"
            | "BROADCAST_MODE_ASYNC";
        };
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /**
             * @description TxResponse defines a structure containing relevant tx data and metadata. The
             * tags are stringified and the log is JSON decoded.
             */
            tx_response?: {
              /**
               * The block height
               * Format: int64
               */
              height?: string;
              /** @description The transaction hash. */
              txhash?: string;
              /** Namespace for the Code */
              codespace?: string;
              /**
               * Format: int64
               * @description Response code.
               */
              code?: number;
              /** @description Result bytes, if any. */
              data?: string;
              /**
               * @description The output of the application's logger (raw string). May be
               * non-deterministic.
               */
              raw_log?: string;
              /** @description The output of the application's logger (typed). May be non-deterministic. */
              logs?: {
                /** Format: int64 */
                msg_index?: number;
                log?: string;
                /**
                 * @description Events contains a slice of Event objects that were emitted during some
                 * execution.
                 */
                events?: {
                  type?: string;
                  attributes?: {
                    key?: string;
                    value?: string;
                  }[];
                }[];
              }[];
              /** @description Additional information. May be non-deterministic. */
              info?: string;
              /**
               * Format: int64
               * @description Amount of gas requested for transaction.
               */
              gas_wanted?: string;
              /**
               * Format: int64
               * @description Amount of gas consumed by transaction.
               */
              gas_used?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              tx?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /**
               * @description Time of the previous block. For heights > 1, it's the weighted median of
               * the timestamps of the valid votes in the block.LastCommit. For height == 1,
               * it's genesis time.
               */
              timestamp?: string;
              /**
               * @description Events defines all the events emitted by processing a transaction. Note,
               * these events include those emitted by processing all the messages and those
               * emitted from the ante. Whereas Logs contains the events, with
               * additional metadata, emitted only by processing the messages.
               *
               * Since: cosmos-sdk 0.42.11, 0.44.5, 0.45
               */
              events?: {
                type?: string;
                attributes?: {
                  key?: string;
                  value?: string;
                  index?: boolean;
                }[];
              }[];
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * GetBlockWithTxs fetches a block with decoded txs.
   * @description Since: cosmos-sdk 0.45.2
   */
  GetBlockWithTxs: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        /** @description height is the height of the block to query. */
        height: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": components["schemas"]["cosmos.tx.v1beta1.GetBlockWithTxsResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetTx fetches a tx by hash. */
  GetTx: {
    parameters: {
      path: {
        /** @description hash is the tx hash to query, encoded as a hex string. */
        hash: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": components["schemas"]["cosmos.tx.v1beta1.GetTxResponse"];
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /**
   * ABCIQuery defines a query handler that supports ABCI queries directly to the
   * application, bypassing Tendermint completely. The ABCI query must contain
   * a valid and supported path, including app, custom, p2p, and store.
   * @description Since: cosmos-sdk 0.46
   */
  ABCIQuery: {
    parameters: {
      query?: {
        data?: string;
        path?: string;
        height?: string;
        prove?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** Format: int64 */
            code?: number;
            log?: string;
            info?: string;
            /** Format: int64 */
            index?: string;
            /** Format: byte */
            key?: string;
            /** Format: byte */
            value?: string;
            /**
             * @description ProofOps is Merkle proof defined by the list of ProofOps.
             *
             * Note: This type is a duplicate of the ProofOps proto type defined in Tendermint.
             */
            proof_ops?: {
              ops?: {
                type?: string;
                /** Format: byte */
                key?: string;
                /** Format: byte */
                data?: string;
              }[];
            };
            /** Format: int64 */
            height?: string;
            codespace?: string;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetLatestBlock returns the latest block. */
  GetLatestBlock: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /** Deprecated: please use `sdk_block` instead */
            block?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              /** Data contains the set of transactions included in the block */
              data?: {
                /**
                 * @description Txs that will be applied by state @ block.Height+1.
                 * NOTE: not all txs here are valid.  We're just agreeing on the order first.
                 * This means that block.AppHash does not include these txs.
                 */
                txs?: string[];
              };
              evidence?: {
                evidence?: {
                  /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                  duplicate_vote_evidence?: {
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_a?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_b?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: int64 */
                    validator_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                  /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                  light_client_attack_evidence?: {
                    conflicting_block?: {
                      signed_header?: {
                        /** @description Header defines the structure of a block header. */
                        header?: {
                          /**
                           * basic block info
                           * @description Consensus captures the consensus rules for processing a block in the blockchain,
                           * including all blockchain data structures and the rules of the application's
                           * state transition machine.
                           */
                          version?: {
                            /** Format: uint64 */
                            block?: string;
                            /** Format: uint64 */
                            app?: string;
                          };
                          chain_id?: string;
                          /** Format: int64 */
                          height?: string;
                          /** Format: date-time */
                          time?: string;
                          /** BlockID */
                          last_block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          /**
                           * hashes of block data
                           * Format: byte
                           */
                          last_commit_hash?: string;
                          /** Format: byte */
                          data_hash?: string;
                          /**
                           * hashes from the app output from the prev block
                           * Format: byte
                           */
                          validators_hash?: string;
                          /** Format: byte */
                          next_validators_hash?: string;
                          /** Format: byte */
                          consensus_hash?: string;
                          /** Format: byte */
                          app_hash?: string;
                          /** Format: byte */
                          last_results_hash?: string;
                          /**
                           * consensus info
                           * Format: byte
                           */
                          evidence_hash?: string;
                          /** Format: byte */
                          proposer_address?: string;
                        };
                        /** @description Commit contains the evidence that a block was committed by a set of validators. */
                        commit?: {
                          /** Format: int64 */
                          height?: string;
                          /** Format: int32 */
                          round?: number;
                          /** BlockID */
                          block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          signatures?: {
                            /**
                             * BlockIdFlag indicates which BlockID the signature is for
                             * @default BLOCK_ID_FLAG_UNKNOWN
                             * @enum {string}
                             */
                            block_id_flag?:
                              | "BLOCK_ID_FLAG_UNKNOWN"
                              | "BLOCK_ID_FLAG_ABSENT"
                              | "BLOCK_ID_FLAG_COMMIT"
                              | "BLOCK_ID_FLAG_NIL";
                            /** Format: byte */
                            validator_address?: string;
                            /** Format: date-time */
                            timestamp?: string;
                            /** Format: byte */
                            signature?: string;
                          }[];
                        };
                      };
                      validator_set?: {
                        validators?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        }[];
                        proposer?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        };
                        /** Format: int64 */
                        total_voting_power?: string;
                      };
                    };
                    /** Format: int64 */
                    common_height?: string;
                    byzantine_validators?: {
                      /** Format: byte */
                      address?: string;
                      /** PublicKey defines the keys available for use with Validators */
                      pub_key?: {
                        /** Format: byte */
                        ed25519?: string;
                        /** Format: byte */
                        secp256k1?: string;
                      };
                      /** Format: int64 */
                      voting_power?: string;
                      /** Format: int64 */
                      proposer_priority?: string;
                    }[];
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                }[];
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              last_commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
            /**
             * Since: cosmos-sdk 0.47
             * @description Block is tendermint type Block, with the Header proposer address
             * field converted to bech32 string.
             */
            sdk_block?: {
              /** @description Header defines the structure of a Tendermint block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /**
                 * @description proposer_address is the original block proposer address, formatted as a Bech32 string.
                 * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
                 * for better UX.
                 */
                proposer_address?: string;
              };
              /** Data contains the set of transactions included in the block */
              data?: {
                /**
                 * @description Txs that will be applied by state @ block.Height+1.
                 * NOTE: not all txs here are valid.  We're just agreeing on the order first.
                 * This means that block.AppHash does not include these txs.
                 */
                txs?: string[];
              };
              evidence?: {
                evidence?: {
                  /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                  duplicate_vote_evidence?: {
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_a?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_b?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: int64 */
                    validator_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                  /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                  light_client_attack_evidence?: {
                    conflicting_block?: {
                      signed_header?: {
                        /** @description Header defines the structure of a block header. */
                        header?: {
                          /**
                           * basic block info
                           * @description Consensus captures the consensus rules for processing a block in the blockchain,
                           * including all blockchain data structures and the rules of the application's
                           * state transition machine.
                           */
                          version?: {
                            /** Format: uint64 */
                            block?: string;
                            /** Format: uint64 */
                            app?: string;
                          };
                          chain_id?: string;
                          /** Format: int64 */
                          height?: string;
                          /** Format: date-time */
                          time?: string;
                          /** BlockID */
                          last_block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          /**
                           * hashes of block data
                           * Format: byte
                           */
                          last_commit_hash?: string;
                          /** Format: byte */
                          data_hash?: string;
                          /**
                           * hashes from the app output from the prev block
                           * Format: byte
                           */
                          validators_hash?: string;
                          /** Format: byte */
                          next_validators_hash?: string;
                          /** Format: byte */
                          consensus_hash?: string;
                          /** Format: byte */
                          app_hash?: string;
                          /** Format: byte */
                          last_results_hash?: string;
                          /**
                           * consensus info
                           * Format: byte
                           */
                          evidence_hash?: string;
                          /** Format: byte */
                          proposer_address?: string;
                        };
                        /** @description Commit contains the evidence that a block was committed by a set of validators. */
                        commit?: {
                          /** Format: int64 */
                          height?: string;
                          /** Format: int32 */
                          round?: number;
                          /** BlockID */
                          block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          signatures?: {
                            /**
                             * BlockIdFlag indicates which BlockID the signature is for
                             * @default BLOCK_ID_FLAG_UNKNOWN
                             * @enum {string}
                             */
                            block_id_flag?:
                              | "BLOCK_ID_FLAG_UNKNOWN"
                              | "BLOCK_ID_FLAG_ABSENT"
                              | "BLOCK_ID_FLAG_COMMIT"
                              | "BLOCK_ID_FLAG_NIL";
                            /** Format: byte */
                            validator_address?: string;
                            /** Format: date-time */
                            timestamp?: string;
                            /** Format: byte */
                            signature?: string;
                          }[];
                        };
                      };
                      validator_set?: {
                        validators?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        }[];
                        proposer?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        };
                        /** Format: int64 */
                        total_voting_power?: string;
                      };
                    };
                    /** Format: int64 */
                    common_height?: string;
                    byzantine_validators?: {
                      /** Format: byte */
                      address?: string;
                      /** PublicKey defines the keys available for use with Validators */
                      pub_key?: {
                        /** Format: byte */
                        ed25519?: string;
                        /** Format: byte */
                        secp256k1?: string;
                      };
                      /** Format: int64 */
                      voting_power?: string;
                      /** Format: int64 */
                      proposer_priority?: string;
                    }[];
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                }[];
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              last_commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetBlockByHeight queries block for given height. */
  GetBlockByHeight: {
    parameters: {
      path: {
        height: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** BlockID */
            block_id?: {
              /** Format: byte */
              hash?: string;
              /** PartsetHeader */
              part_set_header?: {
                /** Format: int64 */
                total?: number;
                /** Format: byte */
                hash?: string;
              };
            };
            /** Deprecated: please use `sdk_block` instead */
            block?: {
              /** @description Header defines the structure of a block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /** Format: byte */
                proposer_address?: string;
              };
              /** Data contains the set of transactions included in the block */
              data?: {
                /**
                 * @description Txs that will be applied by state @ block.Height+1.
                 * NOTE: not all txs here are valid.  We're just agreeing on the order first.
                 * This means that block.AppHash does not include these txs.
                 */
                txs?: string[];
              };
              evidence?: {
                evidence?: {
                  /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                  duplicate_vote_evidence?: {
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_a?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_b?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: int64 */
                    validator_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                  /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                  light_client_attack_evidence?: {
                    conflicting_block?: {
                      signed_header?: {
                        /** @description Header defines the structure of a block header. */
                        header?: {
                          /**
                           * basic block info
                           * @description Consensus captures the consensus rules for processing a block in the blockchain,
                           * including all blockchain data structures and the rules of the application's
                           * state transition machine.
                           */
                          version?: {
                            /** Format: uint64 */
                            block?: string;
                            /** Format: uint64 */
                            app?: string;
                          };
                          chain_id?: string;
                          /** Format: int64 */
                          height?: string;
                          /** Format: date-time */
                          time?: string;
                          /** BlockID */
                          last_block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          /**
                           * hashes of block data
                           * Format: byte
                           */
                          last_commit_hash?: string;
                          /** Format: byte */
                          data_hash?: string;
                          /**
                           * hashes from the app output from the prev block
                           * Format: byte
                           */
                          validators_hash?: string;
                          /** Format: byte */
                          next_validators_hash?: string;
                          /** Format: byte */
                          consensus_hash?: string;
                          /** Format: byte */
                          app_hash?: string;
                          /** Format: byte */
                          last_results_hash?: string;
                          /**
                           * consensus info
                           * Format: byte
                           */
                          evidence_hash?: string;
                          /** Format: byte */
                          proposer_address?: string;
                        };
                        /** @description Commit contains the evidence that a block was committed by a set of validators. */
                        commit?: {
                          /** Format: int64 */
                          height?: string;
                          /** Format: int32 */
                          round?: number;
                          /** BlockID */
                          block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          signatures?: {
                            /**
                             * BlockIdFlag indicates which BlockID the signature is for
                             * @default BLOCK_ID_FLAG_UNKNOWN
                             * @enum {string}
                             */
                            block_id_flag?:
                              | "BLOCK_ID_FLAG_UNKNOWN"
                              | "BLOCK_ID_FLAG_ABSENT"
                              | "BLOCK_ID_FLAG_COMMIT"
                              | "BLOCK_ID_FLAG_NIL";
                            /** Format: byte */
                            validator_address?: string;
                            /** Format: date-time */
                            timestamp?: string;
                            /** Format: byte */
                            signature?: string;
                          }[];
                        };
                      };
                      validator_set?: {
                        validators?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        }[];
                        proposer?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        };
                        /** Format: int64 */
                        total_voting_power?: string;
                      };
                    };
                    /** Format: int64 */
                    common_height?: string;
                    byzantine_validators?: {
                      /** Format: byte */
                      address?: string;
                      /** PublicKey defines the keys available for use with Validators */
                      pub_key?: {
                        /** Format: byte */
                        ed25519?: string;
                        /** Format: byte */
                        secp256k1?: string;
                      };
                      /** Format: int64 */
                      voting_power?: string;
                      /** Format: int64 */
                      proposer_priority?: string;
                    }[];
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                }[];
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              last_commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
            /**
             * Since: cosmos-sdk 0.47
             * @description Block is tendermint type Block, with the Header proposer address
             * field converted to bech32 string.
             */
            sdk_block?: {
              /** @description Header defines the structure of a Tendermint block header. */
              header?: {
                /**
                 * basic block info
                 * @description Consensus captures the consensus rules for processing a block in the blockchain,
                 * including all blockchain data structures and the rules of the application's
                 * state transition machine.
                 */
                version?: {
                  /** Format: uint64 */
                  block?: string;
                  /** Format: uint64 */
                  app?: string;
                };
                chain_id?: string;
                /** Format: int64 */
                height?: string;
                /** Format: date-time */
                time?: string;
                /** BlockID */
                last_block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                /**
                 * hashes of block data
                 * Format: byte
                 */
                last_commit_hash?: string;
                /** Format: byte */
                data_hash?: string;
                /**
                 * hashes from the app output from the prev block
                 * Format: byte
                 */
                validators_hash?: string;
                /** Format: byte */
                next_validators_hash?: string;
                /** Format: byte */
                consensus_hash?: string;
                /** Format: byte */
                app_hash?: string;
                /** Format: byte */
                last_results_hash?: string;
                /**
                 * consensus info
                 * Format: byte
                 */
                evidence_hash?: string;
                /**
                 * @description proposer_address is the original block proposer address, formatted as a Bech32 string.
                 * In Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string
                 * for better UX.
                 */
                proposer_address?: string;
              };
              /** Data contains the set of transactions included in the block */
              data?: {
                /**
                 * @description Txs that will be applied by state @ block.Height+1.
                 * NOTE: not all txs here are valid.  We're just agreeing on the order first.
                 * This means that block.AppHash does not include these txs.
                 */
                txs?: string[];
              };
              evidence?: {
                evidence?: {
                  /** @description DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
                  duplicate_vote_evidence?: {
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_a?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /**
                     * @description Vote represents a prevote or precommit vote from validators for
                     * consensus.
                     */
                    vote_b?: {
                      /**
                       * @description SignedMsgType is a type of signed message in the consensus.
                       *
                       *  - SIGNED_MSG_TYPE_PREVOTE: Votes
                       *  - SIGNED_MSG_TYPE_PROPOSAL: Proposals
                       * @default SIGNED_MSG_TYPE_UNKNOWN
                       * @enum {string}
                       */
                      type?:
                        | "SIGNED_MSG_TYPE_UNKNOWN"
                        | "SIGNED_MSG_TYPE_PREVOTE"
                        | "SIGNED_MSG_TYPE_PRECOMMIT"
                        | "SIGNED_MSG_TYPE_PROPOSAL";
                      /** Format: int64 */
                      height?: string;
                      /** Format: int32 */
                      round?: number;
                      /** BlockID */
                      block_id?: {
                        /** Format: byte */
                        hash?: string;
                        /** PartsetHeader */
                        part_set_header?: {
                          /** Format: int64 */
                          total?: number;
                          /** Format: byte */
                          hash?: string;
                        };
                      };
                      /** Format: date-time */
                      timestamp?: string;
                      /** Format: byte */
                      validator_address?: string;
                      /** Format: int32 */
                      validator_index?: number;
                      /**
                       * Format: byte
                       * @description Vote signature by the validator if they participated in consensus for the
                       * associated block.
                       */
                      signature?: string;
                      /**
                       * Format: byte
                       * @description Vote extension provided by the application. Only valid for precommit
                       * messages.
                       */
                      extension?: string;
                      /**
                       * Format: byte
                       * @description Vote extension signature by the validator if they participated in
                       * consensus for the associated block.
                       * Only valid for precommit messages.
                       */
                      extension_signature?: string;
                    };
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: int64 */
                    validator_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                  /** @description LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
                  light_client_attack_evidence?: {
                    conflicting_block?: {
                      signed_header?: {
                        /** @description Header defines the structure of a block header. */
                        header?: {
                          /**
                           * basic block info
                           * @description Consensus captures the consensus rules for processing a block in the blockchain,
                           * including all blockchain data structures and the rules of the application's
                           * state transition machine.
                           */
                          version?: {
                            /** Format: uint64 */
                            block?: string;
                            /** Format: uint64 */
                            app?: string;
                          };
                          chain_id?: string;
                          /** Format: int64 */
                          height?: string;
                          /** Format: date-time */
                          time?: string;
                          /** BlockID */
                          last_block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          /**
                           * hashes of block data
                           * Format: byte
                           */
                          last_commit_hash?: string;
                          /** Format: byte */
                          data_hash?: string;
                          /**
                           * hashes from the app output from the prev block
                           * Format: byte
                           */
                          validators_hash?: string;
                          /** Format: byte */
                          next_validators_hash?: string;
                          /** Format: byte */
                          consensus_hash?: string;
                          /** Format: byte */
                          app_hash?: string;
                          /** Format: byte */
                          last_results_hash?: string;
                          /**
                           * consensus info
                           * Format: byte
                           */
                          evidence_hash?: string;
                          /** Format: byte */
                          proposer_address?: string;
                        };
                        /** @description Commit contains the evidence that a block was committed by a set of validators. */
                        commit?: {
                          /** Format: int64 */
                          height?: string;
                          /** Format: int32 */
                          round?: number;
                          /** BlockID */
                          block_id?: {
                            /** Format: byte */
                            hash?: string;
                            /** PartsetHeader */
                            part_set_header?: {
                              /** Format: int64 */
                              total?: number;
                              /** Format: byte */
                              hash?: string;
                            };
                          };
                          signatures?: {
                            /**
                             * BlockIdFlag indicates which BlockID the signature is for
                             * @default BLOCK_ID_FLAG_UNKNOWN
                             * @enum {string}
                             */
                            block_id_flag?:
                              | "BLOCK_ID_FLAG_UNKNOWN"
                              | "BLOCK_ID_FLAG_ABSENT"
                              | "BLOCK_ID_FLAG_COMMIT"
                              | "BLOCK_ID_FLAG_NIL";
                            /** Format: byte */
                            validator_address?: string;
                            /** Format: date-time */
                            timestamp?: string;
                            /** Format: byte */
                            signature?: string;
                          }[];
                        };
                      };
                      validator_set?: {
                        validators?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        }[];
                        proposer?: {
                          /** Format: byte */
                          address?: string;
                          /** PublicKey defines the keys available for use with Validators */
                          pub_key?: {
                            /** Format: byte */
                            ed25519?: string;
                            /** Format: byte */
                            secp256k1?: string;
                          };
                          /** Format: int64 */
                          voting_power?: string;
                          /** Format: int64 */
                          proposer_priority?: string;
                        };
                        /** Format: int64 */
                        total_voting_power?: string;
                      };
                    };
                    /** Format: int64 */
                    common_height?: string;
                    byzantine_validators?: {
                      /** Format: byte */
                      address?: string;
                      /** PublicKey defines the keys available for use with Validators */
                      pub_key?: {
                        /** Format: byte */
                        ed25519?: string;
                        /** Format: byte */
                        secp256k1?: string;
                      };
                      /** Format: int64 */
                      voting_power?: string;
                      /** Format: int64 */
                      proposer_priority?: string;
                    }[];
                    /** Format: int64 */
                    total_voting_power?: string;
                    /** Format: date-time */
                    timestamp?: string;
                  };
                }[];
              };
              /** @description Commit contains the evidence that a block was committed by a set of validators. */
              last_commit?: {
                /** Format: int64 */
                height?: string;
                /** Format: int32 */
                round?: number;
                /** BlockID */
                block_id?: {
                  /** Format: byte */
                  hash?: string;
                  /** PartsetHeader */
                  part_set_header?: {
                    /** Format: int64 */
                    total?: number;
                    /** Format: byte */
                    hash?: string;
                  };
                };
                signatures?: {
                  /**
                   * BlockIdFlag indicates which BlockID the signature is for
                   * @default BLOCK_ID_FLAG_UNKNOWN
                   * @enum {string}
                   */
                  block_id_flag?:
                    | "BLOCK_ID_FLAG_UNKNOWN"
                    | "BLOCK_ID_FLAG_ABSENT"
                    | "BLOCK_ID_FLAG_COMMIT"
                    | "BLOCK_ID_FLAG_NIL";
                  /** Format: byte */
                  validator_address?: string;
                  /** Format: date-time */
                  timestamp?: string;
                  /** Format: byte */
                  signature?: string;
                }[];
              };
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetNodeInfo queries the current node info. */
  GetNodeInfo: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            default_node_info?: {
              protocol_version?: {
                /** Format: uint64 */
                p2p?: string;
                /** Format: uint64 */
                block?: string;
                /** Format: uint64 */
                app?: string;
              };
              default_node_id?: string;
              listen_addr?: string;
              network?: string;
              version?: string;
              /** Format: byte */
              channels?: string;
              moniker?: string;
              other?: {
                tx_index?: string;
                rpc_address?: string;
              };
            };
            /** @description VersionInfo is the type for the GetNodeInfoResponse message. */
            application_version?: {
              name?: string;
              app_name?: string;
              version?: string;
              git_commit?: string;
              build_tags?: string;
              go_version?: string;
              build_deps?: {
                /** module path */
                path?: string;
                /** module version */
                version?: string;
                /** checksum */
                sum?: string;
              }[];
              /** Since: cosmos-sdk 0.43 */
              cosmos_sdk_version?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetSyncing queries node syncing. */
  GetSyncing: {
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            syncing?: boolean;
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetLatestValidatorSet queries latest validator-set. */
  GetLatestValidatorSet: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** Format: int64 */
            block_height?: string;
            validators?: {
              address?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              pub_key?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
  /** GetValidatorSetByHeight queries validator-set at a given height. */
  GetValidatorSetByHeight: {
    parameters: {
      query?: {
        /**
         * @description key is a value returned in PageResponse.next_key to begin
         * querying the next page most efficiently. Only one of offset or key
         * should be set.
         */
        "pagination.key"?: string;
        /**
         * @description offset is a numeric offset that can be used when key is unavailable.
         * It is less efficient than using key. Only one of offset or key should
         * be set.
         */
        "pagination.offset"?: string;
        /**
         * @description limit is the total number of results to be returned in the result page.
         * If left empty it will default to a value to be set by each app.
         */
        "pagination.limit"?: string;
        /**
         * @description count_total is set to true  to indicate that the result set should include
         * a count of the total number of items available for pagination in UIs.
         * count_total is only respected when offset is used. It is ignored when key
         * is set.
         */
        "pagination.count_total"?: boolean;
        /**
         * @description reverse is set to true if results are to be returned in the descending order.
         *
         * Since: cosmos-sdk 0.43
         */
        "pagination.reverse"?: boolean;
      };
      path: {
        height: string;
      };
    };
    responses: {
      /** @description A successful response. */
      200: {
        content: {
          "*/*": {
            /** Format: int64 */
            block_height?: string;
            validators?: {
              address?: string;
              /**
               * @description `Any` contains an arbitrary serialized protocol buffer message along with a
               * URL that describes the type of the serialized message.
               *
               * Protobuf library provides support to pack/unpack Any values in the form
               * of utility functions or additional generated methods of the Any type.
               *
               * Example 1: Pack and unpack a message in C++.
               *
               *     Foo foo = ...;
               *     Any any;
               *     any.PackFrom(foo);
               *     ...
               *     if (any.UnpackTo(&foo)) {
               *       ...
               *     }
               *
               * Example 2: Pack and unpack a message in Java.
               *
               *     Foo foo = ...;
               *     Any any = Any.pack(foo);
               *     ...
               *     if (any.is(Foo.class)) {
               *       foo = any.unpack(Foo.class);
               *     }
               *
               * Example 3: Pack and unpack a message in Python.
               *
               *     foo = Foo(...)
               *     any = Any()
               *     any.Pack(foo)
               *     ...
               *     if any.Is(Foo.DESCRIPTOR):
               *       any.Unpack(foo)
               *       ...
               *
               * Example 4: Pack and unpack a message in Go
               *
               *      foo := &pb.Foo{...}
               *      any, err := anypb.New(foo)
               *      if err != nil {
               *        ...
               *      }
               *      ...
               *      foo := &pb.Foo{}
               *      if err := any.UnmarshalTo(foo); err != nil {
               *        ...
               *      }
               *
               * The pack methods provided by protobuf library will by default use
               * 'type.googleapis.com/full.type.name' as the type URL and the unpack
               * methods only use the fully qualified type name after the last '/'
               * in the type URL, for example "foo.bar.com/x/y.z" will yield type
               * name "y.z".
               *
               *
               * JSON
               *
               * The JSON representation of an `Any` value uses the regular
               * representation of the deserialized, embedded message, with an
               * additional field `@type` which contains the type URL. Example:
               *
               *     package google.profile;
               *     message Person {
               *       string first_name = 1;
               *       string last_name = 2;
               *     }
               *
               *     {
               *       "@type": "type.googleapis.com/google.profile.Person",
               *       "firstName": <string>,
               *       "lastName": <string>
               *     }
               *
               * If the embedded message type is well-known and has a custom JSON
               * representation, that representation will be embedded adding a field
               * `value` which holds the custom JSON in addition to the `@type`
               * field. Example (for message [google.protobuf.Duration][]):
               *
               *     {
               *       "@type": "type.googleapis.com/google.protobuf.Duration",
               *       "value": "1.212s"
               *     }
               */
              pub_key?: {
                /**
                 * @description A URL/resource name that uniquely identifies the type of the serialized
                 * protocol buffer message. This string must contain at least
                 * one "/" character. The last segment of the URL's path must represent
                 * the fully qualified name of the type (as in
                 * `path/google.protobuf.Duration`). The name should be in a canonical form
                 * (e.g., leading "." is not accepted).
                 *
                 * In practice, teams usually precompile into the binary all types that they
                 * expect it to use in the context of Any. However, for URLs which use the
                 * scheme `http`, `https`, or no scheme, one can optionally set up a type
                 * server that maps type URLs to message definitions as follows:
                 *
                 * * If no scheme is provided, `https` is assumed.
                 * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                 *   value in binary format, or produce an error.
                 * * Applications are allowed to cache lookup results based on the
                 *   URL, or have them precompiled into a binary to avoid any
                 *   lookup. Therefore, binary compatibility needs to be preserved
                 *   on changes to types. (Use versioned type names to manage
                 *   breaking changes.)
                 *
                 * Note: this functionality is not currently available in the official
                 * protobuf release, and it is not used for type URLs beginning with
                 * type.googleapis.com.
                 *
                 * Schemes other than `http`, `https` (or the empty scheme) might be
                 * used with implementation specific semantics.
                 */
                type_url?: string;
                /**
                 * Format: byte
                 * @description Must be a valid serialized protocol buffer of the above specified type.
                 */
                value?: string;
              };
              /** Format: int64 */
              voting_power?: string;
              /** Format: int64 */
              proposer_priority?: string;
            }[];
            /** @description pagination defines an pagination for the response. */
            pagination?: {
              /**
               * Format: byte
               * @description next_key is the key to be passed to PageRequest.key to
               * query the next page most efficiently. It will be empty if
               * there are no more results.
               */
              next_key?: string;
              /**
               * total is total number of results available if PageRequest.count_total
               * was set, its value is undefined otherwise
               * Format: uint64
               */
              total?: string;
            };
          };
        };
      };
      /** @description An unexpected error response. */
      default: {
        content: {
          "*/*": {
            error?: string;
            /** Format: int32 */
            code?: number;
            message?: string;
            details?: {
              /**
               * @description A URL/resource name that uniquely identifies the type of the serialized
               * protocol buffer message. This string must contain at least
               * one "/" character. The last segment of the URL's path must represent
               * the fully qualified name of the type (as in
               * `path/google.protobuf.Duration`). The name should be in a canonical form
               * (e.g., leading "." is not accepted).
               *
               * In practice, teams usually precompile into the binary all types that they
               * expect it to use in the context of Any. However, for URLs which use the
               * scheme `http`, `https`, or no scheme, one can optionally set up a type
               * server that maps type URLs to message definitions as follows:
               *
               * * If no scheme is provided, `https` is assumed.
               * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
               *   value in binary format, or produce an error.
               * * Applications are allowed to cache lookup results based on the
               *   URL, or have them precompiled into a binary to avoid any
               *   lookup. Therefore, binary compatibility needs to be preserved
               *   on changes to types. (Use versioned type names to manage
               *   breaking changes.)
               *
               * Note: this functionality is not currently available in the official
               * protobuf release, and it is not used for type URLs beginning with
               * type.googleapis.com.
               *
               * Schemes other than `http`, `https` (or the empty scheme) might be
               * used with implementation specific semantics.
               */
              type_url?: string;
              /**
               * Format: byte
               * @description Must be a valid serialized protocol buffer of the above specified type.
               */
              value?: string;
            }[];
          };
        };
      };
    };
  };
}
